
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Otp
 * 
 */
export type Otp = $Result.DefaultSelection<Prisma.$OtpPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model ReorderRule
 * 
 */
export type ReorderRule = $Result.DefaultSelection<Prisma.$ReorderRulePayload>
/**
 * Model Warehouse
 * 
 */
export type Warehouse = $Result.DefaultSelection<Prisma.$WarehousePayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model StockQuant
 * 
 */
export type StockQuant = $Result.DefaultSelection<Prisma.$StockQuantPayload>
/**
 * Model Receipt
 * 
 */
export type Receipt = $Result.DefaultSelection<Prisma.$ReceiptPayload>
/**
 * Model ReceiptLine
 * 
 */
export type ReceiptLine = $Result.DefaultSelection<Prisma.$ReceiptLinePayload>
/**
 * Model Delivery
 * 
 */
export type Delivery = $Result.DefaultSelection<Prisma.$DeliveryPayload>
/**
 * Model DeliveryLine
 * 
 */
export type DeliveryLine = $Result.DefaultSelection<Prisma.$DeliveryLinePayload>
/**
 * Model Transfer
 * 
 */
export type Transfer = $Result.DefaultSelection<Prisma.$TransferPayload>
/**
 * Model TransferLine
 * 
 */
export type TransferLine = $Result.DefaultSelection<Prisma.$TransferLinePayload>
/**
 * Model Adjustment
 * 
 */
export type Adjustment = $Result.DefaultSelection<Prisma.$AdjustmentPayload>
/**
 * Model AdjustmentLine
 * 
 */
export type AdjustmentLine = $Result.DefaultSelection<Prisma.$AdjustmentLinePayload>
/**
 * Model StockMove
 * 
 */
export type StockMove = $Result.DefaultSelection<Prisma.$StockMovePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const DocumentStatus: {
  draft: 'draft',
  waiting: 'waiting',
  ready: 'ready',
  done: 'done',
  cancelled: 'cancelled'
};

export type DocumentStatus = (typeof DocumentStatus)[keyof typeof DocumentStatus]

}

export type DocumentStatus = $Enums.DocumentStatus

export const DocumentStatus: typeof $Enums.DocumentStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.otp`: Exposes CRUD operations for the **Otp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otps
    * const otps = await prisma.otp.findMany()
    * ```
    */
  get otp(): Prisma.OtpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reorderRule`: Exposes CRUD operations for the **ReorderRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReorderRules
    * const reorderRules = await prisma.reorderRule.findMany()
    * ```
    */
  get reorderRule(): Prisma.ReorderRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warehouse`: Exposes CRUD operations for the **Warehouse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Warehouses
    * const warehouses = await prisma.warehouse.findMany()
    * ```
    */
  get warehouse(): Prisma.WarehouseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockQuant`: Exposes CRUD operations for the **StockQuant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockQuants
    * const stockQuants = await prisma.stockQuant.findMany()
    * ```
    */
  get stockQuant(): Prisma.StockQuantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.receipt`: Exposes CRUD operations for the **Receipt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Receipts
    * const receipts = await prisma.receipt.findMany()
    * ```
    */
  get receipt(): Prisma.ReceiptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.receiptLine`: Exposes CRUD operations for the **ReceiptLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReceiptLines
    * const receiptLines = await prisma.receiptLine.findMany()
    * ```
    */
  get receiptLine(): Prisma.ReceiptLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.delivery`: Exposes CRUD operations for the **Delivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deliveries
    * const deliveries = await prisma.delivery.findMany()
    * ```
    */
  get delivery(): Prisma.DeliveryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryLine`: Exposes CRUD operations for the **DeliveryLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryLines
    * const deliveryLines = await prisma.deliveryLine.findMany()
    * ```
    */
  get deliveryLine(): Prisma.DeliveryLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transfer`: Exposes CRUD operations for the **Transfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transfers
    * const transfers = await prisma.transfer.findMany()
    * ```
    */
  get transfer(): Prisma.TransferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transferLine`: Exposes CRUD operations for the **TransferLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransferLines
    * const transferLines = await prisma.transferLine.findMany()
    * ```
    */
  get transferLine(): Prisma.TransferLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adjustment`: Exposes CRUD operations for the **Adjustment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Adjustments
    * const adjustments = await prisma.adjustment.findMany()
    * ```
    */
  get adjustment(): Prisma.AdjustmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adjustmentLine`: Exposes CRUD operations for the **AdjustmentLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdjustmentLines
    * const adjustmentLines = await prisma.adjustmentLine.findMany()
    * ```
    */
  get adjustmentLine(): Prisma.AdjustmentLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockMove`: Exposes CRUD operations for the **StockMove** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockMoves
    * const stockMoves = await prisma.stockMove.findMany()
    * ```
    */
  get stockMove(): Prisma.StockMoveDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.0.0
   * Query Engine version: 0c19ccc313cf9911a90d99d2ac2eb0280c76c513
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Otp: 'Otp',
    Product: 'Product',
    Category: 'Category',
    ReorderRule: 'ReorderRule',
    Warehouse: 'Warehouse',
    Location: 'Location',
    StockQuant: 'StockQuant',
    Receipt: 'Receipt',
    ReceiptLine: 'ReceiptLine',
    Delivery: 'Delivery',
    DeliveryLine: 'DeliveryLine',
    Transfer: 'Transfer',
    TransferLine: 'TransferLine',
    Adjustment: 'Adjustment',
    AdjustmentLine: 'AdjustmentLine',
    StockMove: 'StockMove'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "otp" | "product" | "category" | "reorderRule" | "warehouse" | "location" | "stockQuant" | "receipt" | "receiptLine" | "delivery" | "deliveryLine" | "transfer" | "transferLine" | "adjustment" | "adjustmentLine" | "stockMove"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Otp: {
        payload: Prisma.$OtpPayload<ExtArgs>
        fields: Prisma.OtpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findFirst: {
            args: Prisma.OtpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findMany: {
            args: Prisma.OtpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          create: {
            args: Prisma.OtpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          createMany: {
            args: Prisma.OtpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OtpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          delete: {
            args: Prisma.OtpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          update: {
            args: Prisma.OtpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          deleteMany: {
            args: Prisma.OtpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OtpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OtpUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          upsert: {
            args: Prisma.OtpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          aggregate: {
            args: Prisma.OtpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtp>
          }
          groupBy: {
            args: Prisma.OtpGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtpGroupByOutputType>[]
          }
          count: {
            args: Prisma.OtpCountArgs<ExtArgs>
            result: $Utils.Optional<OtpCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      ReorderRule: {
        payload: Prisma.$ReorderRulePayload<ExtArgs>
        fields: Prisma.ReorderRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReorderRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReorderRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReorderRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReorderRulePayload>
          }
          findFirst: {
            args: Prisma.ReorderRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReorderRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReorderRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReorderRulePayload>
          }
          findMany: {
            args: Prisma.ReorderRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReorderRulePayload>[]
          }
          create: {
            args: Prisma.ReorderRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReorderRulePayload>
          }
          createMany: {
            args: Prisma.ReorderRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReorderRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReorderRulePayload>[]
          }
          delete: {
            args: Prisma.ReorderRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReorderRulePayload>
          }
          update: {
            args: Prisma.ReorderRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReorderRulePayload>
          }
          deleteMany: {
            args: Prisma.ReorderRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReorderRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReorderRuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReorderRulePayload>[]
          }
          upsert: {
            args: Prisma.ReorderRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReorderRulePayload>
          }
          aggregate: {
            args: Prisma.ReorderRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReorderRule>
          }
          groupBy: {
            args: Prisma.ReorderRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReorderRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReorderRuleCountArgs<ExtArgs>
            result: $Utils.Optional<ReorderRuleCountAggregateOutputType> | number
          }
        }
      }
      Warehouse: {
        payload: Prisma.$WarehousePayload<ExtArgs>
        fields: Prisma.WarehouseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findFirst: {
            args: Prisma.WarehouseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findMany: {
            args: Prisma.WarehouseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          create: {
            args: Prisma.WarehouseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          createMany: {
            args: Prisma.WarehouseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarehouseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          delete: {
            args: Prisma.WarehouseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          update: {
            args: Prisma.WarehouseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          deleteMany: {
            args: Prisma.WarehouseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WarehouseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          upsert: {
            args: Prisma.WarehouseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          aggregate: {
            args: Prisma.WarehouseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouse>
          }
          groupBy: {
            args: Prisma.WarehouseGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      StockQuant: {
        payload: Prisma.$StockQuantPayload<ExtArgs>
        fields: Prisma.StockQuantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockQuantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockQuantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockQuantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockQuantPayload>
          }
          findFirst: {
            args: Prisma.StockQuantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockQuantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockQuantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockQuantPayload>
          }
          findMany: {
            args: Prisma.StockQuantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockQuantPayload>[]
          }
          create: {
            args: Prisma.StockQuantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockQuantPayload>
          }
          createMany: {
            args: Prisma.StockQuantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockQuantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockQuantPayload>[]
          }
          delete: {
            args: Prisma.StockQuantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockQuantPayload>
          }
          update: {
            args: Prisma.StockQuantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockQuantPayload>
          }
          deleteMany: {
            args: Prisma.StockQuantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockQuantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockQuantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockQuantPayload>[]
          }
          upsert: {
            args: Prisma.StockQuantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockQuantPayload>
          }
          aggregate: {
            args: Prisma.StockQuantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockQuant>
          }
          groupBy: {
            args: Prisma.StockQuantGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockQuantGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockQuantCountArgs<ExtArgs>
            result: $Utils.Optional<StockQuantCountAggregateOutputType> | number
          }
        }
      }
      Receipt: {
        payload: Prisma.$ReceiptPayload<ExtArgs>
        fields: Prisma.ReceiptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReceiptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReceiptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          findFirst: {
            args: Prisma.ReceiptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReceiptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          findMany: {
            args: Prisma.ReceiptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
          }
          create: {
            args: Prisma.ReceiptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          createMany: {
            args: Prisma.ReceiptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReceiptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
          }
          delete: {
            args: Prisma.ReceiptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          update: {
            args: Prisma.ReceiptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          deleteMany: {
            args: Prisma.ReceiptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReceiptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReceiptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
          }
          upsert: {
            args: Prisma.ReceiptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          aggregate: {
            args: Prisma.ReceiptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReceipt>
          }
          groupBy: {
            args: Prisma.ReceiptGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReceiptGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReceiptCountArgs<ExtArgs>
            result: $Utils.Optional<ReceiptCountAggregateOutputType> | number
          }
        }
      }
      ReceiptLine: {
        payload: Prisma.$ReceiptLinePayload<ExtArgs>
        fields: Prisma.ReceiptLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReceiptLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReceiptLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptLinePayload>
          }
          findFirst: {
            args: Prisma.ReceiptLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReceiptLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptLinePayload>
          }
          findMany: {
            args: Prisma.ReceiptLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptLinePayload>[]
          }
          create: {
            args: Prisma.ReceiptLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptLinePayload>
          }
          createMany: {
            args: Prisma.ReceiptLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReceiptLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptLinePayload>[]
          }
          delete: {
            args: Prisma.ReceiptLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptLinePayload>
          }
          update: {
            args: Prisma.ReceiptLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptLinePayload>
          }
          deleteMany: {
            args: Prisma.ReceiptLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReceiptLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReceiptLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptLinePayload>[]
          }
          upsert: {
            args: Prisma.ReceiptLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptLinePayload>
          }
          aggregate: {
            args: Prisma.ReceiptLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReceiptLine>
          }
          groupBy: {
            args: Prisma.ReceiptLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReceiptLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReceiptLineCountArgs<ExtArgs>
            result: $Utils.Optional<ReceiptLineCountAggregateOutputType> | number
          }
        }
      }
      Delivery: {
        payload: Prisma.$DeliveryPayload<ExtArgs>
        fields: Prisma.DeliveryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          findFirst: {
            args: Prisma.DeliveryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          findMany: {
            args: Prisma.DeliveryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>[]
          }
          create: {
            args: Prisma.DeliveryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          createMany: {
            args: Prisma.DeliveryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>[]
          }
          delete: {
            args: Prisma.DeliveryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          update: {
            args: Prisma.DeliveryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>[]
          }
          upsert: {
            args: Prisma.DeliveryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          aggregate: {
            args: Prisma.DeliveryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDelivery>
          }
          groupBy: {
            args: Prisma.DeliveryGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryCountAggregateOutputType> | number
          }
        }
      }
      DeliveryLine: {
        payload: Prisma.$DeliveryLinePayload<ExtArgs>
        fields: Prisma.DeliveryLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLinePayload>
          }
          findFirst: {
            args: Prisma.DeliveryLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLinePayload>
          }
          findMany: {
            args: Prisma.DeliveryLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLinePayload>[]
          }
          create: {
            args: Prisma.DeliveryLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLinePayload>
          }
          createMany: {
            args: Prisma.DeliveryLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLinePayload>[]
          }
          delete: {
            args: Prisma.DeliveryLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLinePayload>
          }
          update: {
            args: Prisma.DeliveryLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLinePayload>
          }
          deleteMany: {
            args: Prisma.DeliveryLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLinePayload>[]
          }
          upsert: {
            args: Prisma.DeliveryLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLinePayload>
          }
          aggregate: {
            args: Prisma.DeliveryLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryLine>
          }
          groupBy: {
            args: Prisma.DeliveryLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryLineCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryLineCountAggregateOutputType> | number
          }
        }
      }
      Transfer: {
        payload: Prisma.$TransferPayload<ExtArgs>
        fields: Prisma.TransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findFirst: {
            args: Prisma.TransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findMany: {
            args: Prisma.TransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          create: {
            args: Prisma.TransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          createMany: {
            args: Prisma.TransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          delete: {
            args: Prisma.TransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          update: {
            args: Prisma.TransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          deleteMany: {
            args: Prisma.TransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          upsert: {
            args: Prisma.TransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          aggregate: {
            args: Prisma.TransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransfer>
          }
          groupBy: {
            args: Prisma.TransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferCountArgs<ExtArgs>
            result: $Utils.Optional<TransferCountAggregateOutputType> | number
          }
        }
      }
      TransferLine: {
        payload: Prisma.$TransferLinePayload<ExtArgs>
        fields: Prisma.TransferLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferLinePayload>
          }
          findFirst: {
            args: Prisma.TransferLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferLinePayload>
          }
          findMany: {
            args: Prisma.TransferLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferLinePayload>[]
          }
          create: {
            args: Prisma.TransferLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferLinePayload>
          }
          createMany: {
            args: Prisma.TransferLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransferLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferLinePayload>[]
          }
          delete: {
            args: Prisma.TransferLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferLinePayload>
          }
          update: {
            args: Prisma.TransferLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferLinePayload>
          }
          deleteMany: {
            args: Prisma.TransferLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransferLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransferLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferLinePayload>[]
          }
          upsert: {
            args: Prisma.TransferLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferLinePayload>
          }
          aggregate: {
            args: Prisma.TransferLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransferLine>
          }
          groupBy: {
            args: Prisma.TransferLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransferLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferLineCountArgs<ExtArgs>
            result: $Utils.Optional<TransferLineCountAggregateOutputType> | number
          }
        }
      }
      Adjustment: {
        payload: Prisma.$AdjustmentPayload<ExtArgs>
        fields: Prisma.AdjustmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdjustmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdjustmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdjustmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdjustmentPayload>
          }
          findFirst: {
            args: Prisma.AdjustmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdjustmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdjustmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdjustmentPayload>
          }
          findMany: {
            args: Prisma.AdjustmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdjustmentPayload>[]
          }
          create: {
            args: Prisma.AdjustmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdjustmentPayload>
          }
          createMany: {
            args: Prisma.AdjustmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdjustmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdjustmentPayload>[]
          }
          delete: {
            args: Prisma.AdjustmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdjustmentPayload>
          }
          update: {
            args: Prisma.AdjustmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdjustmentPayload>
          }
          deleteMany: {
            args: Prisma.AdjustmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdjustmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdjustmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdjustmentPayload>[]
          }
          upsert: {
            args: Prisma.AdjustmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdjustmentPayload>
          }
          aggregate: {
            args: Prisma.AdjustmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdjustment>
          }
          groupBy: {
            args: Prisma.AdjustmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdjustmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdjustmentCountArgs<ExtArgs>
            result: $Utils.Optional<AdjustmentCountAggregateOutputType> | number
          }
        }
      }
      AdjustmentLine: {
        payload: Prisma.$AdjustmentLinePayload<ExtArgs>
        fields: Prisma.AdjustmentLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdjustmentLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdjustmentLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdjustmentLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdjustmentLinePayload>
          }
          findFirst: {
            args: Prisma.AdjustmentLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdjustmentLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdjustmentLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdjustmentLinePayload>
          }
          findMany: {
            args: Prisma.AdjustmentLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdjustmentLinePayload>[]
          }
          create: {
            args: Prisma.AdjustmentLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdjustmentLinePayload>
          }
          createMany: {
            args: Prisma.AdjustmentLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdjustmentLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdjustmentLinePayload>[]
          }
          delete: {
            args: Prisma.AdjustmentLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdjustmentLinePayload>
          }
          update: {
            args: Prisma.AdjustmentLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdjustmentLinePayload>
          }
          deleteMany: {
            args: Prisma.AdjustmentLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdjustmentLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdjustmentLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdjustmentLinePayload>[]
          }
          upsert: {
            args: Prisma.AdjustmentLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdjustmentLinePayload>
          }
          aggregate: {
            args: Prisma.AdjustmentLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdjustmentLine>
          }
          groupBy: {
            args: Prisma.AdjustmentLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdjustmentLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdjustmentLineCountArgs<ExtArgs>
            result: $Utils.Optional<AdjustmentLineCountAggregateOutputType> | number
          }
        }
      }
      StockMove: {
        payload: Prisma.$StockMovePayload<ExtArgs>
        fields: Prisma.StockMoveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockMoveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockMoveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovePayload>
          }
          findFirst: {
            args: Prisma.StockMoveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockMoveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovePayload>
          }
          findMany: {
            args: Prisma.StockMoveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovePayload>[]
          }
          create: {
            args: Prisma.StockMoveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovePayload>
          }
          createMany: {
            args: Prisma.StockMoveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockMoveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovePayload>[]
          }
          delete: {
            args: Prisma.StockMoveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovePayload>
          }
          update: {
            args: Prisma.StockMoveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovePayload>
          }
          deleteMany: {
            args: Prisma.StockMoveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockMoveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockMoveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovePayload>[]
          }
          upsert: {
            args: Prisma.StockMoveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovePayload>
          }
          aggregate: {
            args: Prisma.StockMoveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockMove>
          }
          groupBy: {
            args: Prisma.StockMoveGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockMoveGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockMoveCountArgs<ExtArgs>
            result: $Utils.Optional<StockMoveCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    otp?: OtpOmit
    product?: ProductOmit
    category?: CategoryOmit
    reorderRule?: ReorderRuleOmit
    warehouse?: WarehouseOmit
    location?: LocationOmit
    stockQuant?: StockQuantOmit
    receipt?: ReceiptOmit
    receiptLine?: ReceiptLineOmit
    delivery?: DeliveryOmit
    deliveryLine?: DeliveryLineOmit
    transfer?: TransferOmit
    transferLine?: TransferLineOmit
    adjustment?: AdjustmentOmit
    adjustmentLine?: AdjustmentLineOmit
    stockMove?: StockMoveOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    receiptsCreated: number
    deliveriesCreated: number
    transfersCreated: number
    adjustmentsCreated: number
    stockMovesCreated: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receiptsCreated?: boolean | UserCountOutputTypeCountReceiptsCreatedArgs
    deliveriesCreated?: boolean | UserCountOutputTypeCountDeliveriesCreatedArgs
    transfersCreated?: boolean | UserCountOutputTypeCountTransfersCreatedArgs
    adjustmentsCreated?: boolean | UserCountOutputTypeCountAdjustmentsCreatedArgs
    stockMovesCreated?: boolean | UserCountOutputTypeCountStockMovesCreatedArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceiptsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceiptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeliveriesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransfersCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdjustmentsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdjustmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStockMovesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMoveWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    stockQuants: number
    stockMoves: number
    receiptLines: number
    deliveryLines: number
    transferLines: number
    adjustmentLines: number
    reorderRules: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockQuants?: boolean | ProductCountOutputTypeCountStockQuantsArgs
    stockMoves?: boolean | ProductCountOutputTypeCountStockMovesArgs
    receiptLines?: boolean | ProductCountOutputTypeCountReceiptLinesArgs
    deliveryLines?: boolean | ProductCountOutputTypeCountDeliveryLinesArgs
    transferLines?: boolean | ProductCountOutputTypeCountTransferLinesArgs
    adjustmentLines?: boolean | ProductCountOutputTypeCountAdjustmentLinesArgs
    reorderRules?: boolean | ProductCountOutputTypeCountReorderRulesArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountStockQuantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockQuantWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountStockMovesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMoveWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountReceiptLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceiptLineWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountDeliveryLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryLineWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountTransferLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferLineWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountAdjustmentLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdjustmentLineWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountReorderRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReorderRuleWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    products: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type WarehouseCountOutputType
   */

  export type WarehouseCountOutputType = {
    locations: number
    stockQuants: number
    receipts: number
    deliveries: number
    transfersFrom: number
    transfersTo: number
    adjustments: number
    stockMovesFrom: number
    stockMovesTo: number
    reorderRules: number
  }

  export type WarehouseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | WarehouseCountOutputTypeCountLocationsArgs
    stockQuants?: boolean | WarehouseCountOutputTypeCountStockQuantsArgs
    receipts?: boolean | WarehouseCountOutputTypeCountReceiptsArgs
    deliveries?: boolean | WarehouseCountOutputTypeCountDeliveriesArgs
    transfersFrom?: boolean | WarehouseCountOutputTypeCountTransfersFromArgs
    transfersTo?: boolean | WarehouseCountOutputTypeCountTransfersToArgs
    adjustments?: boolean | WarehouseCountOutputTypeCountAdjustmentsArgs
    stockMovesFrom?: boolean | WarehouseCountOutputTypeCountStockMovesFromArgs
    stockMovesTo?: boolean | WarehouseCountOutputTypeCountStockMovesToArgs
    reorderRules?: boolean | WarehouseCountOutputTypeCountReorderRulesArgs
  }

  // Custom InputTypes
  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseCountOutputType
     */
    select?: WarehouseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountStockQuantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockQuantWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceiptWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountTransfersFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountTransfersToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdjustmentWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountStockMovesFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMoveWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountStockMovesToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMoveWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountReorderRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReorderRuleWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    stockQuants: number
    stockMovesFrom: number
    stockMovesTo: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockQuants?: boolean | LocationCountOutputTypeCountStockQuantsArgs
    stockMovesFrom?: boolean | LocationCountOutputTypeCountStockMovesFromArgs
    stockMovesTo?: boolean | LocationCountOutputTypeCountStockMovesToArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountStockQuantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockQuantWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountStockMovesFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMoveWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountStockMovesToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMoveWhereInput
  }


  /**
   * Count Type ReceiptCountOutputType
   */

  export type ReceiptCountOutputType = {
    lines: number
  }

  export type ReceiptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | ReceiptCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * ReceiptCountOutputType without action
   */
  export type ReceiptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptCountOutputType
     */
    select?: ReceiptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReceiptCountOutputType without action
   */
  export type ReceiptCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceiptLineWhereInput
  }


  /**
   * Count Type DeliveryCountOutputType
   */

  export type DeliveryCountOutputType = {
    lines: number
  }

  export type DeliveryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | DeliveryCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * DeliveryCountOutputType without action
   */
  export type DeliveryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryCountOutputType
     */
    select?: DeliveryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeliveryCountOutputType without action
   */
  export type DeliveryCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryLineWhereInput
  }


  /**
   * Count Type TransferCountOutputType
   */

  export type TransferCountOutputType = {
    lines: number
  }

  export type TransferCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | TransferCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * TransferCountOutputType without action
   */
  export type TransferCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferCountOutputType
     */
    select?: TransferCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransferCountOutputType without action
   */
  export type TransferCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferLineWhereInput
  }


  /**
   * Count Type AdjustmentCountOutputType
   */

  export type AdjustmentCountOutputType = {
    lines: number
  }

  export type AdjustmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | AdjustmentCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * AdjustmentCountOutputType without action
   */
  export type AdjustmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdjustmentCountOutputType
     */
    select?: AdjustmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdjustmentCountOutputType without action
   */
  export type AdjustmentCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdjustmentLineWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    passwordHash: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    passwordHash: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    passwordHash: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string | null
    email: string
    passwordHash: string
    role: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    receiptsCreated?: boolean | User$receiptsCreatedArgs<ExtArgs>
    deliveriesCreated?: boolean | User$deliveriesCreatedArgs<ExtArgs>
    transfersCreated?: boolean | User$transfersCreatedArgs<ExtArgs>
    adjustmentsCreated?: boolean | User$adjustmentsCreatedArgs<ExtArgs>
    stockMovesCreated?: boolean | User$stockMovesCreatedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "passwordHash" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receiptsCreated?: boolean | User$receiptsCreatedArgs<ExtArgs>
    deliveriesCreated?: boolean | User$deliveriesCreatedArgs<ExtArgs>
    transfersCreated?: boolean | User$transfersCreatedArgs<ExtArgs>
    adjustmentsCreated?: boolean | User$adjustmentsCreatedArgs<ExtArgs>
    stockMovesCreated?: boolean | User$stockMovesCreatedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      receiptsCreated: Prisma.$ReceiptPayload<ExtArgs>[]
      deliveriesCreated: Prisma.$DeliveryPayload<ExtArgs>[]
      transfersCreated: Prisma.$TransferPayload<ExtArgs>[]
      adjustmentsCreated: Prisma.$AdjustmentPayload<ExtArgs>[]
      stockMovesCreated: Prisma.$StockMovePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      email: string
      passwordHash: string
      role: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    receiptsCreated<T extends User$receiptsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$receiptsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveriesCreated<T extends User$deliveriesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$deliveriesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transfersCreated<T extends User$transfersCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$transfersCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adjustmentsCreated<T extends User$adjustmentsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$adjustmentsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdjustmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockMovesCreated<T extends User$stockMovesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$stockMovesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.receiptsCreated
   */
  export type User$receiptsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    where?: ReceiptWhereInput
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    cursor?: ReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }

  /**
   * User.deliveriesCreated
   */
  export type User$deliveriesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    where?: DeliveryWhereInput
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    cursor?: DeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * User.transfersCreated
   */
  export type User$transfersCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * User.adjustmentsCreated
   */
  export type User$adjustmentsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adjustment
     */
    select?: AdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adjustment
     */
    omit?: AdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentInclude<ExtArgs> | null
    where?: AdjustmentWhereInput
    orderBy?: AdjustmentOrderByWithRelationInput | AdjustmentOrderByWithRelationInput[]
    cursor?: AdjustmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdjustmentScalarFieldEnum | AdjustmentScalarFieldEnum[]
  }

  /**
   * User.stockMovesCreated
   */
  export type User$stockMovesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMove
     */
    select?: StockMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMove
     */
    omit?: StockMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMoveInclude<ExtArgs> | null
    where?: StockMoveWhereInput
    orderBy?: StockMoveOrderByWithRelationInput | StockMoveOrderByWithRelationInput[]
    cursor?: StockMoveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMoveScalarFieldEnum | StockMoveScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Otp
   */

  export type AggregateOtp = {
    _count: OtpCountAggregateOutputType | null
    _avg: OtpAvgAggregateOutputType | null
    _sum: OtpSumAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  export type OtpAvgAggregateOutputType = {
    id: number | null
  }

  export type OtpSumAggregateOutputType = {
    id: number | null
  }

  export type OtpMinAggregateOutputType = {
    id: number | null
    email: string | null
    code: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type OtpMaxAggregateOutputType = {
    id: number | null
    email: string | null
    code: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type OtpCountAggregateOutputType = {
    id: number
    email: number
    code: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type OtpAvgAggregateInputType = {
    id?: true
  }

  export type OtpSumAggregateInputType = {
    id?: true
  }

  export type OtpMinAggregateInputType = {
    id?: true
    email?: true
    code?: true
    expiresAt?: true
    createdAt?: true
  }

  export type OtpMaxAggregateInputType = {
    id?: true
    email?: true
    code?: true
    expiresAt?: true
    createdAt?: true
  }

  export type OtpCountAggregateInputType = {
    id?: true
    email?: true
    code?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type OtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otp to aggregate.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Otps
    **/
    _count?: true | OtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OtpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OtpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpMaxAggregateInputType
  }

  export type GetOtpAggregateType<T extends OtpAggregateArgs> = {
        [P in keyof T & keyof AggregateOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtp[P]>
      : GetScalarType<T[P], AggregateOtp[P]>
  }




  export type OtpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpWhereInput
    orderBy?: OtpOrderByWithAggregationInput | OtpOrderByWithAggregationInput[]
    by: OtpScalarFieldEnum[] | OtpScalarFieldEnum
    having?: OtpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpCountAggregateInputType | true
    _avg?: OtpAvgAggregateInputType
    _sum?: OtpSumAggregateInputType
    _min?: OtpMinAggregateInputType
    _max?: OtpMaxAggregateInputType
  }

  export type OtpGroupByOutputType = {
    id: number
    email: string
    code: string
    expiresAt: Date
    createdAt: Date
    _count: OtpCountAggregateOutputType | null
    _avg: OtpAvgAggregateOutputType | null
    _sum: OtpSumAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  type GetOtpGroupByPayload<T extends OtpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpGroupByOutputType[P]>
            : GetScalarType<T[P], OtpGroupByOutputType[P]>
        }
      >
    >


  export type OtpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    code?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["otp"]>

  export type OtpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    code?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["otp"]>

  export type OtpSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    code?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["otp"]>

  export type OtpSelectScalar = {
    id?: boolean
    email?: boolean
    code?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type OtpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "code" | "expiresAt" | "createdAt", ExtArgs["result"]["otp"]>

  export type $OtpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Otp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      code: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["otp"]>
    composites: {}
  }

  type OtpGetPayload<S extends boolean | null | undefined | OtpDefaultArgs> = $Result.GetResult<Prisma.$OtpPayload, S>

  type OtpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OtpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OtpCountAggregateInputType | true
    }

  export interface OtpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Otp'], meta: { name: 'Otp' } }
    /**
     * Find zero or one Otp that matches the filter.
     * @param {OtpFindUniqueArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OtpFindUniqueArgs>(args: SelectSubset<T, OtpFindUniqueArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Otp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OtpFindUniqueOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OtpFindUniqueOrThrowArgs>(args: SelectSubset<T, OtpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OtpFindFirstArgs>(args?: SelectSubset<T, OtpFindFirstArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OtpFindFirstOrThrowArgs>(args?: SelectSubset<T, OtpFindFirstOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otps
     * const otps = await prisma.otp.findMany()
     * 
     * // Get first 10 Otps
     * const otps = await prisma.otp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpWithIdOnly = await prisma.otp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OtpFindManyArgs>(args?: SelectSubset<T, OtpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Otp.
     * @param {OtpCreateArgs} args - Arguments to create a Otp.
     * @example
     * // Create one Otp
     * const Otp = await prisma.otp.create({
     *   data: {
     *     // ... data to create a Otp
     *   }
     * })
     * 
     */
    create<T extends OtpCreateArgs>(args: SelectSubset<T, OtpCreateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Otps.
     * @param {OtpCreateManyArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OtpCreateManyArgs>(args?: SelectSubset<T, OtpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Otps and returns the data saved in the database.
     * @param {OtpCreateManyAndReturnArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Otps and only return the `id`
     * const otpWithIdOnly = await prisma.otp.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OtpCreateManyAndReturnArgs>(args?: SelectSubset<T, OtpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Otp.
     * @param {OtpDeleteArgs} args - Arguments to delete one Otp.
     * @example
     * // Delete one Otp
     * const Otp = await prisma.otp.delete({
     *   where: {
     *     // ... filter to delete one Otp
     *   }
     * })
     * 
     */
    delete<T extends OtpDeleteArgs>(args: SelectSubset<T, OtpDeleteArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Otp.
     * @param {OtpUpdateArgs} args - Arguments to update one Otp.
     * @example
     * // Update one Otp
     * const otp = await prisma.otp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OtpUpdateArgs>(args: SelectSubset<T, OtpUpdateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Otps.
     * @param {OtpDeleteManyArgs} args - Arguments to filter Otps to delete.
     * @example
     * // Delete a few Otps
     * const { count } = await prisma.otp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OtpDeleteManyArgs>(args?: SelectSubset<T, OtpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OtpUpdateManyArgs>(args: SelectSubset<T, OtpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps and returns the data updated in the database.
     * @param {OtpUpdateManyAndReturnArgs} args - Arguments to update many Otps.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Otps and only return the `id`
     * const otpWithIdOnly = await prisma.otp.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OtpUpdateManyAndReturnArgs>(args: SelectSubset<T, OtpUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Otp.
     * @param {OtpUpsertArgs} args - Arguments to update or create a Otp.
     * @example
     * // Update or create a Otp
     * const otp = await prisma.otp.upsert({
     *   create: {
     *     // ... data to create a Otp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otp we want to update
     *   }
     * })
     */
    upsert<T extends OtpUpsertArgs>(args: SelectSubset<T, OtpUpsertArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpCountArgs} args - Arguments to filter Otps to count.
     * @example
     * // Count the number of Otps
     * const count = await prisma.otp.count({
     *   where: {
     *     // ... the filter for the Otps we want to count
     *   }
     * })
    **/
    count<T extends OtpCountArgs>(
      args?: Subset<T, OtpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpAggregateArgs>(args: Subset<T, OtpAggregateArgs>): Prisma.PrismaPromise<GetOtpAggregateType<T>>

    /**
     * Group by Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtpGroupByArgs['orderBy'] }
        : { orderBy?: OtpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Otp model
   */
  readonly fields: OtpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Otp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Otp model
   */
  interface OtpFieldRefs {
    readonly id: FieldRef<"Otp", 'Int'>
    readonly email: FieldRef<"Otp", 'String'>
    readonly code: FieldRef<"Otp", 'String'>
    readonly expiresAt: FieldRef<"Otp", 'DateTime'>
    readonly createdAt: FieldRef<"Otp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Otp findUnique
   */
  export type OtpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findUniqueOrThrow
   */
  export type OtpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findFirst
   */
  export type OtpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findFirstOrThrow
   */
  export type OtpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findMany
   */
  export type OtpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otps to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp create
   */
  export type OtpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data needed to create a Otp.
     */
    data: XOR<OtpCreateInput, OtpUncheckedCreateInput>
  }

  /**
   * Otp createMany
   */
  export type OtpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Otps.
     */
    data: OtpCreateManyInput | OtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Otp createManyAndReturn
   */
  export type OtpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data used to create many Otps.
     */
    data: OtpCreateManyInput | OtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Otp update
   */
  export type OtpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data needed to update a Otp.
     */
    data: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
    /**
     * Choose, which Otp to update.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp updateMany
   */
  export type OtpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Otps.
     */
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyInput>
    /**
     * Filter which Otps to update
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to update.
     */
    limit?: number
  }

  /**
   * Otp updateManyAndReturn
   */
  export type OtpUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data used to update Otps.
     */
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyInput>
    /**
     * Filter which Otps to update
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to update.
     */
    limit?: number
  }

  /**
   * Otp upsert
   */
  export type OtpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The filter to search for the Otp to update in case it exists.
     */
    where: OtpWhereUniqueInput
    /**
     * In case the Otp found by the `where` argument doesn't exist, create a new Otp with this data.
     */
    create: XOR<OtpCreateInput, OtpUncheckedCreateInput>
    /**
     * In case the Otp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
  }

  /**
   * Otp delete
   */
  export type OtpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter which Otp to delete.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp deleteMany
   */
  export type OtpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otps to delete
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to delete.
     */
    limit?: number
  }

  /**
   * Otp without action
   */
  export type OtpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    defaultPrice: Decimal | null
    categoryId: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    defaultPrice: Decimal | null
    categoryId: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    sku: string | null
    name: string | null
    description: string | null
    uom: string | null
    defaultPrice: Decimal | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    categoryId: number | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    sku: string | null
    name: string | null
    description: string | null
    uom: string | null
    defaultPrice: Decimal | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    categoryId: number | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    sku: number
    name: number
    description: number
    uom: number
    defaultPrice: number
    active: number
    createdAt: number
    updatedAt: number
    categoryId: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    defaultPrice?: true
    categoryId?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    defaultPrice?: true
    categoryId?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    uom?: true
    defaultPrice?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    categoryId?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    uom?: true
    defaultPrice?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    categoryId?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    uom?: true
    defaultPrice?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    categoryId?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    sku: string
    name: string
    description: string | null
    uom: string
    defaultPrice: Decimal
    active: boolean
    createdAt: Date
    updatedAt: Date
    categoryId: number | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    uom?: boolean
    defaultPrice?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryId?: boolean
    stockQuants?: boolean | Product$stockQuantsArgs<ExtArgs>
    stockMoves?: boolean | Product$stockMovesArgs<ExtArgs>
    receiptLines?: boolean | Product$receiptLinesArgs<ExtArgs>
    deliveryLines?: boolean | Product$deliveryLinesArgs<ExtArgs>
    transferLines?: boolean | Product$transferLinesArgs<ExtArgs>
    adjustmentLines?: boolean | Product$adjustmentLinesArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    reorderRules?: boolean | Product$reorderRulesArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    uom?: boolean
    defaultPrice?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryId?: boolean
    category?: boolean | Product$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    uom?: boolean
    defaultPrice?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryId?: boolean
    category?: boolean | Product$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    uom?: boolean
    defaultPrice?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryId?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sku" | "name" | "description" | "uom" | "defaultPrice" | "active" | "createdAt" | "updatedAt" | "categoryId", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockQuants?: boolean | Product$stockQuantsArgs<ExtArgs>
    stockMoves?: boolean | Product$stockMovesArgs<ExtArgs>
    receiptLines?: boolean | Product$receiptLinesArgs<ExtArgs>
    deliveryLines?: boolean | Product$deliveryLinesArgs<ExtArgs>
    transferLines?: boolean | Product$transferLinesArgs<ExtArgs>
    adjustmentLines?: boolean | Product$adjustmentLinesArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    reorderRules?: boolean | Product$reorderRulesArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Product$categoryArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Product$categoryArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      stockQuants: Prisma.$StockQuantPayload<ExtArgs>[]
      stockMoves: Prisma.$StockMovePayload<ExtArgs>[]
      receiptLines: Prisma.$ReceiptLinePayload<ExtArgs>[]
      deliveryLines: Prisma.$DeliveryLinePayload<ExtArgs>[]
      transferLines: Prisma.$TransferLinePayload<ExtArgs>[]
      adjustmentLines: Prisma.$AdjustmentLinePayload<ExtArgs>[]
      category: Prisma.$CategoryPayload<ExtArgs> | null
      reorderRules: Prisma.$ReorderRulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sku: string
      name: string
      description: string | null
      uom: string
      defaultPrice: Prisma.Decimal
      active: boolean
      createdAt: Date
      updatedAt: Date
      categoryId: number | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stockQuants<T extends Product$stockQuantsArgs<ExtArgs> = {}>(args?: Subset<T, Product$stockQuantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockQuantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockMoves<T extends Product$stockMovesArgs<ExtArgs> = {}>(args?: Subset<T, Product$stockMovesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receiptLines<T extends Product$receiptLinesArgs<ExtArgs> = {}>(args?: Subset<T, Product$receiptLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveryLines<T extends Product$deliveryLinesArgs<ExtArgs> = {}>(args?: Subset<T, Product$deliveryLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transferLines<T extends Product$transferLinesArgs<ExtArgs> = {}>(args?: Subset<T, Product$transferLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adjustmentLines<T extends Product$adjustmentLinesArgs<ExtArgs> = {}>(args?: Subset<T, Product$adjustmentLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdjustmentLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    category<T extends Product$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reorderRules<T extends Product$reorderRulesArgs<ExtArgs> = {}>(args?: Subset<T, Product$reorderRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReorderRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly uom: FieldRef<"Product", 'String'>
    readonly defaultPrice: FieldRef<"Product", 'Decimal'>
    readonly active: FieldRef<"Product", 'Boolean'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly categoryId: FieldRef<"Product", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.stockQuants
   */
  export type Product$stockQuantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockQuant
     */
    select?: StockQuantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockQuant
     */
    omit?: StockQuantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockQuantInclude<ExtArgs> | null
    where?: StockQuantWhereInput
    orderBy?: StockQuantOrderByWithRelationInput | StockQuantOrderByWithRelationInput[]
    cursor?: StockQuantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockQuantScalarFieldEnum | StockQuantScalarFieldEnum[]
  }

  /**
   * Product.stockMoves
   */
  export type Product$stockMovesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMove
     */
    select?: StockMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMove
     */
    omit?: StockMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMoveInclude<ExtArgs> | null
    where?: StockMoveWhereInput
    orderBy?: StockMoveOrderByWithRelationInput | StockMoveOrderByWithRelationInput[]
    cursor?: StockMoveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMoveScalarFieldEnum | StockMoveScalarFieldEnum[]
  }

  /**
   * Product.receiptLines
   */
  export type Product$receiptLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptLine
     */
    select?: ReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptLine
     */
    omit?: ReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptLineInclude<ExtArgs> | null
    where?: ReceiptLineWhereInput
    orderBy?: ReceiptLineOrderByWithRelationInput | ReceiptLineOrderByWithRelationInput[]
    cursor?: ReceiptLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceiptLineScalarFieldEnum | ReceiptLineScalarFieldEnum[]
  }

  /**
   * Product.deliveryLines
   */
  export type Product$deliveryLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLine
     */
    select?: DeliveryLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLine
     */
    omit?: DeliveryLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLineInclude<ExtArgs> | null
    where?: DeliveryLineWhereInput
    orderBy?: DeliveryLineOrderByWithRelationInput | DeliveryLineOrderByWithRelationInput[]
    cursor?: DeliveryLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryLineScalarFieldEnum | DeliveryLineScalarFieldEnum[]
  }

  /**
   * Product.transferLines
   */
  export type Product$transferLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
    where?: TransferLineWhereInput
    orderBy?: TransferLineOrderByWithRelationInput | TransferLineOrderByWithRelationInput[]
    cursor?: TransferLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferLineScalarFieldEnum | TransferLineScalarFieldEnum[]
  }

  /**
   * Product.adjustmentLines
   */
  export type Product$adjustmentLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdjustmentLine
     */
    select?: AdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdjustmentLine
     */
    omit?: AdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentLineInclude<ExtArgs> | null
    where?: AdjustmentLineWhereInput
    orderBy?: AdjustmentLineOrderByWithRelationInput | AdjustmentLineOrderByWithRelationInput[]
    cursor?: AdjustmentLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdjustmentLineScalarFieldEnum | AdjustmentLineScalarFieldEnum[]
  }

  /**
   * Product.category
   */
  export type Product$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Product.reorderRules
   */
  export type Product$reorderRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReorderRule
     */
    select?: ReorderRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReorderRule
     */
    omit?: ReorderRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReorderRuleInclude<ExtArgs> | null
    where?: ReorderRuleWhereInput
    orderBy?: ReorderRuleOrderByWithRelationInput | ReorderRuleOrderByWithRelationInput[]
    cursor?: ReorderRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReorderRuleScalarFieldEnum | ReorderRuleScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
    parentId: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    parentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    parentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
    parentId?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
    parentId?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    name: string
    parentId: number | null
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "parentId" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      parentId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'Int'>
    readonly name: FieldRef<"Category", 'String'>
    readonly parentId: FieldRef<"Category", 'Int'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model ReorderRule
   */

  export type AggregateReorderRule = {
    _count: ReorderRuleCountAggregateOutputType | null
    _avg: ReorderRuleAvgAggregateOutputType | null
    _sum: ReorderRuleSumAggregateOutputType | null
    _min: ReorderRuleMinAggregateOutputType | null
    _max: ReorderRuleMaxAggregateOutputType | null
  }

  export type ReorderRuleAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    warehouseId: number | null
    minQty: Decimal | null
    maxQty: Decimal | null
  }

  export type ReorderRuleSumAggregateOutputType = {
    id: number | null
    productId: number | null
    warehouseId: number | null
    minQty: Decimal | null
    maxQty: Decimal | null
  }

  export type ReorderRuleMinAggregateOutputType = {
    id: number | null
    productId: number | null
    warehouseId: number | null
    minQty: Decimal | null
    maxQty: Decimal | null
    createdAt: Date | null
  }

  export type ReorderRuleMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    warehouseId: number | null
    minQty: Decimal | null
    maxQty: Decimal | null
    createdAt: Date | null
  }

  export type ReorderRuleCountAggregateOutputType = {
    id: number
    productId: number
    warehouseId: number
    minQty: number
    maxQty: number
    createdAt: number
    _all: number
  }


  export type ReorderRuleAvgAggregateInputType = {
    id?: true
    productId?: true
    warehouseId?: true
    minQty?: true
    maxQty?: true
  }

  export type ReorderRuleSumAggregateInputType = {
    id?: true
    productId?: true
    warehouseId?: true
    minQty?: true
    maxQty?: true
  }

  export type ReorderRuleMinAggregateInputType = {
    id?: true
    productId?: true
    warehouseId?: true
    minQty?: true
    maxQty?: true
    createdAt?: true
  }

  export type ReorderRuleMaxAggregateInputType = {
    id?: true
    productId?: true
    warehouseId?: true
    minQty?: true
    maxQty?: true
    createdAt?: true
  }

  export type ReorderRuleCountAggregateInputType = {
    id?: true
    productId?: true
    warehouseId?: true
    minQty?: true
    maxQty?: true
    createdAt?: true
    _all?: true
  }

  export type ReorderRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReorderRule to aggregate.
     */
    where?: ReorderRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReorderRules to fetch.
     */
    orderBy?: ReorderRuleOrderByWithRelationInput | ReorderRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReorderRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReorderRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReorderRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReorderRules
    **/
    _count?: true | ReorderRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReorderRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReorderRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReorderRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReorderRuleMaxAggregateInputType
  }

  export type GetReorderRuleAggregateType<T extends ReorderRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateReorderRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReorderRule[P]>
      : GetScalarType<T[P], AggregateReorderRule[P]>
  }




  export type ReorderRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReorderRuleWhereInput
    orderBy?: ReorderRuleOrderByWithAggregationInput | ReorderRuleOrderByWithAggregationInput[]
    by: ReorderRuleScalarFieldEnum[] | ReorderRuleScalarFieldEnum
    having?: ReorderRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReorderRuleCountAggregateInputType | true
    _avg?: ReorderRuleAvgAggregateInputType
    _sum?: ReorderRuleSumAggregateInputType
    _min?: ReorderRuleMinAggregateInputType
    _max?: ReorderRuleMaxAggregateInputType
  }

  export type ReorderRuleGroupByOutputType = {
    id: number
    productId: number
    warehouseId: number
    minQty: Decimal
    maxQty: Decimal | null
    createdAt: Date
    _count: ReorderRuleCountAggregateOutputType | null
    _avg: ReorderRuleAvgAggregateOutputType | null
    _sum: ReorderRuleSumAggregateOutputType | null
    _min: ReorderRuleMinAggregateOutputType | null
    _max: ReorderRuleMaxAggregateOutputType | null
  }

  type GetReorderRuleGroupByPayload<T extends ReorderRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReorderRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReorderRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReorderRuleGroupByOutputType[P]>
            : GetScalarType<T[P], ReorderRuleGroupByOutputType[P]>
        }
      >
    >


  export type ReorderRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    warehouseId?: boolean
    minQty?: boolean
    maxQty?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reorderRule"]>

  export type ReorderRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    warehouseId?: boolean
    minQty?: boolean
    maxQty?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reorderRule"]>

  export type ReorderRuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    warehouseId?: boolean
    minQty?: boolean
    maxQty?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reorderRule"]>

  export type ReorderRuleSelectScalar = {
    id?: boolean
    productId?: boolean
    warehouseId?: boolean
    minQty?: boolean
    maxQty?: boolean
    createdAt?: boolean
  }

  export type ReorderRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "warehouseId" | "minQty" | "maxQty" | "createdAt", ExtArgs["result"]["reorderRule"]>
  export type ReorderRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }
  export type ReorderRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }
  export type ReorderRuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }

  export type $ReorderRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReorderRule"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      warehouse: Prisma.$WarehousePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      warehouseId: number
      minQty: Prisma.Decimal
      maxQty: Prisma.Decimal | null
      createdAt: Date
    }, ExtArgs["result"]["reorderRule"]>
    composites: {}
  }

  type ReorderRuleGetPayload<S extends boolean | null | undefined | ReorderRuleDefaultArgs> = $Result.GetResult<Prisma.$ReorderRulePayload, S>

  type ReorderRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReorderRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReorderRuleCountAggregateInputType | true
    }

  export interface ReorderRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReorderRule'], meta: { name: 'ReorderRule' } }
    /**
     * Find zero or one ReorderRule that matches the filter.
     * @param {ReorderRuleFindUniqueArgs} args - Arguments to find a ReorderRule
     * @example
     * // Get one ReorderRule
     * const reorderRule = await prisma.reorderRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReorderRuleFindUniqueArgs>(args: SelectSubset<T, ReorderRuleFindUniqueArgs<ExtArgs>>): Prisma__ReorderRuleClient<$Result.GetResult<Prisma.$ReorderRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReorderRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReorderRuleFindUniqueOrThrowArgs} args - Arguments to find a ReorderRule
     * @example
     * // Get one ReorderRule
     * const reorderRule = await prisma.reorderRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReorderRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ReorderRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReorderRuleClient<$Result.GetResult<Prisma.$ReorderRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReorderRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReorderRuleFindFirstArgs} args - Arguments to find a ReorderRule
     * @example
     * // Get one ReorderRule
     * const reorderRule = await prisma.reorderRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReorderRuleFindFirstArgs>(args?: SelectSubset<T, ReorderRuleFindFirstArgs<ExtArgs>>): Prisma__ReorderRuleClient<$Result.GetResult<Prisma.$ReorderRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReorderRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReorderRuleFindFirstOrThrowArgs} args - Arguments to find a ReorderRule
     * @example
     * // Get one ReorderRule
     * const reorderRule = await prisma.reorderRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReorderRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ReorderRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReorderRuleClient<$Result.GetResult<Prisma.$ReorderRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReorderRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReorderRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReorderRules
     * const reorderRules = await prisma.reorderRule.findMany()
     * 
     * // Get first 10 ReorderRules
     * const reorderRules = await prisma.reorderRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reorderRuleWithIdOnly = await prisma.reorderRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReorderRuleFindManyArgs>(args?: SelectSubset<T, ReorderRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReorderRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReorderRule.
     * @param {ReorderRuleCreateArgs} args - Arguments to create a ReorderRule.
     * @example
     * // Create one ReorderRule
     * const ReorderRule = await prisma.reorderRule.create({
     *   data: {
     *     // ... data to create a ReorderRule
     *   }
     * })
     * 
     */
    create<T extends ReorderRuleCreateArgs>(args: SelectSubset<T, ReorderRuleCreateArgs<ExtArgs>>): Prisma__ReorderRuleClient<$Result.GetResult<Prisma.$ReorderRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReorderRules.
     * @param {ReorderRuleCreateManyArgs} args - Arguments to create many ReorderRules.
     * @example
     * // Create many ReorderRules
     * const reorderRule = await prisma.reorderRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReorderRuleCreateManyArgs>(args?: SelectSubset<T, ReorderRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReorderRules and returns the data saved in the database.
     * @param {ReorderRuleCreateManyAndReturnArgs} args - Arguments to create many ReorderRules.
     * @example
     * // Create many ReorderRules
     * const reorderRule = await prisma.reorderRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReorderRules and only return the `id`
     * const reorderRuleWithIdOnly = await prisma.reorderRule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReorderRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, ReorderRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReorderRulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReorderRule.
     * @param {ReorderRuleDeleteArgs} args - Arguments to delete one ReorderRule.
     * @example
     * // Delete one ReorderRule
     * const ReorderRule = await prisma.reorderRule.delete({
     *   where: {
     *     // ... filter to delete one ReorderRule
     *   }
     * })
     * 
     */
    delete<T extends ReorderRuleDeleteArgs>(args: SelectSubset<T, ReorderRuleDeleteArgs<ExtArgs>>): Prisma__ReorderRuleClient<$Result.GetResult<Prisma.$ReorderRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReorderRule.
     * @param {ReorderRuleUpdateArgs} args - Arguments to update one ReorderRule.
     * @example
     * // Update one ReorderRule
     * const reorderRule = await prisma.reorderRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReorderRuleUpdateArgs>(args: SelectSubset<T, ReorderRuleUpdateArgs<ExtArgs>>): Prisma__ReorderRuleClient<$Result.GetResult<Prisma.$ReorderRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReorderRules.
     * @param {ReorderRuleDeleteManyArgs} args - Arguments to filter ReorderRules to delete.
     * @example
     * // Delete a few ReorderRules
     * const { count } = await prisma.reorderRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReorderRuleDeleteManyArgs>(args?: SelectSubset<T, ReorderRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReorderRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReorderRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReorderRules
     * const reorderRule = await prisma.reorderRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReorderRuleUpdateManyArgs>(args: SelectSubset<T, ReorderRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReorderRules and returns the data updated in the database.
     * @param {ReorderRuleUpdateManyAndReturnArgs} args - Arguments to update many ReorderRules.
     * @example
     * // Update many ReorderRules
     * const reorderRule = await prisma.reorderRule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReorderRules and only return the `id`
     * const reorderRuleWithIdOnly = await prisma.reorderRule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReorderRuleUpdateManyAndReturnArgs>(args: SelectSubset<T, ReorderRuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReorderRulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReorderRule.
     * @param {ReorderRuleUpsertArgs} args - Arguments to update or create a ReorderRule.
     * @example
     * // Update or create a ReorderRule
     * const reorderRule = await prisma.reorderRule.upsert({
     *   create: {
     *     // ... data to create a ReorderRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReorderRule we want to update
     *   }
     * })
     */
    upsert<T extends ReorderRuleUpsertArgs>(args: SelectSubset<T, ReorderRuleUpsertArgs<ExtArgs>>): Prisma__ReorderRuleClient<$Result.GetResult<Prisma.$ReorderRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReorderRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReorderRuleCountArgs} args - Arguments to filter ReorderRules to count.
     * @example
     * // Count the number of ReorderRules
     * const count = await prisma.reorderRule.count({
     *   where: {
     *     // ... the filter for the ReorderRules we want to count
     *   }
     * })
    **/
    count<T extends ReorderRuleCountArgs>(
      args?: Subset<T, ReorderRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReorderRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReorderRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReorderRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReorderRuleAggregateArgs>(args: Subset<T, ReorderRuleAggregateArgs>): Prisma.PrismaPromise<GetReorderRuleAggregateType<T>>

    /**
     * Group by ReorderRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReorderRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReorderRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReorderRuleGroupByArgs['orderBy'] }
        : { orderBy?: ReorderRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReorderRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReorderRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReorderRule model
   */
  readonly fields: ReorderRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReorderRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReorderRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReorderRule model
   */
  interface ReorderRuleFieldRefs {
    readonly id: FieldRef<"ReorderRule", 'Int'>
    readonly productId: FieldRef<"ReorderRule", 'Int'>
    readonly warehouseId: FieldRef<"ReorderRule", 'Int'>
    readonly minQty: FieldRef<"ReorderRule", 'Decimal'>
    readonly maxQty: FieldRef<"ReorderRule", 'Decimal'>
    readonly createdAt: FieldRef<"ReorderRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReorderRule findUnique
   */
  export type ReorderRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReorderRule
     */
    select?: ReorderRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReorderRule
     */
    omit?: ReorderRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReorderRuleInclude<ExtArgs> | null
    /**
     * Filter, which ReorderRule to fetch.
     */
    where: ReorderRuleWhereUniqueInput
  }

  /**
   * ReorderRule findUniqueOrThrow
   */
  export type ReorderRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReorderRule
     */
    select?: ReorderRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReorderRule
     */
    omit?: ReorderRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReorderRuleInclude<ExtArgs> | null
    /**
     * Filter, which ReorderRule to fetch.
     */
    where: ReorderRuleWhereUniqueInput
  }

  /**
   * ReorderRule findFirst
   */
  export type ReorderRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReorderRule
     */
    select?: ReorderRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReorderRule
     */
    omit?: ReorderRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReorderRuleInclude<ExtArgs> | null
    /**
     * Filter, which ReorderRule to fetch.
     */
    where?: ReorderRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReorderRules to fetch.
     */
    orderBy?: ReorderRuleOrderByWithRelationInput | ReorderRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReorderRules.
     */
    cursor?: ReorderRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReorderRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReorderRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReorderRules.
     */
    distinct?: ReorderRuleScalarFieldEnum | ReorderRuleScalarFieldEnum[]
  }

  /**
   * ReorderRule findFirstOrThrow
   */
  export type ReorderRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReorderRule
     */
    select?: ReorderRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReorderRule
     */
    omit?: ReorderRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReorderRuleInclude<ExtArgs> | null
    /**
     * Filter, which ReorderRule to fetch.
     */
    where?: ReorderRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReorderRules to fetch.
     */
    orderBy?: ReorderRuleOrderByWithRelationInput | ReorderRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReorderRules.
     */
    cursor?: ReorderRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReorderRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReorderRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReorderRules.
     */
    distinct?: ReorderRuleScalarFieldEnum | ReorderRuleScalarFieldEnum[]
  }

  /**
   * ReorderRule findMany
   */
  export type ReorderRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReorderRule
     */
    select?: ReorderRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReorderRule
     */
    omit?: ReorderRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReorderRuleInclude<ExtArgs> | null
    /**
     * Filter, which ReorderRules to fetch.
     */
    where?: ReorderRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReorderRules to fetch.
     */
    orderBy?: ReorderRuleOrderByWithRelationInput | ReorderRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReorderRules.
     */
    cursor?: ReorderRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReorderRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReorderRules.
     */
    skip?: number
    distinct?: ReorderRuleScalarFieldEnum | ReorderRuleScalarFieldEnum[]
  }

  /**
   * ReorderRule create
   */
  export type ReorderRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReorderRule
     */
    select?: ReorderRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReorderRule
     */
    omit?: ReorderRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReorderRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a ReorderRule.
     */
    data: XOR<ReorderRuleCreateInput, ReorderRuleUncheckedCreateInput>
  }

  /**
   * ReorderRule createMany
   */
  export type ReorderRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReorderRules.
     */
    data: ReorderRuleCreateManyInput | ReorderRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReorderRule createManyAndReturn
   */
  export type ReorderRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReorderRule
     */
    select?: ReorderRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReorderRule
     */
    omit?: ReorderRuleOmit<ExtArgs> | null
    /**
     * The data used to create many ReorderRules.
     */
    data: ReorderRuleCreateManyInput | ReorderRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReorderRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReorderRule update
   */
  export type ReorderRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReorderRule
     */
    select?: ReorderRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReorderRule
     */
    omit?: ReorderRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReorderRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a ReorderRule.
     */
    data: XOR<ReorderRuleUpdateInput, ReorderRuleUncheckedUpdateInput>
    /**
     * Choose, which ReorderRule to update.
     */
    where: ReorderRuleWhereUniqueInput
  }

  /**
   * ReorderRule updateMany
   */
  export type ReorderRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReorderRules.
     */
    data: XOR<ReorderRuleUpdateManyMutationInput, ReorderRuleUncheckedUpdateManyInput>
    /**
     * Filter which ReorderRules to update
     */
    where?: ReorderRuleWhereInput
    /**
     * Limit how many ReorderRules to update.
     */
    limit?: number
  }

  /**
   * ReorderRule updateManyAndReturn
   */
  export type ReorderRuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReorderRule
     */
    select?: ReorderRuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReorderRule
     */
    omit?: ReorderRuleOmit<ExtArgs> | null
    /**
     * The data used to update ReorderRules.
     */
    data: XOR<ReorderRuleUpdateManyMutationInput, ReorderRuleUncheckedUpdateManyInput>
    /**
     * Filter which ReorderRules to update
     */
    where?: ReorderRuleWhereInput
    /**
     * Limit how many ReorderRules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReorderRuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReorderRule upsert
   */
  export type ReorderRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReorderRule
     */
    select?: ReorderRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReorderRule
     */
    omit?: ReorderRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReorderRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the ReorderRule to update in case it exists.
     */
    where: ReorderRuleWhereUniqueInput
    /**
     * In case the ReorderRule found by the `where` argument doesn't exist, create a new ReorderRule with this data.
     */
    create: XOR<ReorderRuleCreateInput, ReorderRuleUncheckedCreateInput>
    /**
     * In case the ReorderRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReorderRuleUpdateInput, ReorderRuleUncheckedUpdateInput>
  }

  /**
   * ReorderRule delete
   */
  export type ReorderRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReorderRule
     */
    select?: ReorderRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReorderRule
     */
    omit?: ReorderRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReorderRuleInclude<ExtArgs> | null
    /**
     * Filter which ReorderRule to delete.
     */
    where: ReorderRuleWhereUniqueInput
  }

  /**
   * ReorderRule deleteMany
   */
  export type ReorderRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReorderRules to delete
     */
    where?: ReorderRuleWhereInput
    /**
     * Limit how many ReorderRules to delete.
     */
    limit?: number
  }

  /**
   * ReorderRule without action
   */
  export type ReorderRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReorderRule
     */
    select?: ReorderRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReorderRule
     */
    omit?: ReorderRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReorderRuleInclude<ExtArgs> | null
  }


  /**
   * Model Warehouse
   */

  export type AggregateWarehouse = {
    _count: WarehouseCountAggregateOutputType | null
    _avg: WarehouseAvgAggregateOutputType | null
    _sum: WarehouseSumAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  export type WarehouseAvgAggregateOutputType = {
    id: number | null
  }

  export type WarehouseSumAggregateOutputType = {
    id: number | null
  }

  export type WarehouseMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    address: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    address: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseCountAggregateOutputType = {
    id: number
    code: number
    name: number
    address: number
    phone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WarehouseAvgAggregateInputType = {
    id?: true
  }

  export type WarehouseSumAggregateInputType = {
    id?: true
  }

  export type WarehouseMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WarehouseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouse to aggregate.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Warehouses
    **/
    _count?: true | WarehouseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WarehouseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WarehouseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseMaxAggregateInputType
  }

  export type GetWarehouseAggregateType<T extends WarehouseAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouse[P]>
      : GetScalarType<T[P], AggregateWarehouse[P]>
  }




  export type WarehouseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseWhereInput
    orderBy?: WarehouseOrderByWithAggregationInput | WarehouseOrderByWithAggregationInput[]
    by: WarehouseScalarFieldEnum[] | WarehouseScalarFieldEnum
    having?: WarehouseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseCountAggregateInputType | true
    _avg?: WarehouseAvgAggregateInputType
    _sum?: WarehouseSumAggregateInputType
    _min?: WarehouseMinAggregateInputType
    _max?: WarehouseMaxAggregateInputType
  }

  export type WarehouseGroupByOutputType = {
    id: number
    code: string
    name: string
    address: string | null
    phone: string | null
    createdAt: Date
    updatedAt: Date
    _count: WarehouseCountAggregateOutputType | null
    _avg: WarehouseAvgAggregateOutputType | null
    _sum: WarehouseSumAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  type GetWarehouseGroupByPayload<T extends WarehouseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    locations?: boolean | Warehouse$locationsArgs<ExtArgs>
    stockQuants?: boolean | Warehouse$stockQuantsArgs<ExtArgs>
    receipts?: boolean | Warehouse$receiptsArgs<ExtArgs>
    deliveries?: boolean | Warehouse$deliveriesArgs<ExtArgs>
    transfersFrom?: boolean | Warehouse$transfersFromArgs<ExtArgs>
    transfersTo?: boolean | Warehouse$transfersToArgs<ExtArgs>
    adjustments?: boolean | Warehouse$adjustmentsArgs<ExtArgs>
    stockMovesFrom?: boolean | Warehouse$stockMovesFromArgs<ExtArgs>
    stockMovesTo?: boolean | Warehouse$stockMovesToArgs<ExtArgs>
    reorderRules?: boolean | Warehouse$reorderRulesArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WarehouseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "address" | "phone" | "createdAt" | "updatedAt", ExtArgs["result"]["warehouse"]>
  export type WarehouseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | Warehouse$locationsArgs<ExtArgs>
    stockQuants?: boolean | Warehouse$stockQuantsArgs<ExtArgs>
    receipts?: boolean | Warehouse$receiptsArgs<ExtArgs>
    deliveries?: boolean | Warehouse$deliveriesArgs<ExtArgs>
    transfersFrom?: boolean | Warehouse$transfersFromArgs<ExtArgs>
    transfersTo?: boolean | Warehouse$transfersToArgs<ExtArgs>
    adjustments?: boolean | Warehouse$adjustmentsArgs<ExtArgs>
    stockMovesFrom?: boolean | Warehouse$stockMovesFromArgs<ExtArgs>
    stockMovesTo?: boolean | Warehouse$stockMovesToArgs<ExtArgs>
    reorderRules?: boolean | Warehouse$reorderRulesArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WarehouseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WarehouseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WarehousePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Warehouse"
    objects: {
      locations: Prisma.$LocationPayload<ExtArgs>[]
      stockQuants: Prisma.$StockQuantPayload<ExtArgs>[]
      receipts: Prisma.$ReceiptPayload<ExtArgs>[]
      deliveries: Prisma.$DeliveryPayload<ExtArgs>[]
      transfersFrom: Prisma.$TransferPayload<ExtArgs>[]
      transfersTo: Prisma.$TransferPayload<ExtArgs>[]
      adjustments: Prisma.$AdjustmentPayload<ExtArgs>[]
      stockMovesFrom: Prisma.$StockMovePayload<ExtArgs>[]
      stockMovesTo: Prisma.$StockMovePayload<ExtArgs>[]
      reorderRules: Prisma.$ReorderRulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      address: string | null
      phone: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["warehouse"]>
    composites: {}
  }

  type WarehouseGetPayload<S extends boolean | null | undefined | WarehouseDefaultArgs> = $Result.GetResult<Prisma.$WarehousePayload, S>

  type WarehouseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WarehouseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WarehouseCountAggregateInputType | true
    }

  export interface WarehouseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Warehouse'], meta: { name: 'Warehouse' } }
    /**
     * Find zero or one Warehouse that matches the filter.
     * @param {WarehouseFindUniqueArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseFindUniqueArgs>(args: SelectSubset<T, WarehouseFindUniqueArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Warehouse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WarehouseFindUniqueOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warehouse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseFindFirstArgs>(args?: SelectSubset<T, WarehouseFindFirstArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warehouse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Warehouses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Warehouses
     * const warehouses = await prisma.warehouse.findMany()
     * 
     * // Get first 10 Warehouses
     * const warehouses = await prisma.warehouse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarehouseFindManyArgs>(args?: SelectSubset<T, WarehouseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Warehouse.
     * @param {WarehouseCreateArgs} args - Arguments to create a Warehouse.
     * @example
     * // Create one Warehouse
     * const Warehouse = await prisma.warehouse.create({
     *   data: {
     *     // ... data to create a Warehouse
     *   }
     * })
     * 
     */
    create<T extends WarehouseCreateArgs>(args: SelectSubset<T, WarehouseCreateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Warehouses.
     * @param {WarehouseCreateManyArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseCreateManyArgs>(args?: SelectSubset<T, WarehouseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Warehouses and returns the data saved in the database.
     * @param {WarehouseCreateManyAndReturnArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Warehouses and only return the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarehouseCreateManyAndReturnArgs>(args?: SelectSubset<T, WarehouseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Warehouse.
     * @param {WarehouseDeleteArgs} args - Arguments to delete one Warehouse.
     * @example
     * // Delete one Warehouse
     * const Warehouse = await prisma.warehouse.delete({
     *   where: {
     *     // ... filter to delete one Warehouse
     *   }
     * })
     * 
     */
    delete<T extends WarehouseDeleteArgs>(args: SelectSubset<T, WarehouseDeleteArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Warehouse.
     * @param {WarehouseUpdateArgs} args - Arguments to update one Warehouse.
     * @example
     * // Update one Warehouse
     * const warehouse = await prisma.warehouse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseUpdateArgs>(args: SelectSubset<T, WarehouseUpdateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Warehouses.
     * @param {WarehouseDeleteManyArgs} args - Arguments to filter Warehouses to delete.
     * @example
     * // Delete a few Warehouses
     * const { count } = await prisma.warehouse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseDeleteManyArgs>(args?: SelectSubset<T, WarehouseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseUpdateManyArgs>(args: SelectSubset<T, WarehouseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses and returns the data updated in the database.
     * @param {WarehouseUpdateManyAndReturnArgs} args - Arguments to update many Warehouses.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Warehouses and only return the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WarehouseUpdateManyAndReturnArgs>(args: SelectSubset<T, WarehouseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Warehouse.
     * @param {WarehouseUpsertArgs} args - Arguments to update or create a Warehouse.
     * @example
     * // Update or create a Warehouse
     * const warehouse = await prisma.warehouse.upsert({
     *   create: {
     *     // ... data to create a Warehouse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Warehouse we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseUpsertArgs>(args: SelectSubset<T, WarehouseUpsertArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseCountArgs} args - Arguments to filter Warehouses to count.
     * @example
     * // Count the number of Warehouses
     * const count = await prisma.warehouse.count({
     *   where: {
     *     // ... the filter for the Warehouses we want to count
     *   }
     * })
    **/
    count<T extends WarehouseCountArgs>(
      args?: Subset<T, WarehouseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseAggregateArgs>(args: Subset<T, WarehouseAggregateArgs>): Prisma.PrismaPromise<GetWarehouseAggregateType<T>>

    /**
     * Group by Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Warehouse model
   */
  readonly fields: WarehouseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Warehouse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    locations<T extends Warehouse$locationsArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockQuants<T extends Warehouse$stockQuantsArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$stockQuantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockQuantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receipts<T extends Warehouse$receiptsArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$receiptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveries<T extends Warehouse$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transfersFrom<T extends Warehouse$transfersFromArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$transfersFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transfersTo<T extends Warehouse$transfersToArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$transfersToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adjustments<T extends Warehouse$adjustmentsArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$adjustmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdjustmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockMovesFrom<T extends Warehouse$stockMovesFromArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$stockMovesFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockMovesTo<T extends Warehouse$stockMovesToArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$stockMovesToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reorderRules<T extends Warehouse$reorderRulesArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$reorderRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReorderRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Warehouse model
   */
  interface WarehouseFieldRefs {
    readonly id: FieldRef<"Warehouse", 'Int'>
    readonly code: FieldRef<"Warehouse", 'String'>
    readonly name: FieldRef<"Warehouse", 'String'>
    readonly address: FieldRef<"Warehouse", 'String'>
    readonly phone: FieldRef<"Warehouse", 'String'>
    readonly createdAt: FieldRef<"Warehouse", 'DateTime'>
    readonly updatedAt: FieldRef<"Warehouse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Warehouse findUnique
   */
  export type WarehouseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findUniqueOrThrow
   */
  export type WarehouseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findFirst
   */
  export type WarehouseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findFirstOrThrow
   */
  export type WarehouseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findMany
   */
  export type WarehouseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouses to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse create
   */
  export type WarehouseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to create a Warehouse.
     */
    data: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
  }

  /**
   * Warehouse createMany
   */
  export type WarehouseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Warehouses.
     */
    data: WarehouseCreateManyInput | WarehouseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Warehouse createManyAndReturn
   */
  export type WarehouseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * The data used to create many Warehouses.
     */
    data: WarehouseCreateManyInput | WarehouseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Warehouse update
   */
  export type WarehouseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to update a Warehouse.
     */
    data: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
    /**
     * Choose, which Warehouse to update.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse updateMany
   */
  export type WarehouseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Warehouses.
     */
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyInput>
    /**
     * Filter which Warehouses to update
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to update.
     */
    limit?: number
  }

  /**
   * Warehouse updateManyAndReturn
   */
  export type WarehouseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * The data used to update Warehouses.
     */
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyInput>
    /**
     * Filter which Warehouses to update
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to update.
     */
    limit?: number
  }

  /**
   * Warehouse upsert
   */
  export type WarehouseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The filter to search for the Warehouse to update in case it exists.
     */
    where: WarehouseWhereUniqueInput
    /**
     * In case the Warehouse found by the `where` argument doesn't exist, create a new Warehouse with this data.
     */
    create: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
    /**
     * In case the Warehouse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
  }

  /**
   * Warehouse delete
   */
  export type WarehouseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter which Warehouse to delete.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse deleteMany
   */
  export type WarehouseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouses to delete
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to delete.
     */
    limit?: number
  }

  /**
   * Warehouse.locations
   */
  export type Warehouse$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Warehouse.stockQuants
   */
  export type Warehouse$stockQuantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockQuant
     */
    select?: StockQuantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockQuant
     */
    omit?: StockQuantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockQuantInclude<ExtArgs> | null
    where?: StockQuantWhereInput
    orderBy?: StockQuantOrderByWithRelationInput | StockQuantOrderByWithRelationInput[]
    cursor?: StockQuantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockQuantScalarFieldEnum | StockQuantScalarFieldEnum[]
  }

  /**
   * Warehouse.receipts
   */
  export type Warehouse$receiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    where?: ReceiptWhereInput
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    cursor?: ReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }

  /**
   * Warehouse.deliveries
   */
  export type Warehouse$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    where?: DeliveryWhereInput
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    cursor?: DeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Warehouse.transfersFrom
   */
  export type Warehouse$transfersFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Warehouse.transfersTo
   */
  export type Warehouse$transfersToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Warehouse.adjustments
   */
  export type Warehouse$adjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adjustment
     */
    select?: AdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adjustment
     */
    omit?: AdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentInclude<ExtArgs> | null
    where?: AdjustmentWhereInput
    orderBy?: AdjustmentOrderByWithRelationInput | AdjustmentOrderByWithRelationInput[]
    cursor?: AdjustmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdjustmentScalarFieldEnum | AdjustmentScalarFieldEnum[]
  }

  /**
   * Warehouse.stockMovesFrom
   */
  export type Warehouse$stockMovesFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMove
     */
    select?: StockMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMove
     */
    omit?: StockMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMoveInclude<ExtArgs> | null
    where?: StockMoveWhereInput
    orderBy?: StockMoveOrderByWithRelationInput | StockMoveOrderByWithRelationInput[]
    cursor?: StockMoveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMoveScalarFieldEnum | StockMoveScalarFieldEnum[]
  }

  /**
   * Warehouse.stockMovesTo
   */
  export type Warehouse$stockMovesToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMove
     */
    select?: StockMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMove
     */
    omit?: StockMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMoveInclude<ExtArgs> | null
    where?: StockMoveWhereInput
    orderBy?: StockMoveOrderByWithRelationInput | StockMoveOrderByWithRelationInput[]
    cursor?: StockMoveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMoveScalarFieldEnum | StockMoveScalarFieldEnum[]
  }

  /**
   * Warehouse.reorderRules
   */
  export type Warehouse$reorderRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReorderRule
     */
    select?: ReorderRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReorderRule
     */
    omit?: ReorderRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReorderRuleInclude<ExtArgs> | null
    where?: ReorderRuleWhereInput
    orderBy?: ReorderRuleOrderByWithRelationInput | ReorderRuleOrderByWithRelationInput[]
    cursor?: ReorderRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReorderRuleScalarFieldEnum | ReorderRuleScalarFieldEnum[]
  }

  /**
   * Warehouse without action
   */
  export type WarehouseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    id: number | null
    warehouseId: number | null
    parentId: number | null
  }

  export type LocationSumAggregateOutputType = {
    id: number | null
    warehouseId: number | null
    parentId: number | null
  }

  export type LocationMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    warehouseId: number | null
    parentId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    warehouseId: number | null
    parentId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    code: number
    name: number
    warehouseId: number
    parentId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    id?: true
    warehouseId?: true
    parentId?: true
  }

  export type LocationSumAggregateInputType = {
    id?: true
    warehouseId?: true
    parentId?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    warehouseId?: true
    parentId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    warehouseId?: true
    parentId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    warehouseId?: true
    parentId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: number
    code: string
    name: string
    warehouseId: number
    parentId: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    warehouseId?: boolean
    parentId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    stockQuants?: boolean | Location$stockQuantsArgs<ExtArgs>
    stockMovesFrom?: boolean | Location$stockMovesFromArgs<ExtArgs>
    stockMovesTo?: boolean | Location$stockMovesToArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    warehouseId?: boolean
    parentId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    warehouseId?: boolean
    parentId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    warehouseId?: boolean
    parentId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "warehouseId" | "parentId" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    stockQuants?: boolean | Location$stockQuantsArgs<ExtArgs>
    stockMovesFrom?: boolean | Location$stockMovesFromArgs<ExtArgs>
    stockMovesTo?: boolean | Location$stockMovesToArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      warehouse: Prisma.$WarehousePayload<ExtArgs>
      stockQuants: Prisma.$StockQuantPayload<ExtArgs>[]
      stockMovesFrom: Prisma.$StockMovePayload<ExtArgs>[]
      stockMovesTo: Prisma.$StockMovePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      warehouseId: number
      parentId: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stockQuants<T extends Location$stockQuantsArgs<ExtArgs> = {}>(args?: Subset<T, Location$stockQuantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockQuantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockMovesFrom<T extends Location$stockMovesFromArgs<ExtArgs> = {}>(args?: Subset<T, Location$stockMovesFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockMovesTo<T extends Location$stockMovesToArgs<ExtArgs> = {}>(args?: Subset<T, Location$stockMovesToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'Int'>
    readonly code: FieldRef<"Location", 'String'>
    readonly name: FieldRef<"Location", 'String'>
    readonly warehouseId: FieldRef<"Location", 'Int'>
    readonly parentId: FieldRef<"Location", 'Int'>
    readonly isActive: FieldRef<"Location", 'Boolean'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly updatedAt: FieldRef<"Location", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location.stockQuants
   */
  export type Location$stockQuantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockQuant
     */
    select?: StockQuantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockQuant
     */
    omit?: StockQuantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockQuantInclude<ExtArgs> | null
    where?: StockQuantWhereInput
    orderBy?: StockQuantOrderByWithRelationInput | StockQuantOrderByWithRelationInput[]
    cursor?: StockQuantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockQuantScalarFieldEnum | StockQuantScalarFieldEnum[]
  }

  /**
   * Location.stockMovesFrom
   */
  export type Location$stockMovesFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMove
     */
    select?: StockMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMove
     */
    omit?: StockMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMoveInclude<ExtArgs> | null
    where?: StockMoveWhereInput
    orderBy?: StockMoveOrderByWithRelationInput | StockMoveOrderByWithRelationInput[]
    cursor?: StockMoveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMoveScalarFieldEnum | StockMoveScalarFieldEnum[]
  }

  /**
   * Location.stockMovesTo
   */
  export type Location$stockMovesToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMove
     */
    select?: StockMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMove
     */
    omit?: StockMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMoveInclude<ExtArgs> | null
    where?: StockMoveWhereInput
    orderBy?: StockMoveOrderByWithRelationInput | StockMoveOrderByWithRelationInput[]
    cursor?: StockMoveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMoveScalarFieldEnum | StockMoveScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model StockQuant
   */

  export type AggregateStockQuant = {
    _count: StockQuantCountAggregateOutputType | null
    _avg: StockQuantAvgAggregateOutputType | null
    _sum: StockQuantSumAggregateOutputType | null
    _min: StockQuantMinAggregateOutputType | null
    _max: StockQuantMaxAggregateOutputType | null
  }

  export type StockQuantAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    warehouseId: number | null
    locationId: number | null
    quantity: Decimal | null
    reserved: Decimal | null
    incoming: Decimal | null
  }

  export type StockQuantSumAggregateOutputType = {
    id: number | null
    productId: number | null
    warehouseId: number | null
    locationId: number | null
    quantity: Decimal | null
    reserved: Decimal | null
    incoming: Decimal | null
  }

  export type StockQuantMinAggregateOutputType = {
    id: number | null
    productId: number | null
    warehouseId: number | null
    locationId: number | null
    quantity: Decimal | null
    reserved: Decimal | null
    incoming: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockQuantMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    warehouseId: number | null
    locationId: number | null
    quantity: Decimal | null
    reserved: Decimal | null
    incoming: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockQuantCountAggregateOutputType = {
    id: number
    productId: number
    warehouseId: number
    locationId: number
    quantity: number
    reserved: number
    incoming: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StockQuantAvgAggregateInputType = {
    id?: true
    productId?: true
    warehouseId?: true
    locationId?: true
    quantity?: true
    reserved?: true
    incoming?: true
  }

  export type StockQuantSumAggregateInputType = {
    id?: true
    productId?: true
    warehouseId?: true
    locationId?: true
    quantity?: true
    reserved?: true
    incoming?: true
  }

  export type StockQuantMinAggregateInputType = {
    id?: true
    productId?: true
    warehouseId?: true
    locationId?: true
    quantity?: true
    reserved?: true
    incoming?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockQuantMaxAggregateInputType = {
    id?: true
    productId?: true
    warehouseId?: true
    locationId?: true
    quantity?: true
    reserved?: true
    incoming?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockQuantCountAggregateInputType = {
    id?: true
    productId?: true
    warehouseId?: true
    locationId?: true
    quantity?: true
    reserved?: true
    incoming?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StockQuantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockQuant to aggregate.
     */
    where?: StockQuantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockQuants to fetch.
     */
    orderBy?: StockQuantOrderByWithRelationInput | StockQuantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockQuantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockQuants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockQuants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockQuants
    **/
    _count?: true | StockQuantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockQuantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockQuantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockQuantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockQuantMaxAggregateInputType
  }

  export type GetStockQuantAggregateType<T extends StockQuantAggregateArgs> = {
        [P in keyof T & keyof AggregateStockQuant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockQuant[P]>
      : GetScalarType<T[P], AggregateStockQuant[P]>
  }




  export type StockQuantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockQuantWhereInput
    orderBy?: StockQuantOrderByWithAggregationInput | StockQuantOrderByWithAggregationInput[]
    by: StockQuantScalarFieldEnum[] | StockQuantScalarFieldEnum
    having?: StockQuantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockQuantCountAggregateInputType | true
    _avg?: StockQuantAvgAggregateInputType
    _sum?: StockQuantSumAggregateInputType
    _min?: StockQuantMinAggregateInputType
    _max?: StockQuantMaxAggregateInputType
  }

  export type StockQuantGroupByOutputType = {
    id: number
    productId: number
    warehouseId: number
    locationId: number | null
    quantity: Decimal
    reserved: Decimal
    incoming: Decimal
    createdAt: Date
    updatedAt: Date
    _count: StockQuantCountAggregateOutputType | null
    _avg: StockQuantAvgAggregateOutputType | null
    _sum: StockQuantSumAggregateOutputType | null
    _min: StockQuantMinAggregateOutputType | null
    _max: StockQuantMaxAggregateOutputType | null
  }

  type GetStockQuantGroupByPayload<T extends StockQuantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockQuantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockQuantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockQuantGroupByOutputType[P]>
            : GetScalarType<T[P], StockQuantGroupByOutputType[P]>
        }
      >
    >


  export type StockQuantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    warehouseId?: boolean
    locationId?: boolean
    quantity?: boolean
    reserved?: boolean
    incoming?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    location?: boolean | StockQuant$locationArgs<ExtArgs>
  }, ExtArgs["result"]["stockQuant"]>

  export type StockQuantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    warehouseId?: boolean
    locationId?: boolean
    quantity?: boolean
    reserved?: boolean
    incoming?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    location?: boolean | StockQuant$locationArgs<ExtArgs>
  }, ExtArgs["result"]["stockQuant"]>

  export type StockQuantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    warehouseId?: boolean
    locationId?: boolean
    quantity?: boolean
    reserved?: boolean
    incoming?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    location?: boolean | StockQuant$locationArgs<ExtArgs>
  }, ExtArgs["result"]["stockQuant"]>

  export type StockQuantSelectScalar = {
    id?: boolean
    productId?: boolean
    warehouseId?: boolean
    locationId?: boolean
    quantity?: boolean
    reserved?: boolean
    incoming?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StockQuantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "warehouseId" | "locationId" | "quantity" | "reserved" | "incoming" | "createdAt" | "updatedAt", ExtArgs["result"]["stockQuant"]>
  export type StockQuantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    location?: boolean | StockQuant$locationArgs<ExtArgs>
  }
  export type StockQuantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    location?: boolean | StockQuant$locationArgs<ExtArgs>
  }
  export type StockQuantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    location?: boolean | StockQuant$locationArgs<ExtArgs>
  }

  export type $StockQuantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockQuant"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      warehouse: Prisma.$WarehousePayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      warehouseId: number
      locationId: number | null
      quantity: Prisma.Decimal
      reserved: Prisma.Decimal
      incoming: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stockQuant"]>
    composites: {}
  }

  type StockQuantGetPayload<S extends boolean | null | undefined | StockQuantDefaultArgs> = $Result.GetResult<Prisma.$StockQuantPayload, S>

  type StockQuantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockQuantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockQuantCountAggregateInputType | true
    }

  export interface StockQuantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockQuant'], meta: { name: 'StockQuant' } }
    /**
     * Find zero or one StockQuant that matches the filter.
     * @param {StockQuantFindUniqueArgs} args - Arguments to find a StockQuant
     * @example
     * // Get one StockQuant
     * const stockQuant = await prisma.stockQuant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockQuantFindUniqueArgs>(args: SelectSubset<T, StockQuantFindUniqueArgs<ExtArgs>>): Prisma__StockQuantClient<$Result.GetResult<Prisma.$StockQuantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockQuant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockQuantFindUniqueOrThrowArgs} args - Arguments to find a StockQuant
     * @example
     * // Get one StockQuant
     * const stockQuant = await prisma.stockQuant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockQuantFindUniqueOrThrowArgs>(args: SelectSubset<T, StockQuantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockQuantClient<$Result.GetResult<Prisma.$StockQuantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockQuant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockQuantFindFirstArgs} args - Arguments to find a StockQuant
     * @example
     * // Get one StockQuant
     * const stockQuant = await prisma.stockQuant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockQuantFindFirstArgs>(args?: SelectSubset<T, StockQuantFindFirstArgs<ExtArgs>>): Prisma__StockQuantClient<$Result.GetResult<Prisma.$StockQuantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockQuant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockQuantFindFirstOrThrowArgs} args - Arguments to find a StockQuant
     * @example
     * // Get one StockQuant
     * const stockQuant = await prisma.stockQuant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockQuantFindFirstOrThrowArgs>(args?: SelectSubset<T, StockQuantFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockQuantClient<$Result.GetResult<Prisma.$StockQuantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockQuants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockQuantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockQuants
     * const stockQuants = await prisma.stockQuant.findMany()
     * 
     * // Get first 10 StockQuants
     * const stockQuants = await prisma.stockQuant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockQuantWithIdOnly = await prisma.stockQuant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockQuantFindManyArgs>(args?: SelectSubset<T, StockQuantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockQuantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockQuant.
     * @param {StockQuantCreateArgs} args - Arguments to create a StockQuant.
     * @example
     * // Create one StockQuant
     * const StockQuant = await prisma.stockQuant.create({
     *   data: {
     *     // ... data to create a StockQuant
     *   }
     * })
     * 
     */
    create<T extends StockQuantCreateArgs>(args: SelectSubset<T, StockQuantCreateArgs<ExtArgs>>): Prisma__StockQuantClient<$Result.GetResult<Prisma.$StockQuantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockQuants.
     * @param {StockQuantCreateManyArgs} args - Arguments to create many StockQuants.
     * @example
     * // Create many StockQuants
     * const stockQuant = await prisma.stockQuant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockQuantCreateManyArgs>(args?: SelectSubset<T, StockQuantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockQuants and returns the data saved in the database.
     * @param {StockQuantCreateManyAndReturnArgs} args - Arguments to create many StockQuants.
     * @example
     * // Create many StockQuants
     * const stockQuant = await prisma.stockQuant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockQuants and only return the `id`
     * const stockQuantWithIdOnly = await prisma.stockQuant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockQuantCreateManyAndReturnArgs>(args?: SelectSubset<T, StockQuantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockQuantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockQuant.
     * @param {StockQuantDeleteArgs} args - Arguments to delete one StockQuant.
     * @example
     * // Delete one StockQuant
     * const StockQuant = await prisma.stockQuant.delete({
     *   where: {
     *     // ... filter to delete one StockQuant
     *   }
     * })
     * 
     */
    delete<T extends StockQuantDeleteArgs>(args: SelectSubset<T, StockQuantDeleteArgs<ExtArgs>>): Prisma__StockQuantClient<$Result.GetResult<Prisma.$StockQuantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockQuant.
     * @param {StockQuantUpdateArgs} args - Arguments to update one StockQuant.
     * @example
     * // Update one StockQuant
     * const stockQuant = await prisma.stockQuant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockQuantUpdateArgs>(args: SelectSubset<T, StockQuantUpdateArgs<ExtArgs>>): Prisma__StockQuantClient<$Result.GetResult<Prisma.$StockQuantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockQuants.
     * @param {StockQuantDeleteManyArgs} args - Arguments to filter StockQuants to delete.
     * @example
     * // Delete a few StockQuants
     * const { count } = await prisma.stockQuant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockQuantDeleteManyArgs>(args?: SelectSubset<T, StockQuantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockQuants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockQuantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockQuants
     * const stockQuant = await prisma.stockQuant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockQuantUpdateManyArgs>(args: SelectSubset<T, StockQuantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockQuants and returns the data updated in the database.
     * @param {StockQuantUpdateManyAndReturnArgs} args - Arguments to update many StockQuants.
     * @example
     * // Update many StockQuants
     * const stockQuant = await prisma.stockQuant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockQuants and only return the `id`
     * const stockQuantWithIdOnly = await prisma.stockQuant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockQuantUpdateManyAndReturnArgs>(args: SelectSubset<T, StockQuantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockQuantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockQuant.
     * @param {StockQuantUpsertArgs} args - Arguments to update or create a StockQuant.
     * @example
     * // Update or create a StockQuant
     * const stockQuant = await prisma.stockQuant.upsert({
     *   create: {
     *     // ... data to create a StockQuant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockQuant we want to update
     *   }
     * })
     */
    upsert<T extends StockQuantUpsertArgs>(args: SelectSubset<T, StockQuantUpsertArgs<ExtArgs>>): Prisma__StockQuantClient<$Result.GetResult<Prisma.$StockQuantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockQuants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockQuantCountArgs} args - Arguments to filter StockQuants to count.
     * @example
     * // Count the number of StockQuants
     * const count = await prisma.stockQuant.count({
     *   where: {
     *     // ... the filter for the StockQuants we want to count
     *   }
     * })
    **/
    count<T extends StockQuantCountArgs>(
      args?: Subset<T, StockQuantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockQuantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockQuant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockQuantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockQuantAggregateArgs>(args: Subset<T, StockQuantAggregateArgs>): Prisma.PrismaPromise<GetStockQuantAggregateType<T>>

    /**
     * Group by StockQuant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockQuantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockQuantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockQuantGroupByArgs['orderBy'] }
        : { orderBy?: StockQuantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockQuantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockQuantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockQuant model
   */
  readonly fields: StockQuantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockQuant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockQuantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    location<T extends StockQuant$locationArgs<ExtArgs> = {}>(args?: Subset<T, StockQuant$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockQuant model
   */
  interface StockQuantFieldRefs {
    readonly id: FieldRef<"StockQuant", 'Int'>
    readonly productId: FieldRef<"StockQuant", 'Int'>
    readonly warehouseId: FieldRef<"StockQuant", 'Int'>
    readonly locationId: FieldRef<"StockQuant", 'Int'>
    readonly quantity: FieldRef<"StockQuant", 'Decimal'>
    readonly reserved: FieldRef<"StockQuant", 'Decimal'>
    readonly incoming: FieldRef<"StockQuant", 'Decimal'>
    readonly createdAt: FieldRef<"StockQuant", 'DateTime'>
    readonly updatedAt: FieldRef<"StockQuant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockQuant findUnique
   */
  export type StockQuantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockQuant
     */
    select?: StockQuantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockQuant
     */
    omit?: StockQuantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockQuantInclude<ExtArgs> | null
    /**
     * Filter, which StockQuant to fetch.
     */
    where: StockQuantWhereUniqueInput
  }

  /**
   * StockQuant findUniqueOrThrow
   */
  export type StockQuantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockQuant
     */
    select?: StockQuantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockQuant
     */
    omit?: StockQuantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockQuantInclude<ExtArgs> | null
    /**
     * Filter, which StockQuant to fetch.
     */
    where: StockQuantWhereUniqueInput
  }

  /**
   * StockQuant findFirst
   */
  export type StockQuantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockQuant
     */
    select?: StockQuantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockQuant
     */
    omit?: StockQuantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockQuantInclude<ExtArgs> | null
    /**
     * Filter, which StockQuant to fetch.
     */
    where?: StockQuantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockQuants to fetch.
     */
    orderBy?: StockQuantOrderByWithRelationInput | StockQuantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockQuants.
     */
    cursor?: StockQuantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockQuants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockQuants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockQuants.
     */
    distinct?: StockQuantScalarFieldEnum | StockQuantScalarFieldEnum[]
  }

  /**
   * StockQuant findFirstOrThrow
   */
  export type StockQuantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockQuant
     */
    select?: StockQuantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockQuant
     */
    omit?: StockQuantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockQuantInclude<ExtArgs> | null
    /**
     * Filter, which StockQuant to fetch.
     */
    where?: StockQuantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockQuants to fetch.
     */
    orderBy?: StockQuantOrderByWithRelationInput | StockQuantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockQuants.
     */
    cursor?: StockQuantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockQuants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockQuants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockQuants.
     */
    distinct?: StockQuantScalarFieldEnum | StockQuantScalarFieldEnum[]
  }

  /**
   * StockQuant findMany
   */
  export type StockQuantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockQuant
     */
    select?: StockQuantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockQuant
     */
    omit?: StockQuantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockQuantInclude<ExtArgs> | null
    /**
     * Filter, which StockQuants to fetch.
     */
    where?: StockQuantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockQuants to fetch.
     */
    orderBy?: StockQuantOrderByWithRelationInput | StockQuantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockQuants.
     */
    cursor?: StockQuantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockQuants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockQuants.
     */
    skip?: number
    distinct?: StockQuantScalarFieldEnum | StockQuantScalarFieldEnum[]
  }

  /**
   * StockQuant create
   */
  export type StockQuantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockQuant
     */
    select?: StockQuantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockQuant
     */
    omit?: StockQuantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockQuantInclude<ExtArgs> | null
    /**
     * The data needed to create a StockQuant.
     */
    data: XOR<StockQuantCreateInput, StockQuantUncheckedCreateInput>
  }

  /**
   * StockQuant createMany
   */
  export type StockQuantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockQuants.
     */
    data: StockQuantCreateManyInput | StockQuantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockQuant createManyAndReturn
   */
  export type StockQuantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockQuant
     */
    select?: StockQuantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockQuant
     */
    omit?: StockQuantOmit<ExtArgs> | null
    /**
     * The data used to create many StockQuants.
     */
    data: StockQuantCreateManyInput | StockQuantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockQuantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockQuant update
   */
  export type StockQuantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockQuant
     */
    select?: StockQuantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockQuant
     */
    omit?: StockQuantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockQuantInclude<ExtArgs> | null
    /**
     * The data needed to update a StockQuant.
     */
    data: XOR<StockQuantUpdateInput, StockQuantUncheckedUpdateInput>
    /**
     * Choose, which StockQuant to update.
     */
    where: StockQuantWhereUniqueInput
  }

  /**
   * StockQuant updateMany
   */
  export type StockQuantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockQuants.
     */
    data: XOR<StockQuantUpdateManyMutationInput, StockQuantUncheckedUpdateManyInput>
    /**
     * Filter which StockQuants to update
     */
    where?: StockQuantWhereInput
    /**
     * Limit how many StockQuants to update.
     */
    limit?: number
  }

  /**
   * StockQuant updateManyAndReturn
   */
  export type StockQuantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockQuant
     */
    select?: StockQuantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockQuant
     */
    omit?: StockQuantOmit<ExtArgs> | null
    /**
     * The data used to update StockQuants.
     */
    data: XOR<StockQuantUpdateManyMutationInput, StockQuantUncheckedUpdateManyInput>
    /**
     * Filter which StockQuants to update
     */
    where?: StockQuantWhereInput
    /**
     * Limit how many StockQuants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockQuantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockQuant upsert
   */
  export type StockQuantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockQuant
     */
    select?: StockQuantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockQuant
     */
    omit?: StockQuantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockQuantInclude<ExtArgs> | null
    /**
     * The filter to search for the StockQuant to update in case it exists.
     */
    where: StockQuantWhereUniqueInput
    /**
     * In case the StockQuant found by the `where` argument doesn't exist, create a new StockQuant with this data.
     */
    create: XOR<StockQuantCreateInput, StockQuantUncheckedCreateInput>
    /**
     * In case the StockQuant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockQuantUpdateInput, StockQuantUncheckedUpdateInput>
  }

  /**
   * StockQuant delete
   */
  export type StockQuantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockQuant
     */
    select?: StockQuantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockQuant
     */
    omit?: StockQuantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockQuantInclude<ExtArgs> | null
    /**
     * Filter which StockQuant to delete.
     */
    where: StockQuantWhereUniqueInput
  }

  /**
   * StockQuant deleteMany
   */
  export type StockQuantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockQuants to delete
     */
    where?: StockQuantWhereInput
    /**
     * Limit how many StockQuants to delete.
     */
    limit?: number
  }

  /**
   * StockQuant.location
   */
  export type StockQuant$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * StockQuant without action
   */
  export type StockQuantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockQuant
     */
    select?: StockQuantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockQuant
     */
    omit?: StockQuantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockQuantInclude<ExtArgs> | null
  }


  /**
   * Model Receipt
   */

  export type AggregateReceipt = {
    _count: ReceiptCountAggregateOutputType | null
    _avg: ReceiptAvgAggregateOutputType | null
    _sum: ReceiptSumAggregateOutputType | null
    _min: ReceiptMinAggregateOutputType | null
    _max: ReceiptMaxAggregateOutputType | null
  }

  export type ReceiptAvgAggregateOutputType = {
    id: number | null
    warehouseId: number | null
    createdById: number | null
  }

  export type ReceiptSumAggregateOutputType = {
    id: number | null
    warehouseId: number | null
    createdById: number | null
  }

  export type ReceiptMinAggregateOutputType = {
    id: number | null
    receiptNo: string | null
    reference: string | null
    warehouseId: number | null
    partner: string | null
    status: $Enums.DocumentStatus | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReceiptMaxAggregateOutputType = {
    id: number | null
    receiptNo: string | null
    reference: string | null
    warehouseId: number | null
    partner: string | null
    status: $Enums.DocumentStatus | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReceiptCountAggregateOutputType = {
    id: number
    receiptNo: number
    reference: number
    warehouseId: number
    partner: number
    status: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReceiptAvgAggregateInputType = {
    id?: true
    warehouseId?: true
    createdById?: true
  }

  export type ReceiptSumAggregateInputType = {
    id?: true
    warehouseId?: true
    createdById?: true
  }

  export type ReceiptMinAggregateInputType = {
    id?: true
    receiptNo?: true
    reference?: true
    warehouseId?: true
    partner?: true
    status?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReceiptMaxAggregateInputType = {
    id?: true
    receiptNo?: true
    reference?: true
    warehouseId?: true
    partner?: true
    status?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReceiptCountAggregateInputType = {
    id?: true
    receiptNo?: true
    reference?: true
    warehouseId?: true
    partner?: true
    status?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReceiptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Receipt to aggregate.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Receipts
    **/
    _count?: true | ReceiptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceiptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceiptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceiptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceiptMaxAggregateInputType
  }

  export type GetReceiptAggregateType<T extends ReceiptAggregateArgs> = {
        [P in keyof T & keyof AggregateReceipt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceipt[P]>
      : GetScalarType<T[P], AggregateReceipt[P]>
  }




  export type ReceiptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceiptWhereInput
    orderBy?: ReceiptOrderByWithAggregationInput | ReceiptOrderByWithAggregationInput[]
    by: ReceiptScalarFieldEnum[] | ReceiptScalarFieldEnum
    having?: ReceiptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceiptCountAggregateInputType | true
    _avg?: ReceiptAvgAggregateInputType
    _sum?: ReceiptSumAggregateInputType
    _min?: ReceiptMinAggregateInputType
    _max?: ReceiptMaxAggregateInputType
  }

  export type ReceiptGroupByOutputType = {
    id: number
    receiptNo: string
    reference: string | null
    warehouseId: number
    partner: string | null
    status: $Enums.DocumentStatus
    createdById: number | null
    createdAt: Date
    updatedAt: Date
    _count: ReceiptCountAggregateOutputType | null
    _avg: ReceiptAvgAggregateOutputType | null
    _sum: ReceiptSumAggregateOutputType | null
    _min: ReceiptMinAggregateOutputType | null
    _max: ReceiptMaxAggregateOutputType | null
  }

  type GetReceiptGroupByPayload<T extends ReceiptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceiptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceiptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceiptGroupByOutputType[P]>
            : GetScalarType<T[P], ReceiptGroupByOutputType[P]>
        }
      >
    >


  export type ReceiptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptNo?: boolean
    reference?: boolean
    warehouseId?: boolean
    partner?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Receipt$createdByArgs<ExtArgs>
    lines?: boolean | Receipt$linesArgs<ExtArgs>
    _count?: boolean | ReceiptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receipt"]>

  export type ReceiptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptNo?: boolean
    reference?: boolean
    warehouseId?: boolean
    partner?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Receipt$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["receipt"]>

  export type ReceiptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptNo?: boolean
    reference?: boolean
    warehouseId?: boolean
    partner?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Receipt$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["receipt"]>

  export type ReceiptSelectScalar = {
    id?: boolean
    receiptNo?: boolean
    reference?: boolean
    warehouseId?: boolean
    partner?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReceiptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "receiptNo" | "reference" | "warehouseId" | "partner" | "status" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["receipt"]>
  export type ReceiptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Receipt$createdByArgs<ExtArgs>
    lines?: boolean | Receipt$linesArgs<ExtArgs>
    _count?: boolean | ReceiptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReceiptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Receipt$createdByArgs<ExtArgs>
  }
  export type ReceiptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Receipt$createdByArgs<ExtArgs>
  }

  export type $ReceiptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Receipt"
    objects: {
      warehouse: Prisma.$WarehousePayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      lines: Prisma.$ReceiptLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      receiptNo: string
      reference: string | null
      warehouseId: number
      partner: string | null
      status: $Enums.DocumentStatus
      createdById: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["receipt"]>
    composites: {}
  }

  type ReceiptGetPayload<S extends boolean | null | undefined | ReceiptDefaultArgs> = $Result.GetResult<Prisma.$ReceiptPayload, S>

  type ReceiptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReceiptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReceiptCountAggregateInputType | true
    }

  export interface ReceiptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Receipt'], meta: { name: 'Receipt' } }
    /**
     * Find zero or one Receipt that matches the filter.
     * @param {ReceiptFindUniqueArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReceiptFindUniqueArgs>(args: SelectSubset<T, ReceiptFindUniqueArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Receipt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReceiptFindUniqueOrThrowArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReceiptFindUniqueOrThrowArgs>(args: SelectSubset<T, ReceiptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Receipt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptFindFirstArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReceiptFindFirstArgs>(args?: SelectSubset<T, ReceiptFindFirstArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Receipt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptFindFirstOrThrowArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReceiptFindFirstOrThrowArgs>(args?: SelectSubset<T, ReceiptFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Receipts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Receipts
     * const receipts = await prisma.receipt.findMany()
     * 
     * // Get first 10 Receipts
     * const receipts = await prisma.receipt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receiptWithIdOnly = await prisma.receipt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReceiptFindManyArgs>(args?: SelectSubset<T, ReceiptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Receipt.
     * @param {ReceiptCreateArgs} args - Arguments to create a Receipt.
     * @example
     * // Create one Receipt
     * const Receipt = await prisma.receipt.create({
     *   data: {
     *     // ... data to create a Receipt
     *   }
     * })
     * 
     */
    create<T extends ReceiptCreateArgs>(args: SelectSubset<T, ReceiptCreateArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Receipts.
     * @param {ReceiptCreateManyArgs} args - Arguments to create many Receipts.
     * @example
     * // Create many Receipts
     * const receipt = await prisma.receipt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReceiptCreateManyArgs>(args?: SelectSubset<T, ReceiptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Receipts and returns the data saved in the database.
     * @param {ReceiptCreateManyAndReturnArgs} args - Arguments to create many Receipts.
     * @example
     * // Create many Receipts
     * const receipt = await prisma.receipt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Receipts and only return the `id`
     * const receiptWithIdOnly = await prisma.receipt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReceiptCreateManyAndReturnArgs>(args?: SelectSubset<T, ReceiptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Receipt.
     * @param {ReceiptDeleteArgs} args - Arguments to delete one Receipt.
     * @example
     * // Delete one Receipt
     * const Receipt = await prisma.receipt.delete({
     *   where: {
     *     // ... filter to delete one Receipt
     *   }
     * })
     * 
     */
    delete<T extends ReceiptDeleteArgs>(args: SelectSubset<T, ReceiptDeleteArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Receipt.
     * @param {ReceiptUpdateArgs} args - Arguments to update one Receipt.
     * @example
     * // Update one Receipt
     * const receipt = await prisma.receipt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReceiptUpdateArgs>(args: SelectSubset<T, ReceiptUpdateArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Receipts.
     * @param {ReceiptDeleteManyArgs} args - Arguments to filter Receipts to delete.
     * @example
     * // Delete a few Receipts
     * const { count } = await prisma.receipt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReceiptDeleteManyArgs>(args?: SelectSubset<T, ReceiptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Receipts
     * const receipt = await prisma.receipt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReceiptUpdateManyArgs>(args: SelectSubset<T, ReceiptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receipts and returns the data updated in the database.
     * @param {ReceiptUpdateManyAndReturnArgs} args - Arguments to update many Receipts.
     * @example
     * // Update many Receipts
     * const receipt = await prisma.receipt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Receipts and only return the `id`
     * const receiptWithIdOnly = await prisma.receipt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReceiptUpdateManyAndReturnArgs>(args: SelectSubset<T, ReceiptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Receipt.
     * @param {ReceiptUpsertArgs} args - Arguments to update or create a Receipt.
     * @example
     * // Update or create a Receipt
     * const receipt = await prisma.receipt.upsert({
     *   create: {
     *     // ... data to create a Receipt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Receipt we want to update
     *   }
     * })
     */
    upsert<T extends ReceiptUpsertArgs>(args: SelectSubset<T, ReceiptUpsertArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Receipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptCountArgs} args - Arguments to filter Receipts to count.
     * @example
     * // Count the number of Receipts
     * const count = await prisma.receipt.count({
     *   where: {
     *     // ... the filter for the Receipts we want to count
     *   }
     * })
    **/
    count<T extends ReceiptCountArgs>(
      args?: Subset<T, ReceiptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceiptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Receipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceiptAggregateArgs>(args: Subset<T, ReceiptAggregateArgs>): Prisma.PrismaPromise<GetReceiptAggregateType<T>>

    /**
     * Group by Receipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceiptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceiptGroupByArgs['orderBy'] }
        : { orderBy?: ReceiptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceiptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceiptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Receipt model
   */
  readonly fields: ReceiptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Receipt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReceiptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Receipt$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Receipt$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lines<T extends Receipt$linesArgs<ExtArgs> = {}>(args?: Subset<T, Receipt$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Receipt model
   */
  interface ReceiptFieldRefs {
    readonly id: FieldRef<"Receipt", 'Int'>
    readonly receiptNo: FieldRef<"Receipt", 'String'>
    readonly reference: FieldRef<"Receipt", 'String'>
    readonly warehouseId: FieldRef<"Receipt", 'Int'>
    readonly partner: FieldRef<"Receipt", 'String'>
    readonly status: FieldRef<"Receipt", 'DocumentStatus'>
    readonly createdById: FieldRef<"Receipt", 'Int'>
    readonly createdAt: FieldRef<"Receipt", 'DateTime'>
    readonly updatedAt: FieldRef<"Receipt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Receipt findUnique
   */
  export type ReceiptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where: ReceiptWhereUniqueInput
  }

  /**
   * Receipt findUniqueOrThrow
   */
  export type ReceiptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where: ReceiptWhereUniqueInput
  }

  /**
   * Receipt findFirst
   */
  export type ReceiptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receipts.
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receipts.
     */
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }

  /**
   * Receipt findFirstOrThrow
   */
  export type ReceiptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receipts.
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receipts.
     */
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }

  /**
   * Receipt findMany
   */
  export type ReceiptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipts to fetch.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Receipts.
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }

  /**
   * Receipt create
   */
  export type ReceiptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * The data needed to create a Receipt.
     */
    data: XOR<ReceiptCreateInput, ReceiptUncheckedCreateInput>
  }

  /**
   * Receipt createMany
   */
  export type ReceiptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Receipts.
     */
    data: ReceiptCreateManyInput | ReceiptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Receipt createManyAndReturn
   */
  export type ReceiptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * The data used to create many Receipts.
     */
    data: ReceiptCreateManyInput | ReceiptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Receipt update
   */
  export type ReceiptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * The data needed to update a Receipt.
     */
    data: XOR<ReceiptUpdateInput, ReceiptUncheckedUpdateInput>
    /**
     * Choose, which Receipt to update.
     */
    where: ReceiptWhereUniqueInput
  }

  /**
   * Receipt updateMany
   */
  export type ReceiptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Receipts.
     */
    data: XOR<ReceiptUpdateManyMutationInput, ReceiptUncheckedUpdateManyInput>
    /**
     * Filter which Receipts to update
     */
    where?: ReceiptWhereInput
    /**
     * Limit how many Receipts to update.
     */
    limit?: number
  }

  /**
   * Receipt updateManyAndReturn
   */
  export type ReceiptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * The data used to update Receipts.
     */
    data: XOR<ReceiptUpdateManyMutationInput, ReceiptUncheckedUpdateManyInput>
    /**
     * Filter which Receipts to update
     */
    where?: ReceiptWhereInput
    /**
     * Limit how many Receipts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Receipt upsert
   */
  export type ReceiptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * The filter to search for the Receipt to update in case it exists.
     */
    where: ReceiptWhereUniqueInput
    /**
     * In case the Receipt found by the `where` argument doesn't exist, create a new Receipt with this data.
     */
    create: XOR<ReceiptCreateInput, ReceiptUncheckedCreateInput>
    /**
     * In case the Receipt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceiptUpdateInput, ReceiptUncheckedUpdateInput>
  }

  /**
   * Receipt delete
   */
  export type ReceiptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter which Receipt to delete.
     */
    where: ReceiptWhereUniqueInput
  }

  /**
   * Receipt deleteMany
   */
  export type ReceiptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Receipts to delete
     */
    where?: ReceiptWhereInput
    /**
     * Limit how many Receipts to delete.
     */
    limit?: number
  }

  /**
   * Receipt.createdBy
   */
  export type Receipt$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Receipt.lines
   */
  export type Receipt$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptLine
     */
    select?: ReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptLine
     */
    omit?: ReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptLineInclude<ExtArgs> | null
    where?: ReceiptLineWhereInput
    orderBy?: ReceiptLineOrderByWithRelationInput | ReceiptLineOrderByWithRelationInput[]
    cursor?: ReceiptLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceiptLineScalarFieldEnum | ReceiptLineScalarFieldEnum[]
  }

  /**
   * Receipt without action
   */
  export type ReceiptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
  }


  /**
   * Model ReceiptLine
   */

  export type AggregateReceiptLine = {
    _count: ReceiptLineCountAggregateOutputType | null
    _avg: ReceiptLineAvgAggregateOutputType | null
    _sum: ReceiptLineSumAggregateOutputType | null
    _min: ReceiptLineMinAggregateOutputType | null
    _max: ReceiptLineMaxAggregateOutputType | null
  }

  export type ReceiptLineAvgAggregateOutputType = {
    id: number | null
    receiptId: number | null
    productId: number | null
    quantity: Decimal | null
    unitPrice: Decimal | null
  }

  export type ReceiptLineSumAggregateOutputType = {
    id: number | null
    receiptId: number | null
    productId: number | null
    quantity: Decimal | null
    unitPrice: Decimal | null
  }

  export type ReceiptLineMinAggregateOutputType = {
    id: number | null
    receiptId: number | null
    productId: number | null
    quantity: Decimal | null
    uom: string | null
    unitPrice: Decimal | null
  }

  export type ReceiptLineMaxAggregateOutputType = {
    id: number | null
    receiptId: number | null
    productId: number | null
    quantity: Decimal | null
    uom: string | null
    unitPrice: Decimal | null
  }

  export type ReceiptLineCountAggregateOutputType = {
    id: number
    receiptId: number
    productId: number
    quantity: number
    uom: number
    unitPrice: number
    _all: number
  }


  export type ReceiptLineAvgAggregateInputType = {
    id?: true
    receiptId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
  }

  export type ReceiptLineSumAggregateInputType = {
    id?: true
    receiptId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
  }

  export type ReceiptLineMinAggregateInputType = {
    id?: true
    receiptId?: true
    productId?: true
    quantity?: true
    uom?: true
    unitPrice?: true
  }

  export type ReceiptLineMaxAggregateInputType = {
    id?: true
    receiptId?: true
    productId?: true
    quantity?: true
    uom?: true
    unitPrice?: true
  }

  export type ReceiptLineCountAggregateInputType = {
    id?: true
    receiptId?: true
    productId?: true
    quantity?: true
    uom?: true
    unitPrice?: true
    _all?: true
  }

  export type ReceiptLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReceiptLine to aggregate.
     */
    where?: ReceiptLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceiptLines to fetch.
     */
    orderBy?: ReceiptLineOrderByWithRelationInput | ReceiptLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceiptLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceiptLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceiptLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReceiptLines
    **/
    _count?: true | ReceiptLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceiptLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceiptLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceiptLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceiptLineMaxAggregateInputType
  }

  export type GetReceiptLineAggregateType<T extends ReceiptLineAggregateArgs> = {
        [P in keyof T & keyof AggregateReceiptLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceiptLine[P]>
      : GetScalarType<T[P], AggregateReceiptLine[P]>
  }




  export type ReceiptLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceiptLineWhereInput
    orderBy?: ReceiptLineOrderByWithAggregationInput | ReceiptLineOrderByWithAggregationInput[]
    by: ReceiptLineScalarFieldEnum[] | ReceiptLineScalarFieldEnum
    having?: ReceiptLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceiptLineCountAggregateInputType | true
    _avg?: ReceiptLineAvgAggregateInputType
    _sum?: ReceiptLineSumAggregateInputType
    _min?: ReceiptLineMinAggregateInputType
    _max?: ReceiptLineMaxAggregateInputType
  }

  export type ReceiptLineGroupByOutputType = {
    id: number
    receiptId: number
    productId: number
    quantity: Decimal
    uom: string
    unitPrice: Decimal | null
    _count: ReceiptLineCountAggregateOutputType | null
    _avg: ReceiptLineAvgAggregateOutputType | null
    _sum: ReceiptLineSumAggregateOutputType | null
    _min: ReceiptLineMinAggregateOutputType | null
    _max: ReceiptLineMaxAggregateOutputType | null
  }

  type GetReceiptLineGroupByPayload<T extends ReceiptLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceiptLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceiptLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceiptLineGroupByOutputType[P]>
            : GetScalarType<T[P], ReceiptLineGroupByOutputType[P]>
        }
      >
    >


  export type ReceiptLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptId?: boolean
    productId?: boolean
    quantity?: boolean
    uom?: boolean
    unitPrice?: boolean
    receipt?: boolean | ReceiptDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receiptLine"]>

  export type ReceiptLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptId?: boolean
    productId?: boolean
    quantity?: boolean
    uom?: boolean
    unitPrice?: boolean
    receipt?: boolean | ReceiptDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receiptLine"]>

  export type ReceiptLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptId?: boolean
    productId?: boolean
    quantity?: boolean
    uom?: boolean
    unitPrice?: boolean
    receipt?: boolean | ReceiptDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receiptLine"]>

  export type ReceiptLineSelectScalar = {
    id?: boolean
    receiptId?: boolean
    productId?: boolean
    quantity?: boolean
    uom?: boolean
    unitPrice?: boolean
  }

  export type ReceiptLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "receiptId" | "productId" | "quantity" | "uom" | "unitPrice", ExtArgs["result"]["receiptLine"]>
  export type ReceiptLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receipt?: boolean | ReceiptDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ReceiptLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receipt?: boolean | ReceiptDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ReceiptLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receipt?: boolean | ReceiptDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ReceiptLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReceiptLine"
    objects: {
      receipt: Prisma.$ReceiptPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      receiptId: number
      productId: number
      quantity: Prisma.Decimal
      uom: string
      unitPrice: Prisma.Decimal | null
    }, ExtArgs["result"]["receiptLine"]>
    composites: {}
  }

  type ReceiptLineGetPayload<S extends boolean | null | undefined | ReceiptLineDefaultArgs> = $Result.GetResult<Prisma.$ReceiptLinePayload, S>

  type ReceiptLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReceiptLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReceiptLineCountAggregateInputType | true
    }

  export interface ReceiptLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReceiptLine'], meta: { name: 'ReceiptLine' } }
    /**
     * Find zero or one ReceiptLine that matches the filter.
     * @param {ReceiptLineFindUniqueArgs} args - Arguments to find a ReceiptLine
     * @example
     * // Get one ReceiptLine
     * const receiptLine = await prisma.receiptLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReceiptLineFindUniqueArgs>(args: SelectSubset<T, ReceiptLineFindUniqueArgs<ExtArgs>>): Prisma__ReceiptLineClient<$Result.GetResult<Prisma.$ReceiptLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReceiptLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReceiptLineFindUniqueOrThrowArgs} args - Arguments to find a ReceiptLine
     * @example
     * // Get one ReceiptLine
     * const receiptLine = await prisma.receiptLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReceiptLineFindUniqueOrThrowArgs>(args: SelectSubset<T, ReceiptLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReceiptLineClient<$Result.GetResult<Prisma.$ReceiptLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReceiptLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptLineFindFirstArgs} args - Arguments to find a ReceiptLine
     * @example
     * // Get one ReceiptLine
     * const receiptLine = await prisma.receiptLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReceiptLineFindFirstArgs>(args?: SelectSubset<T, ReceiptLineFindFirstArgs<ExtArgs>>): Prisma__ReceiptLineClient<$Result.GetResult<Prisma.$ReceiptLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReceiptLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptLineFindFirstOrThrowArgs} args - Arguments to find a ReceiptLine
     * @example
     * // Get one ReceiptLine
     * const receiptLine = await prisma.receiptLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReceiptLineFindFirstOrThrowArgs>(args?: SelectSubset<T, ReceiptLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReceiptLineClient<$Result.GetResult<Prisma.$ReceiptLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReceiptLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReceiptLines
     * const receiptLines = await prisma.receiptLine.findMany()
     * 
     * // Get first 10 ReceiptLines
     * const receiptLines = await prisma.receiptLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receiptLineWithIdOnly = await prisma.receiptLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReceiptLineFindManyArgs>(args?: SelectSubset<T, ReceiptLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReceiptLine.
     * @param {ReceiptLineCreateArgs} args - Arguments to create a ReceiptLine.
     * @example
     * // Create one ReceiptLine
     * const ReceiptLine = await prisma.receiptLine.create({
     *   data: {
     *     // ... data to create a ReceiptLine
     *   }
     * })
     * 
     */
    create<T extends ReceiptLineCreateArgs>(args: SelectSubset<T, ReceiptLineCreateArgs<ExtArgs>>): Prisma__ReceiptLineClient<$Result.GetResult<Prisma.$ReceiptLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReceiptLines.
     * @param {ReceiptLineCreateManyArgs} args - Arguments to create many ReceiptLines.
     * @example
     * // Create many ReceiptLines
     * const receiptLine = await prisma.receiptLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReceiptLineCreateManyArgs>(args?: SelectSubset<T, ReceiptLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReceiptLines and returns the data saved in the database.
     * @param {ReceiptLineCreateManyAndReturnArgs} args - Arguments to create many ReceiptLines.
     * @example
     * // Create many ReceiptLines
     * const receiptLine = await prisma.receiptLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReceiptLines and only return the `id`
     * const receiptLineWithIdOnly = await prisma.receiptLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReceiptLineCreateManyAndReturnArgs>(args?: SelectSubset<T, ReceiptLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReceiptLine.
     * @param {ReceiptLineDeleteArgs} args - Arguments to delete one ReceiptLine.
     * @example
     * // Delete one ReceiptLine
     * const ReceiptLine = await prisma.receiptLine.delete({
     *   where: {
     *     // ... filter to delete one ReceiptLine
     *   }
     * })
     * 
     */
    delete<T extends ReceiptLineDeleteArgs>(args: SelectSubset<T, ReceiptLineDeleteArgs<ExtArgs>>): Prisma__ReceiptLineClient<$Result.GetResult<Prisma.$ReceiptLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReceiptLine.
     * @param {ReceiptLineUpdateArgs} args - Arguments to update one ReceiptLine.
     * @example
     * // Update one ReceiptLine
     * const receiptLine = await prisma.receiptLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReceiptLineUpdateArgs>(args: SelectSubset<T, ReceiptLineUpdateArgs<ExtArgs>>): Prisma__ReceiptLineClient<$Result.GetResult<Prisma.$ReceiptLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReceiptLines.
     * @param {ReceiptLineDeleteManyArgs} args - Arguments to filter ReceiptLines to delete.
     * @example
     * // Delete a few ReceiptLines
     * const { count } = await prisma.receiptLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReceiptLineDeleteManyArgs>(args?: SelectSubset<T, ReceiptLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReceiptLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReceiptLines
     * const receiptLine = await prisma.receiptLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReceiptLineUpdateManyArgs>(args: SelectSubset<T, ReceiptLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReceiptLines and returns the data updated in the database.
     * @param {ReceiptLineUpdateManyAndReturnArgs} args - Arguments to update many ReceiptLines.
     * @example
     * // Update many ReceiptLines
     * const receiptLine = await prisma.receiptLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReceiptLines and only return the `id`
     * const receiptLineWithIdOnly = await prisma.receiptLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReceiptLineUpdateManyAndReturnArgs>(args: SelectSubset<T, ReceiptLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReceiptLine.
     * @param {ReceiptLineUpsertArgs} args - Arguments to update or create a ReceiptLine.
     * @example
     * // Update or create a ReceiptLine
     * const receiptLine = await prisma.receiptLine.upsert({
     *   create: {
     *     // ... data to create a ReceiptLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReceiptLine we want to update
     *   }
     * })
     */
    upsert<T extends ReceiptLineUpsertArgs>(args: SelectSubset<T, ReceiptLineUpsertArgs<ExtArgs>>): Prisma__ReceiptLineClient<$Result.GetResult<Prisma.$ReceiptLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReceiptLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptLineCountArgs} args - Arguments to filter ReceiptLines to count.
     * @example
     * // Count the number of ReceiptLines
     * const count = await prisma.receiptLine.count({
     *   where: {
     *     // ... the filter for the ReceiptLines we want to count
     *   }
     * })
    **/
    count<T extends ReceiptLineCountArgs>(
      args?: Subset<T, ReceiptLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceiptLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReceiptLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceiptLineAggregateArgs>(args: Subset<T, ReceiptLineAggregateArgs>): Prisma.PrismaPromise<GetReceiptLineAggregateType<T>>

    /**
     * Group by ReceiptLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceiptLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceiptLineGroupByArgs['orderBy'] }
        : { orderBy?: ReceiptLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceiptLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceiptLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReceiptLine model
   */
  readonly fields: ReceiptLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReceiptLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReceiptLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    receipt<T extends ReceiptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReceiptDefaultArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReceiptLine model
   */
  interface ReceiptLineFieldRefs {
    readonly id: FieldRef<"ReceiptLine", 'Int'>
    readonly receiptId: FieldRef<"ReceiptLine", 'Int'>
    readonly productId: FieldRef<"ReceiptLine", 'Int'>
    readonly quantity: FieldRef<"ReceiptLine", 'Decimal'>
    readonly uom: FieldRef<"ReceiptLine", 'String'>
    readonly unitPrice: FieldRef<"ReceiptLine", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * ReceiptLine findUnique
   */
  export type ReceiptLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptLine
     */
    select?: ReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptLine
     */
    omit?: ReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptLineInclude<ExtArgs> | null
    /**
     * Filter, which ReceiptLine to fetch.
     */
    where: ReceiptLineWhereUniqueInput
  }

  /**
   * ReceiptLine findUniqueOrThrow
   */
  export type ReceiptLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptLine
     */
    select?: ReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptLine
     */
    omit?: ReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptLineInclude<ExtArgs> | null
    /**
     * Filter, which ReceiptLine to fetch.
     */
    where: ReceiptLineWhereUniqueInput
  }

  /**
   * ReceiptLine findFirst
   */
  export type ReceiptLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptLine
     */
    select?: ReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptLine
     */
    omit?: ReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptLineInclude<ExtArgs> | null
    /**
     * Filter, which ReceiptLine to fetch.
     */
    where?: ReceiptLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceiptLines to fetch.
     */
    orderBy?: ReceiptLineOrderByWithRelationInput | ReceiptLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReceiptLines.
     */
    cursor?: ReceiptLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceiptLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceiptLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReceiptLines.
     */
    distinct?: ReceiptLineScalarFieldEnum | ReceiptLineScalarFieldEnum[]
  }

  /**
   * ReceiptLine findFirstOrThrow
   */
  export type ReceiptLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptLine
     */
    select?: ReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptLine
     */
    omit?: ReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptLineInclude<ExtArgs> | null
    /**
     * Filter, which ReceiptLine to fetch.
     */
    where?: ReceiptLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceiptLines to fetch.
     */
    orderBy?: ReceiptLineOrderByWithRelationInput | ReceiptLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReceiptLines.
     */
    cursor?: ReceiptLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceiptLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceiptLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReceiptLines.
     */
    distinct?: ReceiptLineScalarFieldEnum | ReceiptLineScalarFieldEnum[]
  }

  /**
   * ReceiptLine findMany
   */
  export type ReceiptLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptLine
     */
    select?: ReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptLine
     */
    omit?: ReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptLineInclude<ExtArgs> | null
    /**
     * Filter, which ReceiptLines to fetch.
     */
    where?: ReceiptLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceiptLines to fetch.
     */
    orderBy?: ReceiptLineOrderByWithRelationInput | ReceiptLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReceiptLines.
     */
    cursor?: ReceiptLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceiptLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceiptLines.
     */
    skip?: number
    distinct?: ReceiptLineScalarFieldEnum | ReceiptLineScalarFieldEnum[]
  }

  /**
   * ReceiptLine create
   */
  export type ReceiptLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptLine
     */
    select?: ReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptLine
     */
    omit?: ReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptLineInclude<ExtArgs> | null
    /**
     * The data needed to create a ReceiptLine.
     */
    data: XOR<ReceiptLineCreateInput, ReceiptLineUncheckedCreateInput>
  }

  /**
   * ReceiptLine createMany
   */
  export type ReceiptLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReceiptLines.
     */
    data: ReceiptLineCreateManyInput | ReceiptLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReceiptLine createManyAndReturn
   */
  export type ReceiptLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptLine
     */
    select?: ReceiptLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptLine
     */
    omit?: ReceiptLineOmit<ExtArgs> | null
    /**
     * The data used to create many ReceiptLines.
     */
    data: ReceiptLineCreateManyInput | ReceiptLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReceiptLine update
   */
  export type ReceiptLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptLine
     */
    select?: ReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptLine
     */
    omit?: ReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptLineInclude<ExtArgs> | null
    /**
     * The data needed to update a ReceiptLine.
     */
    data: XOR<ReceiptLineUpdateInput, ReceiptLineUncheckedUpdateInput>
    /**
     * Choose, which ReceiptLine to update.
     */
    where: ReceiptLineWhereUniqueInput
  }

  /**
   * ReceiptLine updateMany
   */
  export type ReceiptLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReceiptLines.
     */
    data: XOR<ReceiptLineUpdateManyMutationInput, ReceiptLineUncheckedUpdateManyInput>
    /**
     * Filter which ReceiptLines to update
     */
    where?: ReceiptLineWhereInput
    /**
     * Limit how many ReceiptLines to update.
     */
    limit?: number
  }

  /**
   * ReceiptLine updateManyAndReturn
   */
  export type ReceiptLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptLine
     */
    select?: ReceiptLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptLine
     */
    omit?: ReceiptLineOmit<ExtArgs> | null
    /**
     * The data used to update ReceiptLines.
     */
    data: XOR<ReceiptLineUpdateManyMutationInput, ReceiptLineUncheckedUpdateManyInput>
    /**
     * Filter which ReceiptLines to update
     */
    where?: ReceiptLineWhereInput
    /**
     * Limit how many ReceiptLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReceiptLine upsert
   */
  export type ReceiptLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptLine
     */
    select?: ReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptLine
     */
    omit?: ReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptLineInclude<ExtArgs> | null
    /**
     * The filter to search for the ReceiptLine to update in case it exists.
     */
    where: ReceiptLineWhereUniqueInput
    /**
     * In case the ReceiptLine found by the `where` argument doesn't exist, create a new ReceiptLine with this data.
     */
    create: XOR<ReceiptLineCreateInput, ReceiptLineUncheckedCreateInput>
    /**
     * In case the ReceiptLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceiptLineUpdateInput, ReceiptLineUncheckedUpdateInput>
  }

  /**
   * ReceiptLine delete
   */
  export type ReceiptLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptLine
     */
    select?: ReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptLine
     */
    omit?: ReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptLineInclude<ExtArgs> | null
    /**
     * Filter which ReceiptLine to delete.
     */
    where: ReceiptLineWhereUniqueInput
  }

  /**
   * ReceiptLine deleteMany
   */
  export type ReceiptLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReceiptLines to delete
     */
    where?: ReceiptLineWhereInput
    /**
     * Limit how many ReceiptLines to delete.
     */
    limit?: number
  }

  /**
   * ReceiptLine without action
   */
  export type ReceiptLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptLine
     */
    select?: ReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptLine
     */
    omit?: ReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptLineInclude<ExtArgs> | null
  }


  /**
   * Model Delivery
   */

  export type AggregateDelivery = {
    _count: DeliveryCountAggregateOutputType | null
    _avg: DeliveryAvgAggregateOutputType | null
    _sum: DeliverySumAggregateOutputType | null
    _min: DeliveryMinAggregateOutputType | null
    _max: DeliveryMaxAggregateOutputType | null
  }

  export type DeliveryAvgAggregateOutputType = {
    id: number | null
    warehouseId: number | null
    createdById: number | null
  }

  export type DeliverySumAggregateOutputType = {
    id: number | null
    warehouseId: number | null
    createdById: number | null
  }

  export type DeliveryMinAggregateOutputType = {
    id: number | null
    deliveryNo: string | null
    reference: string | null
    warehouseId: number | null
    partner: string | null
    status: $Enums.DocumentStatus | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryMaxAggregateOutputType = {
    id: number | null
    deliveryNo: string | null
    reference: string | null
    warehouseId: number | null
    partner: string | null
    status: $Enums.DocumentStatus | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryCountAggregateOutputType = {
    id: number
    deliveryNo: number
    reference: number
    warehouseId: number
    partner: number
    status: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeliveryAvgAggregateInputType = {
    id?: true
    warehouseId?: true
    createdById?: true
  }

  export type DeliverySumAggregateInputType = {
    id?: true
    warehouseId?: true
    createdById?: true
  }

  export type DeliveryMinAggregateInputType = {
    id?: true
    deliveryNo?: true
    reference?: true
    warehouseId?: true
    partner?: true
    status?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryMaxAggregateInputType = {
    id?: true
    deliveryNo?: true
    reference?: true
    warehouseId?: true
    partner?: true
    status?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryCountAggregateInputType = {
    id?: true
    deliveryNo?: true
    reference?: true
    warehouseId?: true
    partner?: true
    status?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeliveryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Delivery to aggregate.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deliveries
    **/
    _count?: true | DeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliverySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryMaxAggregateInputType
  }

  export type GetDeliveryAggregateType<T extends DeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDelivery[P]>
      : GetScalarType<T[P], AggregateDelivery[P]>
  }




  export type DeliveryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryWhereInput
    orderBy?: DeliveryOrderByWithAggregationInput | DeliveryOrderByWithAggregationInput[]
    by: DeliveryScalarFieldEnum[] | DeliveryScalarFieldEnum
    having?: DeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryCountAggregateInputType | true
    _avg?: DeliveryAvgAggregateInputType
    _sum?: DeliverySumAggregateInputType
    _min?: DeliveryMinAggregateInputType
    _max?: DeliveryMaxAggregateInputType
  }

  export type DeliveryGroupByOutputType = {
    id: number
    deliveryNo: string
    reference: string | null
    warehouseId: number
    partner: string | null
    status: $Enums.DocumentStatus
    createdById: number | null
    createdAt: Date
    updatedAt: Date
    _count: DeliveryCountAggregateOutputType | null
    _avg: DeliveryAvgAggregateOutputType | null
    _sum: DeliverySumAggregateOutputType | null
    _min: DeliveryMinAggregateOutputType | null
    _max: DeliveryMaxAggregateOutputType | null
  }

  type GetDeliveryGroupByPayload<T extends DeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryGroupByOutputType[P]>
        }
      >
    >


  export type DeliverySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deliveryNo?: boolean
    reference?: boolean
    warehouseId?: boolean
    partner?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Delivery$createdByArgs<ExtArgs>
    lines?: boolean | Delivery$linesArgs<ExtArgs>
    _count?: boolean | DeliveryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["delivery"]>

  export type DeliverySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deliveryNo?: boolean
    reference?: boolean
    warehouseId?: boolean
    partner?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Delivery$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["delivery"]>

  export type DeliverySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deliveryNo?: boolean
    reference?: boolean
    warehouseId?: boolean
    partner?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Delivery$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["delivery"]>

  export type DeliverySelectScalar = {
    id?: boolean
    deliveryNo?: boolean
    reference?: boolean
    warehouseId?: boolean
    partner?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeliveryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deliveryNo" | "reference" | "warehouseId" | "partner" | "status" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["delivery"]>
  export type DeliveryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Delivery$createdByArgs<ExtArgs>
    lines?: boolean | Delivery$linesArgs<ExtArgs>
    _count?: boolean | DeliveryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeliveryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Delivery$createdByArgs<ExtArgs>
  }
  export type DeliveryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Delivery$createdByArgs<ExtArgs>
  }

  export type $DeliveryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Delivery"
    objects: {
      warehouse: Prisma.$WarehousePayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      lines: Prisma.$DeliveryLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      deliveryNo: string
      reference: string | null
      warehouseId: number
      partner: string | null
      status: $Enums.DocumentStatus
      createdById: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["delivery"]>
    composites: {}
  }

  type DeliveryGetPayload<S extends boolean | null | undefined | DeliveryDefaultArgs> = $Result.GetResult<Prisma.$DeliveryPayload, S>

  type DeliveryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryCountAggregateInputType | true
    }

  export interface DeliveryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Delivery'], meta: { name: 'Delivery' } }
    /**
     * Find zero or one Delivery that matches the filter.
     * @param {DeliveryFindUniqueArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryFindUniqueArgs>(args: SelectSubset<T, DeliveryFindUniqueArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Delivery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryFindUniqueOrThrowArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Delivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindFirstArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryFindFirstArgs>(args?: SelectSubset<T, DeliveryFindFirstArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Delivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindFirstOrThrowArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Deliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deliveries
     * const deliveries = await prisma.delivery.findMany()
     * 
     * // Get first 10 Deliveries
     * const deliveries = await prisma.delivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryWithIdOnly = await prisma.delivery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryFindManyArgs>(args?: SelectSubset<T, DeliveryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Delivery.
     * @param {DeliveryCreateArgs} args - Arguments to create a Delivery.
     * @example
     * // Create one Delivery
     * const Delivery = await prisma.delivery.create({
     *   data: {
     *     // ... data to create a Delivery
     *   }
     * })
     * 
     */
    create<T extends DeliveryCreateArgs>(args: SelectSubset<T, DeliveryCreateArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Deliveries.
     * @param {DeliveryCreateManyArgs} args - Arguments to create many Deliveries.
     * @example
     * // Create many Deliveries
     * const delivery = await prisma.delivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryCreateManyArgs>(args?: SelectSubset<T, DeliveryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deliveries and returns the data saved in the database.
     * @param {DeliveryCreateManyAndReturnArgs} args - Arguments to create many Deliveries.
     * @example
     * // Create many Deliveries
     * const delivery = await prisma.delivery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deliveries and only return the `id`
     * const deliveryWithIdOnly = await prisma.delivery.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Delivery.
     * @param {DeliveryDeleteArgs} args - Arguments to delete one Delivery.
     * @example
     * // Delete one Delivery
     * const Delivery = await prisma.delivery.delete({
     *   where: {
     *     // ... filter to delete one Delivery
     *   }
     * })
     * 
     */
    delete<T extends DeliveryDeleteArgs>(args: SelectSubset<T, DeliveryDeleteArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Delivery.
     * @param {DeliveryUpdateArgs} args - Arguments to update one Delivery.
     * @example
     * // Update one Delivery
     * const delivery = await prisma.delivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryUpdateArgs>(args: SelectSubset<T, DeliveryUpdateArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Deliveries.
     * @param {DeliveryDeleteManyArgs} args - Arguments to filter Deliveries to delete.
     * @example
     * // Delete a few Deliveries
     * const { count } = await prisma.delivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryDeleteManyArgs>(args?: SelectSubset<T, DeliveryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deliveries
     * const delivery = await prisma.delivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryUpdateManyArgs>(args: SelectSubset<T, DeliveryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deliveries and returns the data updated in the database.
     * @param {DeliveryUpdateManyAndReturnArgs} args - Arguments to update many Deliveries.
     * @example
     * // Update many Deliveries
     * const delivery = await prisma.delivery.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Deliveries and only return the `id`
     * const deliveryWithIdOnly = await prisma.delivery.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Delivery.
     * @param {DeliveryUpsertArgs} args - Arguments to update or create a Delivery.
     * @example
     * // Update or create a Delivery
     * const delivery = await prisma.delivery.upsert({
     *   create: {
     *     // ... data to create a Delivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Delivery we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryUpsertArgs>(args: SelectSubset<T, DeliveryUpsertArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Deliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryCountArgs} args - Arguments to filter Deliveries to count.
     * @example
     * // Count the number of Deliveries
     * const count = await prisma.delivery.count({
     *   where: {
     *     // ... the filter for the Deliveries we want to count
     *   }
     * })
    **/
    count<T extends DeliveryCountArgs>(
      args?: Subset<T, DeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Delivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryAggregateArgs>(args: Subset<T, DeliveryAggregateArgs>): Prisma.PrismaPromise<GetDeliveryAggregateType<T>>

    /**
     * Group by Delivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Delivery model
   */
  readonly fields: DeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Delivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Delivery$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Delivery$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lines<T extends Delivery$linesArgs<ExtArgs> = {}>(args?: Subset<T, Delivery$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Delivery model
   */
  interface DeliveryFieldRefs {
    readonly id: FieldRef<"Delivery", 'Int'>
    readonly deliveryNo: FieldRef<"Delivery", 'String'>
    readonly reference: FieldRef<"Delivery", 'String'>
    readonly warehouseId: FieldRef<"Delivery", 'Int'>
    readonly partner: FieldRef<"Delivery", 'String'>
    readonly status: FieldRef<"Delivery", 'DocumentStatus'>
    readonly createdById: FieldRef<"Delivery", 'Int'>
    readonly createdAt: FieldRef<"Delivery", 'DateTime'>
    readonly updatedAt: FieldRef<"Delivery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Delivery findUnique
   */
  export type DeliveryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery findUniqueOrThrow
   */
  export type DeliveryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery findFirst
   */
  export type DeliveryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deliveries.
     */
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Delivery findFirstOrThrow
   */
  export type DeliveryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deliveries.
     */
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Delivery findMany
   */
  export type DeliveryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Deliveries to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Delivery create
   */
  export type DeliveryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * The data needed to create a Delivery.
     */
    data: XOR<DeliveryCreateInput, DeliveryUncheckedCreateInput>
  }

  /**
   * Delivery createMany
   */
  export type DeliveryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deliveries.
     */
    data: DeliveryCreateManyInput | DeliveryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Delivery createManyAndReturn
   */
  export type DeliveryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * The data used to create many Deliveries.
     */
    data: DeliveryCreateManyInput | DeliveryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Delivery update
   */
  export type DeliveryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * The data needed to update a Delivery.
     */
    data: XOR<DeliveryUpdateInput, DeliveryUncheckedUpdateInput>
    /**
     * Choose, which Delivery to update.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery updateMany
   */
  export type DeliveryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deliveries.
     */
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyInput>
    /**
     * Filter which Deliveries to update
     */
    where?: DeliveryWhereInput
    /**
     * Limit how many Deliveries to update.
     */
    limit?: number
  }

  /**
   * Delivery updateManyAndReturn
   */
  export type DeliveryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * The data used to update Deliveries.
     */
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyInput>
    /**
     * Filter which Deliveries to update
     */
    where?: DeliveryWhereInput
    /**
     * Limit how many Deliveries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Delivery upsert
   */
  export type DeliveryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * The filter to search for the Delivery to update in case it exists.
     */
    where: DeliveryWhereUniqueInput
    /**
     * In case the Delivery found by the `where` argument doesn't exist, create a new Delivery with this data.
     */
    create: XOR<DeliveryCreateInput, DeliveryUncheckedCreateInput>
    /**
     * In case the Delivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryUpdateInput, DeliveryUncheckedUpdateInput>
  }

  /**
   * Delivery delete
   */
  export type DeliveryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter which Delivery to delete.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery deleteMany
   */
  export type DeliveryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deliveries to delete
     */
    where?: DeliveryWhereInput
    /**
     * Limit how many Deliveries to delete.
     */
    limit?: number
  }

  /**
   * Delivery.createdBy
   */
  export type Delivery$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Delivery.lines
   */
  export type Delivery$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLine
     */
    select?: DeliveryLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLine
     */
    omit?: DeliveryLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLineInclude<ExtArgs> | null
    where?: DeliveryLineWhereInput
    orderBy?: DeliveryLineOrderByWithRelationInput | DeliveryLineOrderByWithRelationInput[]
    cursor?: DeliveryLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryLineScalarFieldEnum | DeliveryLineScalarFieldEnum[]
  }

  /**
   * Delivery without action
   */
  export type DeliveryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryLine
   */

  export type AggregateDeliveryLine = {
    _count: DeliveryLineCountAggregateOutputType | null
    _avg: DeliveryLineAvgAggregateOutputType | null
    _sum: DeliveryLineSumAggregateOutputType | null
    _min: DeliveryLineMinAggregateOutputType | null
    _max: DeliveryLineMaxAggregateOutputType | null
  }

  export type DeliveryLineAvgAggregateOutputType = {
    id: number | null
    deliveryId: number | null
    productId: number | null
    quantity: Decimal | null
    unitPrice: Decimal | null
  }

  export type DeliveryLineSumAggregateOutputType = {
    id: number | null
    deliveryId: number | null
    productId: number | null
    quantity: Decimal | null
    unitPrice: Decimal | null
  }

  export type DeliveryLineMinAggregateOutputType = {
    id: number | null
    deliveryId: number | null
    productId: number | null
    quantity: Decimal | null
    uom: string | null
    unitPrice: Decimal | null
  }

  export type DeliveryLineMaxAggregateOutputType = {
    id: number | null
    deliveryId: number | null
    productId: number | null
    quantity: Decimal | null
    uom: string | null
    unitPrice: Decimal | null
  }

  export type DeliveryLineCountAggregateOutputType = {
    id: number
    deliveryId: number
    productId: number
    quantity: number
    uom: number
    unitPrice: number
    _all: number
  }


  export type DeliveryLineAvgAggregateInputType = {
    id?: true
    deliveryId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
  }

  export type DeliveryLineSumAggregateInputType = {
    id?: true
    deliveryId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
  }

  export type DeliveryLineMinAggregateInputType = {
    id?: true
    deliveryId?: true
    productId?: true
    quantity?: true
    uom?: true
    unitPrice?: true
  }

  export type DeliveryLineMaxAggregateInputType = {
    id?: true
    deliveryId?: true
    productId?: true
    quantity?: true
    uom?: true
    unitPrice?: true
  }

  export type DeliveryLineCountAggregateInputType = {
    id?: true
    deliveryId?: true
    productId?: true
    quantity?: true
    uom?: true
    unitPrice?: true
    _all?: true
  }

  export type DeliveryLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryLine to aggregate.
     */
    where?: DeliveryLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryLines to fetch.
     */
    orderBy?: DeliveryLineOrderByWithRelationInput | DeliveryLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryLines
    **/
    _count?: true | DeliveryLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryLineMaxAggregateInputType
  }

  export type GetDeliveryLineAggregateType<T extends DeliveryLineAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryLine[P]>
      : GetScalarType<T[P], AggregateDeliveryLine[P]>
  }




  export type DeliveryLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryLineWhereInput
    orderBy?: DeliveryLineOrderByWithAggregationInput | DeliveryLineOrderByWithAggregationInput[]
    by: DeliveryLineScalarFieldEnum[] | DeliveryLineScalarFieldEnum
    having?: DeliveryLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryLineCountAggregateInputType | true
    _avg?: DeliveryLineAvgAggregateInputType
    _sum?: DeliveryLineSumAggregateInputType
    _min?: DeliveryLineMinAggregateInputType
    _max?: DeliveryLineMaxAggregateInputType
  }

  export type DeliveryLineGroupByOutputType = {
    id: number
    deliveryId: number
    productId: number
    quantity: Decimal
    uom: string
    unitPrice: Decimal | null
    _count: DeliveryLineCountAggregateOutputType | null
    _avg: DeliveryLineAvgAggregateOutputType | null
    _sum: DeliveryLineSumAggregateOutputType | null
    _min: DeliveryLineMinAggregateOutputType | null
    _max: DeliveryLineMaxAggregateOutputType | null
  }

  type GetDeliveryLineGroupByPayload<T extends DeliveryLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryLineGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryLineGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deliveryId?: boolean
    productId?: boolean
    quantity?: boolean
    uom?: boolean
    unitPrice?: boolean
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryLine"]>

  export type DeliveryLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deliveryId?: boolean
    productId?: boolean
    quantity?: boolean
    uom?: boolean
    unitPrice?: boolean
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryLine"]>

  export type DeliveryLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deliveryId?: boolean
    productId?: boolean
    quantity?: boolean
    uom?: boolean
    unitPrice?: boolean
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryLine"]>

  export type DeliveryLineSelectScalar = {
    id?: boolean
    deliveryId?: boolean
    productId?: boolean
    quantity?: boolean
    uom?: boolean
    unitPrice?: boolean
  }

  export type DeliveryLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deliveryId" | "productId" | "quantity" | "uom" | "unitPrice", ExtArgs["result"]["deliveryLine"]>
  export type DeliveryLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type DeliveryLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type DeliveryLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $DeliveryLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryLine"
    objects: {
      delivery: Prisma.$DeliveryPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      deliveryId: number
      productId: number
      quantity: Prisma.Decimal
      uom: string
      unitPrice: Prisma.Decimal | null
    }, ExtArgs["result"]["deliveryLine"]>
    composites: {}
  }

  type DeliveryLineGetPayload<S extends boolean | null | undefined | DeliveryLineDefaultArgs> = $Result.GetResult<Prisma.$DeliveryLinePayload, S>

  type DeliveryLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryLineCountAggregateInputType | true
    }

  export interface DeliveryLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryLine'], meta: { name: 'DeliveryLine' } }
    /**
     * Find zero or one DeliveryLine that matches the filter.
     * @param {DeliveryLineFindUniqueArgs} args - Arguments to find a DeliveryLine
     * @example
     * // Get one DeliveryLine
     * const deliveryLine = await prisma.deliveryLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryLineFindUniqueArgs>(args: SelectSubset<T, DeliveryLineFindUniqueArgs<ExtArgs>>): Prisma__DeliveryLineClient<$Result.GetResult<Prisma.$DeliveryLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryLineFindUniqueOrThrowArgs} args - Arguments to find a DeliveryLine
     * @example
     * // Get one DeliveryLine
     * const deliveryLine = await prisma.deliveryLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryLineFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryLineClient<$Result.GetResult<Prisma.$DeliveryLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLineFindFirstArgs} args - Arguments to find a DeliveryLine
     * @example
     * // Get one DeliveryLine
     * const deliveryLine = await prisma.deliveryLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryLineFindFirstArgs>(args?: SelectSubset<T, DeliveryLineFindFirstArgs<ExtArgs>>): Prisma__DeliveryLineClient<$Result.GetResult<Prisma.$DeliveryLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLineFindFirstOrThrowArgs} args - Arguments to find a DeliveryLine
     * @example
     * // Get one DeliveryLine
     * const deliveryLine = await prisma.deliveryLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryLineFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryLineClient<$Result.GetResult<Prisma.$DeliveryLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryLines
     * const deliveryLines = await prisma.deliveryLine.findMany()
     * 
     * // Get first 10 DeliveryLines
     * const deliveryLines = await prisma.deliveryLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryLineWithIdOnly = await prisma.deliveryLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryLineFindManyArgs>(args?: SelectSubset<T, DeliveryLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryLine.
     * @param {DeliveryLineCreateArgs} args - Arguments to create a DeliveryLine.
     * @example
     * // Create one DeliveryLine
     * const DeliveryLine = await prisma.deliveryLine.create({
     *   data: {
     *     // ... data to create a DeliveryLine
     *   }
     * })
     * 
     */
    create<T extends DeliveryLineCreateArgs>(args: SelectSubset<T, DeliveryLineCreateArgs<ExtArgs>>): Prisma__DeliveryLineClient<$Result.GetResult<Prisma.$DeliveryLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryLines.
     * @param {DeliveryLineCreateManyArgs} args - Arguments to create many DeliveryLines.
     * @example
     * // Create many DeliveryLines
     * const deliveryLine = await prisma.deliveryLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryLineCreateManyArgs>(args?: SelectSubset<T, DeliveryLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryLines and returns the data saved in the database.
     * @param {DeliveryLineCreateManyAndReturnArgs} args - Arguments to create many DeliveryLines.
     * @example
     * // Create many DeliveryLines
     * const deliveryLine = await prisma.deliveryLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryLines and only return the `id`
     * const deliveryLineWithIdOnly = await prisma.deliveryLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryLineCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryLine.
     * @param {DeliveryLineDeleteArgs} args - Arguments to delete one DeliveryLine.
     * @example
     * // Delete one DeliveryLine
     * const DeliveryLine = await prisma.deliveryLine.delete({
     *   where: {
     *     // ... filter to delete one DeliveryLine
     *   }
     * })
     * 
     */
    delete<T extends DeliveryLineDeleteArgs>(args: SelectSubset<T, DeliveryLineDeleteArgs<ExtArgs>>): Prisma__DeliveryLineClient<$Result.GetResult<Prisma.$DeliveryLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryLine.
     * @param {DeliveryLineUpdateArgs} args - Arguments to update one DeliveryLine.
     * @example
     * // Update one DeliveryLine
     * const deliveryLine = await prisma.deliveryLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryLineUpdateArgs>(args: SelectSubset<T, DeliveryLineUpdateArgs<ExtArgs>>): Prisma__DeliveryLineClient<$Result.GetResult<Prisma.$DeliveryLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryLines.
     * @param {DeliveryLineDeleteManyArgs} args - Arguments to filter DeliveryLines to delete.
     * @example
     * // Delete a few DeliveryLines
     * const { count } = await prisma.deliveryLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryLineDeleteManyArgs>(args?: SelectSubset<T, DeliveryLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryLines
     * const deliveryLine = await prisma.deliveryLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryLineUpdateManyArgs>(args: SelectSubset<T, DeliveryLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryLines and returns the data updated in the database.
     * @param {DeliveryLineUpdateManyAndReturnArgs} args - Arguments to update many DeliveryLines.
     * @example
     * // Update many DeliveryLines
     * const deliveryLine = await prisma.deliveryLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryLines and only return the `id`
     * const deliveryLineWithIdOnly = await prisma.deliveryLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryLineUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryLine.
     * @param {DeliveryLineUpsertArgs} args - Arguments to update or create a DeliveryLine.
     * @example
     * // Update or create a DeliveryLine
     * const deliveryLine = await prisma.deliveryLine.upsert({
     *   create: {
     *     // ... data to create a DeliveryLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryLine we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryLineUpsertArgs>(args: SelectSubset<T, DeliveryLineUpsertArgs<ExtArgs>>): Prisma__DeliveryLineClient<$Result.GetResult<Prisma.$DeliveryLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLineCountArgs} args - Arguments to filter DeliveryLines to count.
     * @example
     * // Count the number of DeliveryLines
     * const count = await prisma.deliveryLine.count({
     *   where: {
     *     // ... the filter for the DeliveryLines we want to count
     *   }
     * })
    **/
    count<T extends DeliveryLineCountArgs>(
      args?: Subset<T, DeliveryLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryLineAggregateArgs>(args: Subset<T, DeliveryLineAggregateArgs>): Prisma.PrismaPromise<GetDeliveryLineAggregateType<T>>

    /**
     * Group by DeliveryLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryLineGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryLine model
   */
  readonly fields: DeliveryLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    delivery<T extends DeliveryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryDefaultArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryLine model
   */
  interface DeliveryLineFieldRefs {
    readonly id: FieldRef<"DeliveryLine", 'Int'>
    readonly deliveryId: FieldRef<"DeliveryLine", 'Int'>
    readonly productId: FieldRef<"DeliveryLine", 'Int'>
    readonly quantity: FieldRef<"DeliveryLine", 'Decimal'>
    readonly uom: FieldRef<"DeliveryLine", 'String'>
    readonly unitPrice: FieldRef<"DeliveryLine", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryLine findUnique
   */
  export type DeliveryLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLine
     */
    select?: DeliveryLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLine
     */
    omit?: DeliveryLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLineInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryLine to fetch.
     */
    where: DeliveryLineWhereUniqueInput
  }

  /**
   * DeliveryLine findUniqueOrThrow
   */
  export type DeliveryLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLine
     */
    select?: DeliveryLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLine
     */
    omit?: DeliveryLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLineInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryLine to fetch.
     */
    where: DeliveryLineWhereUniqueInput
  }

  /**
   * DeliveryLine findFirst
   */
  export type DeliveryLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLine
     */
    select?: DeliveryLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLine
     */
    omit?: DeliveryLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLineInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryLine to fetch.
     */
    where?: DeliveryLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryLines to fetch.
     */
    orderBy?: DeliveryLineOrderByWithRelationInput | DeliveryLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryLines.
     */
    cursor?: DeliveryLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryLines.
     */
    distinct?: DeliveryLineScalarFieldEnum | DeliveryLineScalarFieldEnum[]
  }

  /**
   * DeliveryLine findFirstOrThrow
   */
  export type DeliveryLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLine
     */
    select?: DeliveryLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLine
     */
    omit?: DeliveryLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLineInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryLine to fetch.
     */
    where?: DeliveryLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryLines to fetch.
     */
    orderBy?: DeliveryLineOrderByWithRelationInput | DeliveryLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryLines.
     */
    cursor?: DeliveryLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryLines.
     */
    distinct?: DeliveryLineScalarFieldEnum | DeliveryLineScalarFieldEnum[]
  }

  /**
   * DeliveryLine findMany
   */
  export type DeliveryLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLine
     */
    select?: DeliveryLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLine
     */
    omit?: DeliveryLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLineInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryLines to fetch.
     */
    where?: DeliveryLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryLines to fetch.
     */
    orderBy?: DeliveryLineOrderByWithRelationInput | DeliveryLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryLines.
     */
    cursor?: DeliveryLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryLines.
     */
    skip?: number
    distinct?: DeliveryLineScalarFieldEnum | DeliveryLineScalarFieldEnum[]
  }

  /**
   * DeliveryLine create
   */
  export type DeliveryLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLine
     */
    select?: DeliveryLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLine
     */
    omit?: DeliveryLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLineInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryLine.
     */
    data: XOR<DeliveryLineCreateInput, DeliveryLineUncheckedCreateInput>
  }

  /**
   * DeliveryLine createMany
   */
  export type DeliveryLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryLines.
     */
    data: DeliveryLineCreateManyInput | DeliveryLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryLine createManyAndReturn
   */
  export type DeliveryLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLine
     */
    select?: DeliveryLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLine
     */
    omit?: DeliveryLineOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryLines.
     */
    data: DeliveryLineCreateManyInput | DeliveryLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryLine update
   */
  export type DeliveryLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLine
     */
    select?: DeliveryLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLine
     */
    omit?: DeliveryLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLineInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryLine.
     */
    data: XOR<DeliveryLineUpdateInput, DeliveryLineUncheckedUpdateInput>
    /**
     * Choose, which DeliveryLine to update.
     */
    where: DeliveryLineWhereUniqueInput
  }

  /**
   * DeliveryLine updateMany
   */
  export type DeliveryLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryLines.
     */
    data: XOR<DeliveryLineUpdateManyMutationInput, DeliveryLineUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryLines to update
     */
    where?: DeliveryLineWhereInput
    /**
     * Limit how many DeliveryLines to update.
     */
    limit?: number
  }

  /**
   * DeliveryLine updateManyAndReturn
   */
  export type DeliveryLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLine
     */
    select?: DeliveryLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLine
     */
    omit?: DeliveryLineOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryLines.
     */
    data: XOR<DeliveryLineUpdateManyMutationInput, DeliveryLineUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryLines to update
     */
    where?: DeliveryLineWhereInput
    /**
     * Limit how many DeliveryLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryLine upsert
   */
  export type DeliveryLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLine
     */
    select?: DeliveryLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLine
     */
    omit?: DeliveryLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLineInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryLine to update in case it exists.
     */
    where: DeliveryLineWhereUniqueInput
    /**
     * In case the DeliveryLine found by the `where` argument doesn't exist, create a new DeliveryLine with this data.
     */
    create: XOR<DeliveryLineCreateInput, DeliveryLineUncheckedCreateInput>
    /**
     * In case the DeliveryLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryLineUpdateInput, DeliveryLineUncheckedUpdateInput>
  }

  /**
   * DeliveryLine delete
   */
  export type DeliveryLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLine
     */
    select?: DeliveryLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLine
     */
    omit?: DeliveryLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLineInclude<ExtArgs> | null
    /**
     * Filter which DeliveryLine to delete.
     */
    where: DeliveryLineWhereUniqueInput
  }

  /**
   * DeliveryLine deleteMany
   */
  export type DeliveryLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryLines to delete
     */
    where?: DeliveryLineWhereInput
    /**
     * Limit how many DeliveryLines to delete.
     */
    limit?: number
  }

  /**
   * DeliveryLine without action
   */
  export type DeliveryLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLine
     */
    select?: DeliveryLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLine
     */
    omit?: DeliveryLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLineInclude<ExtArgs> | null
  }


  /**
   * Model Transfer
   */

  export type AggregateTransfer = {
    _count: TransferCountAggregateOutputType | null
    _avg: TransferAvgAggregateOutputType | null
    _sum: TransferSumAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  export type TransferAvgAggregateOutputType = {
    id: number | null
    fromWarehouseId: number | null
    toWarehouseId: number | null
    createdById: number | null
  }

  export type TransferSumAggregateOutputType = {
    id: number | null
    fromWarehouseId: number | null
    toWarehouseId: number | null
    createdById: number | null
  }

  export type TransferMinAggregateOutputType = {
    id: number | null
    transferNo: string | null
    reference: string | null
    fromWarehouseId: number | null
    toWarehouseId: number | null
    status: $Enums.DocumentStatus | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferMaxAggregateOutputType = {
    id: number | null
    transferNo: string | null
    reference: string | null
    fromWarehouseId: number | null
    toWarehouseId: number | null
    status: $Enums.DocumentStatus | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferCountAggregateOutputType = {
    id: number
    transferNo: number
    reference: number
    fromWarehouseId: number
    toWarehouseId: number
    status: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransferAvgAggregateInputType = {
    id?: true
    fromWarehouseId?: true
    toWarehouseId?: true
    createdById?: true
  }

  export type TransferSumAggregateInputType = {
    id?: true
    fromWarehouseId?: true
    toWarehouseId?: true
    createdById?: true
  }

  export type TransferMinAggregateInputType = {
    id?: true
    transferNo?: true
    reference?: true
    fromWarehouseId?: true
    toWarehouseId?: true
    status?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferMaxAggregateInputType = {
    id?: true
    transferNo?: true
    reference?: true
    fromWarehouseId?: true
    toWarehouseId?: true
    status?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferCountAggregateInputType = {
    id?: true
    transferNo?: true
    reference?: true
    fromWarehouseId?: true
    toWarehouseId?: true
    status?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfer to aggregate.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transfers
    **/
    _count?: true | TransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferMaxAggregateInputType
  }

  export type GetTransferAggregateType<T extends TransferAggregateArgs> = {
        [P in keyof T & keyof AggregateTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransfer[P]>
      : GetScalarType<T[P], AggregateTransfer[P]>
  }




  export type TransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithAggregationInput | TransferOrderByWithAggregationInput[]
    by: TransferScalarFieldEnum[] | TransferScalarFieldEnum
    having?: TransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferCountAggregateInputType | true
    _avg?: TransferAvgAggregateInputType
    _sum?: TransferSumAggregateInputType
    _min?: TransferMinAggregateInputType
    _max?: TransferMaxAggregateInputType
  }

  export type TransferGroupByOutputType = {
    id: number
    transferNo: string
    reference: string | null
    fromWarehouseId: number
    toWarehouseId: number
    status: $Enums.DocumentStatus
    createdById: number | null
    createdAt: Date
    updatedAt: Date
    _count: TransferCountAggregateOutputType | null
    _avg: TransferAvgAggregateOutputType | null
    _sum: TransferSumAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  type GetTransferGroupByPayload<T extends TransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferGroupByOutputType[P]>
            : GetScalarType<T[P], TransferGroupByOutputType[P]>
        }
      >
    >


  export type TransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferNo?: boolean
    reference?: boolean
    fromWarehouseId?: boolean
    toWarehouseId?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fromWarehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    toWarehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Transfer$createdByArgs<ExtArgs>
    lines?: boolean | Transfer$linesArgs<ExtArgs>
    _count?: boolean | TransferCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferNo?: boolean
    reference?: boolean
    fromWarehouseId?: boolean
    toWarehouseId?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fromWarehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    toWarehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Transfer$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferNo?: boolean
    reference?: boolean
    fromWarehouseId?: boolean
    toWarehouseId?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fromWarehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    toWarehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Transfer$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectScalar = {
    id?: boolean
    transferNo?: boolean
    reference?: boolean
    fromWarehouseId?: boolean
    toWarehouseId?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transferNo" | "reference" | "fromWarehouseId" | "toWarehouseId" | "status" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["transfer"]>
  export type TransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromWarehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    toWarehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Transfer$createdByArgs<ExtArgs>
    lines?: boolean | Transfer$linesArgs<ExtArgs>
    _count?: boolean | TransferCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromWarehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    toWarehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Transfer$createdByArgs<ExtArgs>
  }
  export type TransferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromWarehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    toWarehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Transfer$createdByArgs<ExtArgs>
  }

  export type $TransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transfer"
    objects: {
      fromWarehouse: Prisma.$WarehousePayload<ExtArgs>
      toWarehouse: Prisma.$WarehousePayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      lines: Prisma.$TransferLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transferNo: string
      reference: string | null
      fromWarehouseId: number
      toWarehouseId: number
      status: $Enums.DocumentStatus
      createdById: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transfer"]>
    composites: {}
  }

  type TransferGetPayload<S extends boolean | null | undefined | TransferDefaultArgs> = $Result.GetResult<Prisma.$TransferPayload, S>

  type TransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransferCountAggregateInputType | true
    }

  export interface TransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transfer'], meta: { name: 'Transfer' } }
    /**
     * Find zero or one Transfer that matches the filter.
     * @param {TransferFindUniqueArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransferFindUniqueArgs>(args: SelectSubset<T, TransferFindUniqueArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransferFindUniqueOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransferFindUniqueOrThrowArgs>(args: SelectSubset<T, TransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransferFindFirstArgs>(args?: SelectSubset<T, TransferFindFirstArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransferFindFirstOrThrowArgs>(args?: SelectSubset<T, TransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transfers
     * const transfers = await prisma.transfer.findMany()
     * 
     * // Get first 10 Transfers
     * const transfers = await prisma.transfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferWithIdOnly = await prisma.transfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransferFindManyArgs>(args?: SelectSubset<T, TransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transfer.
     * @param {TransferCreateArgs} args - Arguments to create a Transfer.
     * @example
     * // Create one Transfer
     * const Transfer = await prisma.transfer.create({
     *   data: {
     *     // ... data to create a Transfer
     *   }
     * })
     * 
     */
    create<T extends TransferCreateArgs>(args: SelectSubset<T, TransferCreateArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transfers.
     * @param {TransferCreateManyArgs} args - Arguments to create many Transfers.
     * @example
     * // Create many Transfers
     * const transfer = await prisma.transfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransferCreateManyArgs>(args?: SelectSubset<T, TransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transfers and returns the data saved in the database.
     * @param {TransferCreateManyAndReturnArgs} args - Arguments to create many Transfers.
     * @example
     * // Create many Transfers
     * const transfer = await prisma.transfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transfers and only return the `id`
     * const transferWithIdOnly = await prisma.transfer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransferCreateManyAndReturnArgs>(args?: SelectSubset<T, TransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transfer.
     * @param {TransferDeleteArgs} args - Arguments to delete one Transfer.
     * @example
     * // Delete one Transfer
     * const Transfer = await prisma.transfer.delete({
     *   where: {
     *     // ... filter to delete one Transfer
     *   }
     * })
     * 
     */
    delete<T extends TransferDeleteArgs>(args: SelectSubset<T, TransferDeleteArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transfer.
     * @param {TransferUpdateArgs} args - Arguments to update one Transfer.
     * @example
     * // Update one Transfer
     * const transfer = await prisma.transfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransferUpdateArgs>(args: SelectSubset<T, TransferUpdateArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transfers.
     * @param {TransferDeleteManyArgs} args - Arguments to filter Transfers to delete.
     * @example
     * // Delete a few Transfers
     * const { count } = await prisma.transfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransferDeleteManyArgs>(args?: SelectSubset<T, TransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transfers
     * const transfer = await prisma.transfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransferUpdateManyArgs>(args: SelectSubset<T, TransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transfers and returns the data updated in the database.
     * @param {TransferUpdateManyAndReturnArgs} args - Arguments to update many Transfers.
     * @example
     * // Update many Transfers
     * const transfer = await prisma.transfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transfers and only return the `id`
     * const transferWithIdOnly = await prisma.transfer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransferUpdateManyAndReturnArgs>(args: SelectSubset<T, TransferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transfer.
     * @param {TransferUpsertArgs} args - Arguments to update or create a Transfer.
     * @example
     * // Update or create a Transfer
     * const transfer = await prisma.transfer.upsert({
     *   create: {
     *     // ... data to create a Transfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transfer we want to update
     *   }
     * })
     */
    upsert<T extends TransferUpsertArgs>(args: SelectSubset<T, TransferUpsertArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferCountArgs} args - Arguments to filter Transfers to count.
     * @example
     * // Count the number of Transfers
     * const count = await prisma.transfer.count({
     *   where: {
     *     // ... the filter for the Transfers we want to count
     *   }
     * })
    **/
    count<T extends TransferCountArgs>(
      args?: Subset<T, TransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferAggregateArgs>(args: Subset<T, TransferAggregateArgs>): Prisma.PrismaPromise<GetTransferAggregateType<T>>

    /**
     * Group by Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferGroupByArgs['orderBy'] }
        : { orderBy?: TransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transfer model
   */
  readonly fields: TransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fromWarehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    toWarehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Transfer$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lines<T extends Transfer$linesArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transfer model
   */
  interface TransferFieldRefs {
    readonly id: FieldRef<"Transfer", 'Int'>
    readonly transferNo: FieldRef<"Transfer", 'String'>
    readonly reference: FieldRef<"Transfer", 'String'>
    readonly fromWarehouseId: FieldRef<"Transfer", 'Int'>
    readonly toWarehouseId: FieldRef<"Transfer", 'Int'>
    readonly status: FieldRef<"Transfer", 'DocumentStatus'>
    readonly createdById: FieldRef<"Transfer", 'Int'>
    readonly createdAt: FieldRef<"Transfer", 'DateTime'>
    readonly updatedAt: FieldRef<"Transfer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transfer findUnique
   */
  export type TransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer findUniqueOrThrow
   */
  export type TransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer findFirst
   */
  export type TransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer findFirstOrThrow
   */
  export type TransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer findMany
   */
  export type TransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfers to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer create
   */
  export type TransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to create a Transfer.
     */
    data: XOR<TransferCreateInput, TransferUncheckedCreateInput>
  }

  /**
   * Transfer createMany
   */
  export type TransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transfers.
     */
    data: TransferCreateManyInput | TransferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transfer createManyAndReturn
   */
  export type TransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * The data used to create many Transfers.
     */
    data: TransferCreateManyInput | TransferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transfer update
   */
  export type TransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to update a Transfer.
     */
    data: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
    /**
     * Choose, which Transfer to update.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer updateMany
   */
  export type TransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transfers.
     */
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyInput>
    /**
     * Filter which Transfers to update
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to update.
     */
    limit?: number
  }

  /**
   * Transfer updateManyAndReturn
   */
  export type TransferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * The data used to update Transfers.
     */
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyInput>
    /**
     * Filter which Transfers to update
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transfer upsert
   */
  export type TransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The filter to search for the Transfer to update in case it exists.
     */
    where: TransferWhereUniqueInput
    /**
     * In case the Transfer found by the `where` argument doesn't exist, create a new Transfer with this data.
     */
    create: XOR<TransferCreateInput, TransferUncheckedCreateInput>
    /**
     * In case the Transfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
  }

  /**
   * Transfer delete
   */
  export type TransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter which Transfer to delete.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer deleteMany
   */
  export type TransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfers to delete
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to delete.
     */
    limit?: number
  }

  /**
   * Transfer.createdBy
   */
  export type Transfer$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Transfer.lines
   */
  export type Transfer$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
    where?: TransferLineWhereInput
    orderBy?: TransferLineOrderByWithRelationInput | TransferLineOrderByWithRelationInput[]
    cursor?: TransferLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferLineScalarFieldEnum | TransferLineScalarFieldEnum[]
  }

  /**
   * Transfer without action
   */
  export type TransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
  }


  /**
   * Model TransferLine
   */

  export type AggregateTransferLine = {
    _count: TransferLineCountAggregateOutputType | null
    _avg: TransferLineAvgAggregateOutputType | null
    _sum: TransferLineSumAggregateOutputType | null
    _min: TransferLineMinAggregateOutputType | null
    _max: TransferLineMaxAggregateOutputType | null
  }

  export type TransferLineAvgAggregateOutputType = {
    id: number | null
    transferId: number | null
    productId: number | null
    quantity: Decimal | null
  }

  export type TransferLineSumAggregateOutputType = {
    id: number | null
    transferId: number | null
    productId: number | null
    quantity: Decimal | null
  }

  export type TransferLineMinAggregateOutputType = {
    id: number | null
    transferId: number | null
    productId: number | null
    quantity: Decimal | null
    uom: string | null
  }

  export type TransferLineMaxAggregateOutputType = {
    id: number | null
    transferId: number | null
    productId: number | null
    quantity: Decimal | null
    uom: string | null
  }

  export type TransferLineCountAggregateOutputType = {
    id: number
    transferId: number
    productId: number
    quantity: number
    uom: number
    _all: number
  }


  export type TransferLineAvgAggregateInputType = {
    id?: true
    transferId?: true
    productId?: true
    quantity?: true
  }

  export type TransferLineSumAggregateInputType = {
    id?: true
    transferId?: true
    productId?: true
    quantity?: true
  }

  export type TransferLineMinAggregateInputType = {
    id?: true
    transferId?: true
    productId?: true
    quantity?: true
    uom?: true
  }

  export type TransferLineMaxAggregateInputType = {
    id?: true
    transferId?: true
    productId?: true
    quantity?: true
    uom?: true
  }

  export type TransferLineCountAggregateInputType = {
    id?: true
    transferId?: true
    productId?: true
    quantity?: true
    uom?: true
    _all?: true
  }

  export type TransferLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferLine to aggregate.
     */
    where?: TransferLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferLines to fetch.
     */
    orderBy?: TransferLineOrderByWithRelationInput | TransferLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransferLines
    **/
    _count?: true | TransferLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransferLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransferLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferLineMaxAggregateInputType
  }

  export type GetTransferLineAggregateType<T extends TransferLineAggregateArgs> = {
        [P in keyof T & keyof AggregateTransferLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransferLine[P]>
      : GetScalarType<T[P], AggregateTransferLine[P]>
  }




  export type TransferLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferLineWhereInput
    orderBy?: TransferLineOrderByWithAggregationInput | TransferLineOrderByWithAggregationInput[]
    by: TransferLineScalarFieldEnum[] | TransferLineScalarFieldEnum
    having?: TransferLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferLineCountAggregateInputType | true
    _avg?: TransferLineAvgAggregateInputType
    _sum?: TransferLineSumAggregateInputType
    _min?: TransferLineMinAggregateInputType
    _max?: TransferLineMaxAggregateInputType
  }

  export type TransferLineGroupByOutputType = {
    id: number
    transferId: number
    productId: number
    quantity: Decimal
    uom: string
    _count: TransferLineCountAggregateOutputType | null
    _avg: TransferLineAvgAggregateOutputType | null
    _sum: TransferLineSumAggregateOutputType | null
    _min: TransferLineMinAggregateOutputType | null
    _max: TransferLineMaxAggregateOutputType | null
  }

  type GetTransferLineGroupByPayload<T extends TransferLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferLineGroupByOutputType[P]>
            : GetScalarType<T[P], TransferLineGroupByOutputType[P]>
        }
      >
    >


  export type TransferLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferId?: boolean
    productId?: boolean
    quantity?: boolean
    uom?: boolean
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferLine"]>

  export type TransferLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferId?: boolean
    productId?: boolean
    quantity?: boolean
    uom?: boolean
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferLine"]>

  export type TransferLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferId?: boolean
    productId?: boolean
    quantity?: boolean
    uom?: boolean
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferLine"]>

  export type TransferLineSelectScalar = {
    id?: boolean
    transferId?: boolean
    productId?: boolean
    quantity?: boolean
    uom?: boolean
  }

  export type TransferLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transferId" | "productId" | "quantity" | "uom", ExtArgs["result"]["transferLine"]>
  export type TransferLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type TransferLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type TransferLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $TransferLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransferLine"
    objects: {
      transfer: Prisma.$TransferPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transferId: number
      productId: number
      quantity: Prisma.Decimal
      uom: string
    }, ExtArgs["result"]["transferLine"]>
    composites: {}
  }

  type TransferLineGetPayload<S extends boolean | null | undefined | TransferLineDefaultArgs> = $Result.GetResult<Prisma.$TransferLinePayload, S>

  type TransferLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransferLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransferLineCountAggregateInputType | true
    }

  export interface TransferLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransferLine'], meta: { name: 'TransferLine' } }
    /**
     * Find zero or one TransferLine that matches the filter.
     * @param {TransferLineFindUniqueArgs} args - Arguments to find a TransferLine
     * @example
     * // Get one TransferLine
     * const transferLine = await prisma.transferLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransferLineFindUniqueArgs>(args: SelectSubset<T, TransferLineFindUniqueArgs<ExtArgs>>): Prisma__TransferLineClient<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransferLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransferLineFindUniqueOrThrowArgs} args - Arguments to find a TransferLine
     * @example
     * // Get one TransferLine
     * const transferLine = await prisma.transferLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransferLineFindUniqueOrThrowArgs>(args: SelectSubset<T, TransferLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransferLineClient<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransferLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferLineFindFirstArgs} args - Arguments to find a TransferLine
     * @example
     * // Get one TransferLine
     * const transferLine = await prisma.transferLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransferLineFindFirstArgs>(args?: SelectSubset<T, TransferLineFindFirstArgs<ExtArgs>>): Prisma__TransferLineClient<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransferLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferLineFindFirstOrThrowArgs} args - Arguments to find a TransferLine
     * @example
     * // Get one TransferLine
     * const transferLine = await prisma.transferLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransferLineFindFirstOrThrowArgs>(args?: SelectSubset<T, TransferLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransferLineClient<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransferLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransferLines
     * const transferLines = await prisma.transferLine.findMany()
     * 
     * // Get first 10 TransferLines
     * const transferLines = await prisma.transferLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferLineWithIdOnly = await prisma.transferLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransferLineFindManyArgs>(args?: SelectSubset<T, TransferLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransferLine.
     * @param {TransferLineCreateArgs} args - Arguments to create a TransferLine.
     * @example
     * // Create one TransferLine
     * const TransferLine = await prisma.transferLine.create({
     *   data: {
     *     // ... data to create a TransferLine
     *   }
     * })
     * 
     */
    create<T extends TransferLineCreateArgs>(args: SelectSubset<T, TransferLineCreateArgs<ExtArgs>>): Prisma__TransferLineClient<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransferLines.
     * @param {TransferLineCreateManyArgs} args - Arguments to create many TransferLines.
     * @example
     * // Create many TransferLines
     * const transferLine = await prisma.transferLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransferLineCreateManyArgs>(args?: SelectSubset<T, TransferLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransferLines and returns the data saved in the database.
     * @param {TransferLineCreateManyAndReturnArgs} args - Arguments to create many TransferLines.
     * @example
     * // Create many TransferLines
     * const transferLine = await prisma.transferLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransferLines and only return the `id`
     * const transferLineWithIdOnly = await prisma.transferLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransferLineCreateManyAndReturnArgs>(args?: SelectSubset<T, TransferLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransferLine.
     * @param {TransferLineDeleteArgs} args - Arguments to delete one TransferLine.
     * @example
     * // Delete one TransferLine
     * const TransferLine = await prisma.transferLine.delete({
     *   where: {
     *     // ... filter to delete one TransferLine
     *   }
     * })
     * 
     */
    delete<T extends TransferLineDeleteArgs>(args: SelectSubset<T, TransferLineDeleteArgs<ExtArgs>>): Prisma__TransferLineClient<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransferLine.
     * @param {TransferLineUpdateArgs} args - Arguments to update one TransferLine.
     * @example
     * // Update one TransferLine
     * const transferLine = await prisma.transferLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransferLineUpdateArgs>(args: SelectSubset<T, TransferLineUpdateArgs<ExtArgs>>): Prisma__TransferLineClient<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransferLines.
     * @param {TransferLineDeleteManyArgs} args - Arguments to filter TransferLines to delete.
     * @example
     * // Delete a few TransferLines
     * const { count } = await prisma.transferLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransferLineDeleteManyArgs>(args?: SelectSubset<T, TransferLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransferLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransferLines
     * const transferLine = await prisma.transferLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransferLineUpdateManyArgs>(args: SelectSubset<T, TransferLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransferLines and returns the data updated in the database.
     * @param {TransferLineUpdateManyAndReturnArgs} args - Arguments to update many TransferLines.
     * @example
     * // Update many TransferLines
     * const transferLine = await prisma.transferLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransferLines and only return the `id`
     * const transferLineWithIdOnly = await prisma.transferLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransferLineUpdateManyAndReturnArgs>(args: SelectSubset<T, TransferLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransferLine.
     * @param {TransferLineUpsertArgs} args - Arguments to update or create a TransferLine.
     * @example
     * // Update or create a TransferLine
     * const transferLine = await prisma.transferLine.upsert({
     *   create: {
     *     // ... data to create a TransferLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransferLine we want to update
     *   }
     * })
     */
    upsert<T extends TransferLineUpsertArgs>(args: SelectSubset<T, TransferLineUpsertArgs<ExtArgs>>): Prisma__TransferLineClient<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransferLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferLineCountArgs} args - Arguments to filter TransferLines to count.
     * @example
     * // Count the number of TransferLines
     * const count = await prisma.transferLine.count({
     *   where: {
     *     // ... the filter for the TransferLines we want to count
     *   }
     * })
    **/
    count<T extends TransferLineCountArgs>(
      args?: Subset<T, TransferLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransferLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferLineAggregateArgs>(args: Subset<T, TransferLineAggregateArgs>): Prisma.PrismaPromise<GetTransferLineAggregateType<T>>

    /**
     * Group by TransferLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferLineGroupByArgs['orderBy'] }
        : { orderBy?: TransferLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransferLine model
   */
  readonly fields: TransferLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransferLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transfer<T extends TransferDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransferDefaultArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransferLine model
   */
  interface TransferLineFieldRefs {
    readonly id: FieldRef<"TransferLine", 'Int'>
    readonly transferId: FieldRef<"TransferLine", 'Int'>
    readonly productId: FieldRef<"TransferLine", 'Int'>
    readonly quantity: FieldRef<"TransferLine", 'Decimal'>
    readonly uom: FieldRef<"TransferLine", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TransferLine findUnique
   */
  export type TransferLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
    /**
     * Filter, which TransferLine to fetch.
     */
    where: TransferLineWhereUniqueInput
  }

  /**
   * TransferLine findUniqueOrThrow
   */
  export type TransferLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
    /**
     * Filter, which TransferLine to fetch.
     */
    where: TransferLineWhereUniqueInput
  }

  /**
   * TransferLine findFirst
   */
  export type TransferLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
    /**
     * Filter, which TransferLine to fetch.
     */
    where?: TransferLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferLines to fetch.
     */
    orderBy?: TransferLineOrderByWithRelationInput | TransferLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferLines.
     */
    cursor?: TransferLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferLines.
     */
    distinct?: TransferLineScalarFieldEnum | TransferLineScalarFieldEnum[]
  }

  /**
   * TransferLine findFirstOrThrow
   */
  export type TransferLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
    /**
     * Filter, which TransferLine to fetch.
     */
    where?: TransferLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferLines to fetch.
     */
    orderBy?: TransferLineOrderByWithRelationInput | TransferLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferLines.
     */
    cursor?: TransferLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferLines.
     */
    distinct?: TransferLineScalarFieldEnum | TransferLineScalarFieldEnum[]
  }

  /**
   * TransferLine findMany
   */
  export type TransferLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
    /**
     * Filter, which TransferLines to fetch.
     */
    where?: TransferLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferLines to fetch.
     */
    orderBy?: TransferLineOrderByWithRelationInput | TransferLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransferLines.
     */
    cursor?: TransferLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferLines.
     */
    skip?: number
    distinct?: TransferLineScalarFieldEnum | TransferLineScalarFieldEnum[]
  }

  /**
   * TransferLine create
   */
  export type TransferLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
    /**
     * The data needed to create a TransferLine.
     */
    data: XOR<TransferLineCreateInput, TransferLineUncheckedCreateInput>
  }

  /**
   * TransferLine createMany
   */
  export type TransferLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransferLines.
     */
    data: TransferLineCreateManyInput | TransferLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransferLine createManyAndReturn
   */
  export type TransferLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * The data used to create many TransferLines.
     */
    data: TransferLineCreateManyInput | TransferLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransferLine update
   */
  export type TransferLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
    /**
     * The data needed to update a TransferLine.
     */
    data: XOR<TransferLineUpdateInput, TransferLineUncheckedUpdateInput>
    /**
     * Choose, which TransferLine to update.
     */
    where: TransferLineWhereUniqueInput
  }

  /**
   * TransferLine updateMany
   */
  export type TransferLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransferLines.
     */
    data: XOR<TransferLineUpdateManyMutationInput, TransferLineUncheckedUpdateManyInput>
    /**
     * Filter which TransferLines to update
     */
    where?: TransferLineWhereInput
    /**
     * Limit how many TransferLines to update.
     */
    limit?: number
  }

  /**
   * TransferLine updateManyAndReturn
   */
  export type TransferLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * The data used to update TransferLines.
     */
    data: XOR<TransferLineUpdateManyMutationInput, TransferLineUncheckedUpdateManyInput>
    /**
     * Filter which TransferLines to update
     */
    where?: TransferLineWhereInput
    /**
     * Limit how many TransferLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransferLine upsert
   */
  export type TransferLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
    /**
     * The filter to search for the TransferLine to update in case it exists.
     */
    where: TransferLineWhereUniqueInput
    /**
     * In case the TransferLine found by the `where` argument doesn't exist, create a new TransferLine with this data.
     */
    create: XOR<TransferLineCreateInput, TransferLineUncheckedCreateInput>
    /**
     * In case the TransferLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferLineUpdateInput, TransferLineUncheckedUpdateInput>
  }

  /**
   * TransferLine delete
   */
  export type TransferLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
    /**
     * Filter which TransferLine to delete.
     */
    where: TransferLineWhereUniqueInput
  }

  /**
   * TransferLine deleteMany
   */
  export type TransferLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferLines to delete
     */
    where?: TransferLineWhereInput
    /**
     * Limit how many TransferLines to delete.
     */
    limit?: number
  }

  /**
   * TransferLine without action
   */
  export type TransferLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
  }


  /**
   * Model Adjustment
   */

  export type AggregateAdjustment = {
    _count: AdjustmentCountAggregateOutputType | null
    _avg: AdjustmentAvgAggregateOutputType | null
    _sum: AdjustmentSumAggregateOutputType | null
    _min: AdjustmentMinAggregateOutputType | null
    _max: AdjustmentMaxAggregateOutputType | null
  }

  export type AdjustmentAvgAggregateOutputType = {
    id: number | null
    warehouseId: number | null
    createdById: number | null
  }

  export type AdjustmentSumAggregateOutputType = {
    id: number | null
    warehouseId: number | null
    createdById: number | null
  }

  export type AdjustmentMinAggregateOutputType = {
    id: number | null
    adjustmentNo: string | null
    warehouseId: number | null
    reason: string | null
    status: $Enums.DocumentStatus | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdjustmentMaxAggregateOutputType = {
    id: number | null
    adjustmentNo: string | null
    warehouseId: number | null
    reason: string | null
    status: $Enums.DocumentStatus | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdjustmentCountAggregateOutputType = {
    id: number
    adjustmentNo: number
    warehouseId: number
    reason: number
    status: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdjustmentAvgAggregateInputType = {
    id?: true
    warehouseId?: true
    createdById?: true
  }

  export type AdjustmentSumAggregateInputType = {
    id?: true
    warehouseId?: true
    createdById?: true
  }

  export type AdjustmentMinAggregateInputType = {
    id?: true
    adjustmentNo?: true
    warehouseId?: true
    reason?: true
    status?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdjustmentMaxAggregateInputType = {
    id?: true
    adjustmentNo?: true
    warehouseId?: true
    reason?: true
    status?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdjustmentCountAggregateInputType = {
    id?: true
    adjustmentNo?: true
    warehouseId?: true
    reason?: true
    status?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdjustmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Adjustment to aggregate.
     */
    where?: AdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adjustments to fetch.
     */
    orderBy?: AdjustmentOrderByWithRelationInput | AdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Adjustments
    **/
    _count?: true | AdjustmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdjustmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdjustmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdjustmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdjustmentMaxAggregateInputType
  }

  export type GetAdjustmentAggregateType<T extends AdjustmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAdjustment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdjustment[P]>
      : GetScalarType<T[P], AggregateAdjustment[P]>
  }




  export type AdjustmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdjustmentWhereInput
    orderBy?: AdjustmentOrderByWithAggregationInput | AdjustmentOrderByWithAggregationInput[]
    by: AdjustmentScalarFieldEnum[] | AdjustmentScalarFieldEnum
    having?: AdjustmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdjustmentCountAggregateInputType | true
    _avg?: AdjustmentAvgAggregateInputType
    _sum?: AdjustmentSumAggregateInputType
    _min?: AdjustmentMinAggregateInputType
    _max?: AdjustmentMaxAggregateInputType
  }

  export type AdjustmentGroupByOutputType = {
    id: number
    adjustmentNo: string
    warehouseId: number
    reason: string | null
    status: $Enums.DocumentStatus
    createdById: number | null
    createdAt: Date
    updatedAt: Date
    _count: AdjustmentCountAggregateOutputType | null
    _avg: AdjustmentAvgAggregateOutputType | null
    _sum: AdjustmentSumAggregateOutputType | null
    _min: AdjustmentMinAggregateOutputType | null
    _max: AdjustmentMaxAggregateOutputType | null
  }

  type GetAdjustmentGroupByPayload<T extends AdjustmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdjustmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdjustmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdjustmentGroupByOutputType[P]>
            : GetScalarType<T[P], AdjustmentGroupByOutputType[P]>
        }
      >
    >


  export type AdjustmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adjustmentNo?: boolean
    warehouseId?: boolean
    reason?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Adjustment$createdByArgs<ExtArgs>
    lines?: boolean | Adjustment$linesArgs<ExtArgs>
    _count?: boolean | AdjustmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adjustment"]>

  export type AdjustmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adjustmentNo?: boolean
    warehouseId?: boolean
    reason?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Adjustment$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["adjustment"]>

  export type AdjustmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adjustmentNo?: boolean
    warehouseId?: boolean
    reason?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Adjustment$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["adjustment"]>

  export type AdjustmentSelectScalar = {
    id?: boolean
    adjustmentNo?: boolean
    warehouseId?: boolean
    reason?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdjustmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adjustmentNo" | "warehouseId" | "reason" | "status" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["adjustment"]>
  export type AdjustmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Adjustment$createdByArgs<ExtArgs>
    lines?: boolean | Adjustment$linesArgs<ExtArgs>
    _count?: boolean | AdjustmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdjustmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Adjustment$createdByArgs<ExtArgs>
  }
  export type AdjustmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | Adjustment$createdByArgs<ExtArgs>
  }

  export type $AdjustmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Adjustment"
    objects: {
      warehouse: Prisma.$WarehousePayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      lines: Prisma.$AdjustmentLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      adjustmentNo: string
      warehouseId: number
      reason: string | null
      status: $Enums.DocumentStatus
      createdById: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adjustment"]>
    composites: {}
  }

  type AdjustmentGetPayload<S extends boolean | null | undefined | AdjustmentDefaultArgs> = $Result.GetResult<Prisma.$AdjustmentPayload, S>

  type AdjustmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdjustmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdjustmentCountAggregateInputType | true
    }

  export interface AdjustmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Adjustment'], meta: { name: 'Adjustment' } }
    /**
     * Find zero or one Adjustment that matches the filter.
     * @param {AdjustmentFindUniqueArgs} args - Arguments to find a Adjustment
     * @example
     * // Get one Adjustment
     * const adjustment = await prisma.adjustment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdjustmentFindUniqueArgs>(args: SelectSubset<T, AdjustmentFindUniqueArgs<ExtArgs>>): Prisma__AdjustmentClient<$Result.GetResult<Prisma.$AdjustmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Adjustment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdjustmentFindUniqueOrThrowArgs} args - Arguments to find a Adjustment
     * @example
     * // Get one Adjustment
     * const adjustment = await prisma.adjustment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdjustmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AdjustmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdjustmentClient<$Result.GetResult<Prisma.$AdjustmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Adjustment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdjustmentFindFirstArgs} args - Arguments to find a Adjustment
     * @example
     * // Get one Adjustment
     * const adjustment = await prisma.adjustment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdjustmentFindFirstArgs>(args?: SelectSubset<T, AdjustmentFindFirstArgs<ExtArgs>>): Prisma__AdjustmentClient<$Result.GetResult<Prisma.$AdjustmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Adjustment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdjustmentFindFirstOrThrowArgs} args - Arguments to find a Adjustment
     * @example
     * // Get one Adjustment
     * const adjustment = await prisma.adjustment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdjustmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AdjustmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdjustmentClient<$Result.GetResult<Prisma.$AdjustmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Adjustments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdjustmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Adjustments
     * const adjustments = await prisma.adjustment.findMany()
     * 
     * // Get first 10 Adjustments
     * const adjustments = await prisma.adjustment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adjustmentWithIdOnly = await prisma.adjustment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdjustmentFindManyArgs>(args?: SelectSubset<T, AdjustmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdjustmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Adjustment.
     * @param {AdjustmentCreateArgs} args - Arguments to create a Adjustment.
     * @example
     * // Create one Adjustment
     * const Adjustment = await prisma.adjustment.create({
     *   data: {
     *     // ... data to create a Adjustment
     *   }
     * })
     * 
     */
    create<T extends AdjustmentCreateArgs>(args: SelectSubset<T, AdjustmentCreateArgs<ExtArgs>>): Prisma__AdjustmentClient<$Result.GetResult<Prisma.$AdjustmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Adjustments.
     * @param {AdjustmentCreateManyArgs} args - Arguments to create many Adjustments.
     * @example
     * // Create many Adjustments
     * const adjustment = await prisma.adjustment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdjustmentCreateManyArgs>(args?: SelectSubset<T, AdjustmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Adjustments and returns the data saved in the database.
     * @param {AdjustmentCreateManyAndReturnArgs} args - Arguments to create many Adjustments.
     * @example
     * // Create many Adjustments
     * const adjustment = await prisma.adjustment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Adjustments and only return the `id`
     * const adjustmentWithIdOnly = await prisma.adjustment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdjustmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AdjustmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdjustmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Adjustment.
     * @param {AdjustmentDeleteArgs} args - Arguments to delete one Adjustment.
     * @example
     * // Delete one Adjustment
     * const Adjustment = await prisma.adjustment.delete({
     *   where: {
     *     // ... filter to delete one Adjustment
     *   }
     * })
     * 
     */
    delete<T extends AdjustmentDeleteArgs>(args: SelectSubset<T, AdjustmentDeleteArgs<ExtArgs>>): Prisma__AdjustmentClient<$Result.GetResult<Prisma.$AdjustmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Adjustment.
     * @param {AdjustmentUpdateArgs} args - Arguments to update one Adjustment.
     * @example
     * // Update one Adjustment
     * const adjustment = await prisma.adjustment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdjustmentUpdateArgs>(args: SelectSubset<T, AdjustmentUpdateArgs<ExtArgs>>): Prisma__AdjustmentClient<$Result.GetResult<Prisma.$AdjustmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Adjustments.
     * @param {AdjustmentDeleteManyArgs} args - Arguments to filter Adjustments to delete.
     * @example
     * // Delete a few Adjustments
     * const { count } = await prisma.adjustment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdjustmentDeleteManyArgs>(args?: SelectSubset<T, AdjustmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Adjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdjustmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Adjustments
     * const adjustment = await prisma.adjustment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdjustmentUpdateManyArgs>(args: SelectSubset<T, AdjustmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Adjustments and returns the data updated in the database.
     * @param {AdjustmentUpdateManyAndReturnArgs} args - Arguments to update many Adjustments.
     * @example
     * // Update many Adjustments
     * const adjustment = await prisma.adjustment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Adjustments and only return the `id`
     * const adjustmentWithIdOnly = await prisma.adjustment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdjustmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AdjustmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdjustmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Adjustment.
     * @param {AdjustmentUpsertArgs} args - Arguments to update or create a Adjustment.
     * @example
     * // Update or create a Adjustment
     * const adjustment = await prisma.adjustment.upsert({
     *   create: {
     *     // ... data to create a Adjustment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Adjustment we want to update
     *   }
     * })
     */
    upsert<T extends AdjustmentUpsertArgs>(args: SelectSubset<T, AdjustmentUpsertArgs<ExtArgs>>): Prisma__AdjustmentClient<$Result.GetResult<Prisma.$AdjustmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Adjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdjustmentCountArgs} args - Arguments to filter Adjustments to count.
     * @example
     * // Count the number of Adjustments
     * const count = await prisma.adjustment.count({
     *   where: {
     *     // ... the filter for the Adjustments we want to count
     *   }
     * })
    **/
    count<T extends AdjustmentCountArgs>(
      args?: Subset<T, AdjustmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdjustmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Adjustment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdjustmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdjustmentAggregateArgs>(args: Subset<T, AdjustmentAggregateArgs>): Prisma.PrismaPromise<GetAdjustmentAggregateType<T>>

    /**
     * Group by Adjustment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdjustmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdjustmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdjustmentGroupByArgs['orderBy'] }
        : { orderBy?: AdjustmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdjustmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdjustmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Adjustment model
   */
  readonly fields: AdjustmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Adjustment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdjustmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Adjustment$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Adjustment$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lines<T extends Adjustment$linesArgs<ExtArgs> = {}>(args?: Subset<T, Adjustment$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdjustmentLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Adjustment model
   */
  interface AdjustmentFieldRefs {
    readonly id: FieldRef<"Adjustment", 'Int'>
    readonly adjustmentNo: FieldRef<"Adjustment", 'String'>
    readonly warehouseId: FieldRef<"Adjustment", 'Int'>
    readonly reason: FieldRef<"Adjustment", 'String'>
    readonly status: FieldRef<"Adjustment", 'DocumentStatus'>
    readonly createdById: FieldRef<"Adjustment", 'Int'>
    readonly createdAt: FieldRef<"Adjustment", 'DateTime'>
    readonly updatedAt: FieldRef<"Adjustment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Adjustment findUnique
   */
  export type AdjustmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adjustment
     */
    select?: AdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adjustment
     */
    omit?: AdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which Adjustment to fetch.
     */
    where: AdjustmentWhereUniqueInput
  }

  /**
   * Adjustment findUniqueOrThrow
   */
  export type AdjustmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adjustment
     */
    select?: AdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adjustment
     */
    omit?: AdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which Adjustment to fetch.
     */
    where: AdjustmentWhereUniqueInput
  }

  /**
   * Adjustment findFirst
   */
  export type AdjustmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adjustment
     */
    select?: AdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adjustment
     */
    omit?: AdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which Adjustment to fetch.
     */
    where?: AdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adjustments to fetch.
     */
    orderBy?: AdjustmentOrderByWithRelationInput | AdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Adjustments.
     */
    cursor?: AdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Adjustments.
     */
    distinct?: AdjustmentScalarFieldEnum | AdjustmentScalarFieldEnum[]
  }

  /**
   * Adjustment findFirstOrThrow
   */
  export type AdjustmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adjustment
     */
    select?: AdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adjustment
     */
    omit?: AdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which Adjustment to fetch.
     */
    where?: AdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adjustments to fetch.
     */
    orderBy?: AdjustmentOrderByWithRelationInput | AdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Adjustments.
     */
    cursor?: AdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Adjustments.
     */
    distinct?: AdjustmentScalarFieldEnum | AdjustmentScalarFieldEnum[]
  }

  /**
   * Adjustment findMany
   */
  export type AdjustmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adjustment
     */
    select?: AdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adjustment
     */
    omit?: AdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which Adjustments to fetch.
     */
    where?: AdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adjustments to fetch.
     */
    orderBy?: AdjustmentOrderByWithRelationInput | AdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Adjustments.
     */
    cursor?: AdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adjustments.
     */
    skip?: number
    distinct?: AdjustmentScalarFieldEnum | AdjustmentScalarFieldEnum[]
  }

  /**
   * Adjustment create
   */
  export type AdjustmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adjustment
     */
    select?: AdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adjustment
     */
    omit?: AdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Adjustment.
     */
    data: XOR<AdjustmentCreateInput, AdjustmentUncheckedCreateInput>
  }

  /**
   * Adjustment createMany
   */
  export type AdjustmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Adjustments.
     */
    data: AdjustmentCreateManyInput | AdjustmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Adjustment createManyAndReturn
   */
  export type AdjustmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adjustment
     */
    select?: AdjustmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Adjustment
     */
    omit?: AdjustmentOmit<ExtArgs> | null
    /**
     * The data used to create many Adjustments.
     */
    data: AdjustmentCreateManyInput | AdjustmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Adjustment update
   */
  export type AdjustmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adjustment
     */
    select?: AdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adjustment
     */
    omit?: AdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Adjustment.
     */
    data: XOR<AdjustmentUpdateInput, AdjustmentUncheckedUpdateInput>
    /**
     * Choose, which Adjustment to update.
     */
    where: AdjustmentWhereUniqueInput
  }

  /**
   * Adjustment updateMany
   */
  export type AdjustmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Adjustments.
     */
    data: XOR<AdjustmentUpdateManyMutationInput, AdjustmentUncheckedUpdateManyInput>
    /**
     * Filter which Adjustments to update
     */
    where?: AdjustmentWhereInput
    /**
     * Limit how many Adjustments to update.
     */
    limit?: number
  }

  /**
   * Adjustment updateManyAndReturn
   */
  export type AdjustmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adjustment
     */
    select?: AdjustmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Adjustment
     */
    omit?: AdjustmentOmit<ExtArgs> | null
    /**
     * The data used to update Adjustments.
     */
    data: XOR<AdjustmentUpdateManyMutationInput, AdjustmentUncheckedUpdateManyInput>
    /**
     * Filter which Adjustments to update
     */
    where?: AdjustmentWhereInput
    /**
     * Limit how many Adjustments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Adjustment upsert
   */
  export type AdjustmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adjustment
     */
    select?: AdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adjustment
     */
    omit?: AdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Adjustment to update in case it exists.
     */
    where: AdjustmentWhereUniqueInput
    /**
     * In case the Adjustment found by the `where` argument doesn't exist, create a new Adjustment with this data.
     */
    create: XOR<AdjustmentCreateInput, AdjustmentUncheckedCreateInput>
    /**
     * In case the Adjustment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdjustmentUpdateInput, AdjustmentUncheckedUpdateInput>
  }

  /**
   * Adjustment delete
   */
  export type AdjustmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adjustment
     */
    select?: AdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adjustment
     */
    omit?: AdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentInclude<ExtArgs> | null
    /**
     * Filter which Adjustment to delete.
     */
    where: AdjustmentWhereUniqueInput
  }

  /**
   * Adjustment deleteMany
   */
  export type AdjustmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Adjustments to delete
     */
    where?: AdjustmentWhereInput
    /**
     * Limit how many Adjustments to delete.
     */
    limit?: number
  }

  /**
   * Adjustment.createdBy
   */
  export type Adjustment$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Adjustment.lines
   */
  export type Adjustment$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdjustmentLine
     */
    select?: AdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdjustmentLine
     */
    omit?: AdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentLineInclude<ExtArgs> | null
    where?: AdjustmentLineWhereInput
    orderBy?: AdjustmentLineOrderByWithRelationInput | AdjustmentLineOrderByWithRelationInput[]
    cursor?: AdjustmentLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdjustmentLineScalarFieldEnum | AdjustmentLineScalarFieldEnum[]
  }

  /**
   * Adjustment without action
   */
  export type AdjustmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adjustment
     */
    select?: AdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adjustment
     */
    omit?: AdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentInclude<ExtArgs> | null
  }


  /**
   * Model AdjustmentLine
   */

  export type AggregateAdjustmentLine = {
    _count: AdjustmentLineCountAggregateOutputType | null
    _avg: AdjustmentLineAvgAggregateOutputType | null
    _sum: AdjustmentLineSumAggregateOutputType | null
    _min: AdjustmentLineMinAggregateOutputType | null
    _max: AdjustmentLineMaxAggregateOutputType | null
  }

  export type AdjustmentLineAvgAggregateOutputType = {
    id: number | null
    adjustmentId: number | null
    productId: number | null
    quantity: Decimal | null
  }

  export type AdjustmentLineSumAggregateOutputType = {
    id: number | null
    adjustmentId: number | null
    productId: number | null
    quantity: Decimal | null
  }

  export type AdjustmentLineMinAggregateOutputType = {
    id: number | null
    adjustmentId: number | null
    productId: number | null
    quantity: Decimal | null
    uom: string | null
    note: string | null
  }

  export type AdjustmentLineMaxAggregateOutputType = {
    id: number | null
    adjustmentId: number | null
    productId: number | null
    quantity: Decimal | null
    uom: string | null
    note: string | null
  }

  export type AdjustmentLineCountAggregateOutputType = {
    id: number
    adjustmentId: number
    productId: number
    quantity: number
    uom: number
    note: number
    _all: number
  }


  export type AdjustmentLineAvgAggregateInputType = {
    id?: true
    adjustmentId?: true
    productId?: true
    quantity?: true
  }

  export type AdjustmentLineSumAggregateInputType = {
    id?: true
    adjustmentId?: true
    productId?: true
    quantity?: true
  }

  export type AdjustmentLineMinAggregateInputType = {
    id?: true
    adjustmentId?: true
    productId?: true
    quantity?: true
    uom?: true
    note?: true
  }

  export type AdjustmentLineMaxAggregateInputType = {
    id?: true
    adjustmentId?: true
    productId?: true
    quantity?: true
    uom?: true
    note?: true
  }

  export type AdjustmentLineCountAggregateInputType = {
    id?: true
    adjustmentId?: true
    productId?: true
    quantity?: true
    uom?: true
    note?: true
    _all?: true
  }

  export type AdjustmentLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdjustmentLine to aggregate.
     */
    where?: AdjustmentLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdjustmentLines to fetch.
     */
    orderBy?: AdjustmentLineOrderByWithRelationInput | AdjustmentLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdjustmentLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdjustmentLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdjustmentLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdjustmentLines
    **/
    _count?: true | AdjustmentLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdjustmentLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdjustmentLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdjustmentLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdjustmentLineMaxAggregateInputType
  }

  export type GetAdjustmentLineAggregateType<T extends AdjustmentLineAggregateArgs> = {
        [P in keyof T & keyof AggregateAdjustmentLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdjustmentLine[P]>
      : GetScalarType<T[P], AggregateAdjustmentLine[P]>
  }




  export type AdjustmentLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdjustmentLineWhereInput
    orderBy?: AdjustmentLineOrderByWithAggregationInput | AdjustmentLineOrderByWithAggregationInput[]
    by: AdjustmentLineScalarFieldEnum[] | AdjustmentLineScalarFieldEnum
    having?: AdjustmentLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdjustmentLineCountAggregateInputType | true
    _avg?: AdjustmentLineAvgAggregateInputType
    _sum?: AdjustmentLineSumAggregateInputType
    _min?: AdjustmentLineMinAggregateInputType
    _max?: AdjustmentLineMaxAggregateInputType
  }

  export type AdjustmentLineGroupByOutputType = {
    id: number
    adjustmentId: number
    productId: number
    quantity: Decimal
    uom: string
    note: string | null
    _count: AdjustmentLineCountAggregateOutputType | null
    _avg: AdjustmentLineAvgAggregateOutputType | null
    _sum: AdjustmentLineSumAggregateOutputType | null
    _min: AdjustmentLineMinAggregateOutputType | null
    _max: AdjustmentLineMaxAggregateOutputType | null
  }

  type GetAdjustmentLineGroupByPayload<T extends AdjustmentLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdjustmentLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdjustmentLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdjustmentLineGroupByOutputType[P]>
            : GetScalarType<T[P], AdjustmentLineGroupByOutputType[P]>
        }
      >
    >


  export type AdjustmentLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adjustmentId?: boolean
    productId?: boolean
    quantity?: boolean
    uom?: boolean
    note?: boolean
    adjustment?: boolean | AdjustmentDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adjustmentLine"]>

  export type AdjustmentLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adjustmentId?: boolean
    productId?: boolean
    quantity?: boolean
    uom?: boolean
    note?: boolean
    adjustment?: boolean | AdjustmentDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adjustmentLine"]>

  export type AdjustmentLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adjustmentId?: boolean
    productId?: boolean
    quantity?: boolean
    uom?: boolean
    note?: boolean
    adjustment?: boolean | AdjustmentDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adjustmentLine"]>

  export type AdjustmentLineSelectScalar = {
    id?: boolean
    adjustmentId?: boolean
    productId?: boolean
    quantity?: boolean
    uom?: boolean
    note?: boolean
  }

  export type AdjustmentLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adjustmentId" | "productId" | "quantity" | "uom" | "note", ExtArgs["result"]["adjustmentLine"]>
  export type AdjustmentLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adjustment?: boolean | AdjustmentDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type AdjustmentLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adjustment?: boolean | AdjustmentDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type AdjustmentLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adjustment?: boolean | AdjustmentDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $AdjustmentLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdjustmentLine"
    objects: {
      adjustment: Prisma.$AdjustmentPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      adjustmentId: number
      productId: number
      quantity: Prisma.Decimal
      uom: string
      note: string | null
    }, ExtArgs["result"]["adjustmentLine"]>
    composites: {}
  }

  type AdjustmentLineGetPayload<S extends boolean | null | undefined | AdjustmentLineDefaultArgs> = $Result.GetResult<Prisma.$AdjustmentLinePayload, S>

  type AdjustmentLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdjustmentLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdjustmentLineCountAggregateInputType | true
    }

  export interface AdjustmentLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdjustmentLine'], meta: { name: 'AdjustmentLine' } }
    /**
     * Find zero or one AdjustmentLine that matches the filter.
     * @param {AdjustmentLineFindUniqueArgs} args - Arguments to find a AdjustmentLine
     * @example
     * // Get one AdjustmentLine
     * const adjustmentLine = await prisma.adjustmentLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdjustmentLineFindUniqueArgs>(args: SelectSubset<T, AdjustmentLineFindUniqueArgs<ExtArgs>>): Prisma__AdjustmentLineClient<$Result.GetResult<Prisma.$AdjustmentLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdjustmentLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdjustmentLineFindUniqueOrThrowArgs} args - Arguments to find a AdjustmentLine
     * @example
     * // Get one AdjustmentLine
     * const adjustmentLine = await prisma.adjustmentLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdjustmentLineFindUniqueOrThrowArgs>(args: SelectSubset<T, AdjustmentLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdjustmentLineClient<$Result.GetResult<Prisma.$AdjustmentLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdjustmentLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdjustmentLineFindFirstArgs} args - Arguments to find a AdjustmentLine
     * @example
     * // Get one AdjustmentLine
     * const adjustmentLine = await prisma.adjustmentLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdjustmentLineFindFirstArgs>(args?: SelectSubset<T, AdjustmentLineFindFirstArgs<ExtArgs>>): Prisma__AdjustmentLineClient<$Result.GetResult<Prisma.$AdjustmentLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdjustmentLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdjustmentLineFindFirstOrThrowArgs} args - Arguments to find a AdjustmentLine
     * @example
     * // Get one AdjustmentLine
     * const adjustmentLine = await prisma.adjustmentLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdjustmentLineFindFirstOrThrowArgs>(args?: SelectSubset<T, AdjustmentLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdjustmentLineClient<$Result.GetResult<Prisma.$AdjustmentLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdjustmentLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdjustmentLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdjustmentLines
     * const adjustmentLines = await prisma.adjustmentLine.findMany()
     * 
     * // Get first 10 AdjustmentLines
     * const adjustmentLines = await prisma.adjustmentLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adjustmentLineWithIdOnly = await prisma.adjustmentLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdjustmentLineFindManyArgs>(args?: SelectSubset<T, AdjustmentLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdjustmentLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdjustmentLine.
     * @param {AdjustmentLineCreateArgs} args - Arguments to create a AdjustmentLine.
     * @example
     * // Create one AdjustmentLine
     * const AdjustmentLine = await prisma.adjustmentLine.create({
     *   data: {
     *     // ... data to create a AdjustmentLine
     *   }
     * })
     * 
     */
    create<T extends AdjustmentLineCreateArgs>(args: SelectSubset<T, AdjustmentLineCreateArgs<ExtArgs>>): Prisma__AdjustmentLineClient<$Result.GetResult<Prisma.$AdjustmentLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdjustmentLines.
     * @param {AdjustmentLineCreateManyArgs} args - Arguments to create many AdjustmentLines.
     * @example
     * // Create many AdjustmentLines
     * const adjustmentLine = await prisma.adjustmentLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdjustmentLineCreateManyArgs>(args?: SelectSubset<T, AdjustmentLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdjustmentLines and returns the data saved in the database.
     * @param {AdjustmentLineCreateManyAndReturnArgs} args - Arguments to create many AdjustmentLines.
     * @example
     * // Create many AdjustmentLines
     * const adjustmentLine = await prisma.adjustmentLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdjustmentLines and only return the `id`
     * const adjustmentLineWithIdOnly = await prisma.adjustmentLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdjustmentLineCreateManyAndReturnArgs>(args?: SelectSubset<T, AdjustmentLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdjustmentLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdjustmentLine.
     * @param {AdjustmentLineDeleteArgs} args - Arguments to delete one AdjustmentLine.
     * @example
     * // Delete one AdjustmentLine
     * const AdjustmentLine = await prisma.adjustmentLine.delete({
     *   where: {
     *     // ... filter to delete one AdjustmentLine
     *   }
     * })
     * 
     */
    delete<T extends AdjustmentLineDeleteArgs>(args: SelectSubset<T, AdjustmentLineDeleteArgs<ExtArgs>>): Prisma__AdjustmentLineClient<$Result.GetResult<Prisma.$AdjustmentLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdjustmentLine.
     * @param {AdjustmentLineUpdateArgs} args - Arguments to update one AdjustmentLine.
     * @example
     * // Update one AdjustmentLine
     * const adjustmentLine = await prisma.adjustmentLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdjustmentLineUpdateArgs>(args: SelectSubset<T, AdjustmentLineUpdateArgs<ExtArgs>>): Prisma__AdjustmentLineClient<$Result.GetResult<Prisma.$AdjustmentLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdjustmentLines.
     * @param {AdjustmentLineDeleteManyArgs} args - Arguments to filter AdjustmentLines to delete.
     * @example
     * // Delete a few AdjustmentLines
     * const { count } = await prisma.adjustmentLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdjustmentLineDeleteManyArgs>(args?: SelectSubset<T, AdjustmentLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdjustmentLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdjustmentLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdjustmentLines
     * const adjustmentLine = await prisma.adjustmentLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdjustmentLineUpdateManyArgs>(args: SelectSubset<T, AdjustmentLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdjustmentLines and returns the data updated in the database.
     * @param {AdjustmentLineUpdateManyAndReturnArgs} args - Arguments to update many AdjustmentLines.
     * @example
     * // Update many AdjustmentLines
     * const adjustmentLine = await prisma.adjustmentLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdjustmentLines and only return the `id`
     * const adjustmentLineWithIdOnly = await prisma.adjustmentLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdjustmentLineUpdateManyAndReturnArgs>(args: SelectSubset<T, AdjustmentLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdjustmentLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdjustmentLine.
     * @param {AdjustmentLineUpsertArgs} args - Arguments to update or create a AdjustmentLine.
     * @example
     * // Update or create a AdjustmentLine
     * const adjustmentLine = await prisma.adjustmentLine.upsert({
     *   create: {
     *     // ... data to create a AdjustmentLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdjustmentLine we want to update
     *   }
     * })
     */
    upsert<T extends AdjustmentLineUpsertArgs>(args: SelectSubset<T, AdjustmentLineUpsertArgs<ExtArgs>>): Prisma__AdjustmentLineClient<$Result.GetResult<Prisma.$AdjustmentLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdjustmentLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdjustmentLineCountArgs} args - Arguments to filter AdjustmentLines to count.
     * @example
     * // Count the number of AdjustmentLines
     * const count = await prisma.adjustmentLine.count({
     *   where: {
     *     // ... the filter for the AdjustmentLines we want to count
     *   }
     * })
    **/
    count<T extends AdjustmentLineCountArgs>(
      args?: Subset<T, AdjustmentLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdjustmentLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdjustmentLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdjustmentLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdjustmentLineAggregateArgs>(args: Subset<T, AdjustmentLineAggregateArgs>): Prisma.PrismaPromise<GetAdjustmentLineAggregateType<T>>

    /**
     * Group by AdjustmentLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdjustmentLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdjustmentLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdjustmentLineGroupByArgs['orderBy'] }
        : { orderBy?: AdjustmentLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdjustmentLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdjustmentLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdjustmentLine model
   */
  readonly fields: AdjustmentLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdjustmentLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdjustmentLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adjustment<T extends AdjustmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdjustmentDefaultArgs<ExtArgs>>): Prisma__AdjustmentClient<$Result.GetResult<Prisma.$AdjustmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdjustmentLine model
   */
  interface AdjustmentLineFieldRefs {
    readonly id: FieldRef<"AdjustmentLine", 'Int'>
    readonly adjustmentId: FieldRef<"AdjustmentLine", 'Int'>
    readonly productId: FieldRef<"AdjustmentLine", 'Int'>
    readonly quantity: FieldRef<"AdjustmentLine", 'Decimal'>
    readonly uom: FieldRef<"AdjustmentLine", 'String'>
    readonly note: FieldRef<"AdjustmentLine", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdjustmentLine findUnique
   */
  export type AdjustmentLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdjustmentLine
     */
    select?: AdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdjustmentLine
     */
    omit?: AdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentLineInclude<ExtArgs> | null
    /**
     * Filter, which AdjustmentLine to fetch.
     */
    where: AdjustmentLineWhereUniqueInput
  }

  /**
   * AdjustmentLine findUniqueOrThrow
   */
  export type AdjustmentLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdjustmentLine
     */
    select?: AdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdjustmentLine
     */
    omit?: AdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentLineInclude<ExtArgs> | null
    /**
     * Filter, which AdjustmentLine to fetch.
     */
    where: AdjustmentLineWhereUniqueInput
  }

  /**
   * AdjustmentLine findFirst
   */
  export type AdjustmentLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdjustmentLine
     */
    select?: AdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdjustmentLine
     */
    omit?: AdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentLineInclude<ExtArgs> | null
    /**
     * Filter, which AdjustmentLine to fetch.
     */
    where?: AdjustmentLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdjustmentLines to fetch.
     */
    orderBy?: AdjustmentLineOrderByWithRelationInput | AdjustmentLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdjustmentLines.
     */
    cursor?: AdjustmentLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdjustmentLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdjustmentLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdjustmentLines.
     */
    distinct?: AdjustmentLineScalarFieldEnum | AdjustmentLineScalarFieldEnum[]
  }

  /**
   * AdjustmentLine findFirstOrThrow
   */
  export type AdjustmentLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdjustmentLine
     */
    select?: AdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdjustmentLine
     */
    omit?: AdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentLineInclude<ExtArgs> | null
    /**
     * Filter, which AdjustmentLine to fetch.
     */
    where?: AdjustmentLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdjustmentLines to fetch.
     */
    orderBy?: AdjustmentLineOrderByWithRelationInput | AdjustmentLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdjustmentLines.
     */
    cursor?: AdjustmentLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdjustmentLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdjustmentLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdjustmentLines.
     */
    distinct?: AdjustmentLineScalarFieldEnum | AdjustmentLineScalarFieldEnum[]
  }

  /**
   * AdjustmentLine findMany
   */
  export type AdjustmentLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdjustmentLine
     */
    select?: AdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdjustmentLine
     */
    omit?: AdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentLineInclude<ExtArgs> | null
    /**
     * Filter, which AdjustmentLines to fetch.
     */
    where?: AdjustmentLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdjustmentLines to fetch.
     */
    orderBy?: AdjustmentLineOrderByWithRelationInput | AdjustmentLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdjustmentLines.
     */
    cursor?: AdjustmentLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdjustmentLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdjustmentLines.
     */
    skip?: number
    distinct?: AdjustmentLineScalarFieldEnum | AdjustmentLineScalarFieldEnum[]
  }

  /**
   * AdjustmentLine create
   */
  export type AdjustmentLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdjustmentLine
     */
    select?: AdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdjustmentLine
     */
    omit?: AdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentLineInclude<ExtArgs> | null
    /**
     * The data needed to create a AdjustmentLine.
     */
    data: XOR<AdjustmentLineCreateInput, AdjustmentLineUncheckedCreateInput>
  }

  /**
   * AdjustmentLine createMany
   */
  export type AdjustmentLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdjustmentLines.
     */
    data: AdjustmentLineCreateManyInput | AdjustmentLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdjustmentLine createManyAndReturn
   */
  export type AdjustmentLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdjustmentLine
     */
    select?: AdjustmentLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdjustmentLine
     */
    omit?: AdjustmentLineOmit<ExtArgs> | null
    /**
     * The data used to create many AdjustmentLines.
     */
    data: AdjustmentLineCreateManyInput | AdjustmentLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdjustmentLine update
   */
  export type AdjustmentLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdjustmentLine
     */
    select?: AdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdjustmentLine
     */
    omit?: AdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentLineInclude<ExtArgs> | null
    /**
     * The data needed to update a AdjustmentLine.
     */
    data: XOR<AdjustmentLineUpdateInput, AdjustmentLineUncheckedUpdateInput>
    /**
     * Choose, which AdjustmentLine to update.
     */
    where: AdjustmentLineWhereUniqueInput
  }

  /**
   * AdjustmentLine updateMany
   */
  export type AdjustmentLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdjustmentLines.
     */
    data: XOR<AdjustmentLineUpdateManyMutationInput, AdjustmentLineUncheckedUpdateManyInput>
    /**
     * Filter which AdjustmentLines to update
     */
    where?: AdjustmentLineWhereInput
    /**
     * Limit how many AdjustmentLines to update.
     */
    limit?: number
  }

  /**
   * AdjustmentLine updateManyAndReturn
   */
  export type AdjustmentLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdjustmentLine
     */
    select?: AdjustmentLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdjustmentLine
     */
    omit?: AdjustmentLineOmit<ExtArgs> | null
    /**
     * The data used to update AdjustmentLines.
     */
    data: XOR<AdjustmentLineUpdateManyMutationInput, AdjustmentLineUncheckedUpdateManyInput>
    /**
     * Filter which AdjustmentLines to update
     */
    where?: AdjustmentLineWhereInput
    /**
     * Limit how many AdjustmentLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdjustmentLine upsert
   */
  export type AdjustmentLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdjustmentLine
     */
    select?: AdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdjustmentLine
     */
    omit?: AdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentLineInclude<ExtArgs> | null
    /**
     * The filter to search for the AdjustmentLine to update in case it exists.
     */
    where: AdjustmentLineWhereUniqueInput
    /**
     * In case the AdjustmentLine found by the `where` argument doesn't exist, create a new AdjustmentLine with this data.
     */
    create: XOR<AdjustmentLineCreateInput, AdjustmentLineUncheckedCreateInput>
    /**
     * In case the AdjustmentLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdjustmentLineUpdateInput, AdjustmentLineUncheckedUpdateInput>
  }

  /**
   * AdjustmentLine delete
   */
  export type AdjustmentLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdjustmentLine
     */
    select?: AdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdjustmentLine
     */
    omit?: AdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentLineInclude<ExtArgs> | null
    /**
     * Filter which AdjustmentLine to delete.
     */
    where: AdjustmentLineWhereUniqueInput
  }

  /**
   * AdjustmentLine deleteMany
   */
  export type AdjustmentLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdjustmentLines to delete
     */
    where?: AdjustmentLineWhereInput
    /**
     * Limit how many AdjustmentLines to delete.
     */
    limit?: number
  }

  /**
   * AdjustmentLine without action
   */
  export type AdjustmentLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdjustmentLine
     */
    select?: AdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdjustmentLine
     */
    omit?: AdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdjustmentLineInclude<ExtArgs> | null
  }


  /**
   * Model StockMove
   */

  export type AggregateStockMove = {
    _count: StockMoveCountAggregateOutputType | null
    _avg: StockMoveAvgAggregateOutputType | null
    _sum: StockMoveSumAggregateOutputType | null
    _min: StockMoveMinAggregateOutputType | null
    _max: StockMoveMaxAggregateOutputType | null
  }

  export type StockMoveAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: Decimal | null
    fromWarehouseId: number | null
    toWarehouseId: number | null
    fromLocationId: number | null
    toLocationId: number | null
    documentId: number | null
    createdById: number | null
  }

  export type StockMoveSumAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: Decimal | null
    fromWarehouseId: number | null
    toWarehouseId: number | null
    fromLocationId: number | null
    toLocationId: number | null
    documentId: number | null
    createdById: number | null
  }

  export type StockMoveMinAggregateOutputType = {
    id: number | null
    moveNo: string | null
    productId: number | null
    quantity: Decimal | null
    uom: string | null
    fromWarehouseId: number | null
    toWarehouseId: number | null
    fromLocationId: number | null
    toLocationId: number | null
    reason: string | null
    reference: string | null
    documentType: string | null
    documentId: number | null
    status: $Enums.DocumentStatus | null
    createdById: number | null
    createdAt: Date | null
  }

  export type StockMoveMaxAggregateOutputType = {
    id: number | null
    moveNo: string | null
    productId: number | null
    quantity: Decimal | null
    uom: string | null
    fromWarehouseId: number | null
    toWarehouseId: number | null
    fromLocationId: number | null
    toLocationId: number | null
    reason: string | null
    reference: string | null
    documentType: string | null
    documentId: number | null
    status: $Enums.DocumentStatus | null
    createdById: number | null
    createdAt: Date | null
  }

  export type StockMoveCountAggregateOutputType = {
    id: number
    moveNo: number
    productId: number
    quantity: number
    uom: number
    fromWarehouseId: number
    toWarehouseId: number
    fromLocationId: number
    toLocationId: number
    reason: number
    reference: number
    documentType: number
    documentId: number
    status: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type StockMoveAvgAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    fromWarehouseId?: true
    toWarehouseId?: true
    fromLocationId?: true
    toLocationId?: true
    documentId?: true
    createdById?: true
  }

  export type StockMoveSumAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    fromWarehouseId?: true
    toWarehouseId?: true
    fromLocationId?: true
    toLocationId?: true
    documentId?: true
    createdById?: true
  }

  export type StockMoveMinAggregateInputType = {
    id?: true
    moveNo?: true
    productId?: true
    quantity?: true
    uom?: true
    fromWarehouseId?: true
    toWarehouseId?: true
    fromLocationId?: true
    toLocationId?: true
    reason?: true
    reference?: true
    documentType?: true
    documentId?: true
    status?: true
    createdById?: true
    createdAt?: true
  }

  export type StockMoveMaxAggregateInputType = {
    id?: true
    moveNo?: true
    productId?: true
    quantity?: true
    uom?: true
    fromWarehouseId?: true
    toWarehouseId?: true
    fromLocationId?: true
    toLocationId?: true
    reason?: true
    reference?: true
    documentType?: true
    documentId?: true
    status?: true
    createdById?: true
    createdAt?: true
  }

  export type StockMoveCountAggregateInputType = {
    id?: true
    moveNo?: true
    productId?: true
    quantity?: true
    uom?: true
    fromWarehouseId?: true
    toWarehouseId?: true
    fromLocationId?: true
    toLocationId?: true
    reason?: true
    reference?: true
    documentType?: true
    documentId?: true
    status?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type StockMoveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockMove to aggregate.
     */
    where?: StockMoveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMoves to fetch.
     */
    orderBy?: StockMoveOrderByWithRelationInput | StockMoveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockMoveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMoves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMoves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockMoves
    **/
    _count?: true | StockMoveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockMoveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockMoveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockMoveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockMoveMaxAggregateInputType
  }

  export type GetStockMoveAggregateType<T extends StockMoveAggregateArgs> = {
        [P in keyof T & keyof AggregateStockMove]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockMove[P]>
      : GetScalarType<T[P], AggregateStockMove[P]>
  }




  export type StockMoveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMoveWhereInput
    orderBy?: StockMoveOrderByWithAggregationInput | StockMoveOrderByWithAggregationInput[]
    by: StockMoveScalarFieldEnum[] | StockMoveScalarFieldEnum
    having?: StockMoveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockMoveCountAggregateInputType | true
    _avg?: StockMoveAvgAggregateInputType
    _sum?: StockMoveSumAggregateInputType
    _min?: StockMoveMinAggregateInputType
    _max?: StockMoveMaxAggregateInputType
  }

  export type StockMoveGroupByOutputType = {
    id: number
    moveNo: string | null
    productId: number
    quantity: Decimal
    uom: string
    fromWarehouseId: number | null
    toWarehouseId: number | null
    fromLocationId: number | null
    toLocationId: number | null
    reason: string | null
    reference: string | null
    documentType: string | null
    documentId: number | null
    status: $Enums.DocumentStatus
    createdById: number | null
    createdAt: Date
    _count: StockMoveCountAggregateOutputType | null
    _avg: StockMoveAvgAggregateOutputType | null
    _sum: StockMoveSumAggregateOutputType | null
    _min: StockMoveMinAggregateOutputType | null
    _max: StockMoveMaxAggregateOutputType | null
  }

  type GetStockMoveGroupByPayload<T extends StockMoveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockMoveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockMoveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockMoveGroupByOutputType[P]>
            : GetScalarType<T[P], StockMoveGroupByOutputType[P]>
        }
      >
    >


  export type StockMoveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moveNo?: boolean
    productId?: boolean
    quantity?: boolean
    uom?: boolean
    fromWarehouseId?: boolean
    toWarehouseId?: boolean
    fromLocationId?: boolean
    toLocationId?: boolean
    reason?: boolean
    reference?: boolean
    documentType?: boolean
    documentId?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    fromWarehouse?: boolean | StockMove$fromWarehouseArgs<ExtArgs>
    toWarehouse?: boolean | StockMove$toWarehouseArgs<ExtArgs>
    fromLocation?: boolean | StockMove$fromLocationArgs<ExtArgs>
    toLocation?: boolean | StockMove$toLocationArgs<ExtArgs>
    createdBy?: boolean | StockMove$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["stockMove"]>

  export type StockMoveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moveNo?: boolean
    productId?: boolean
    quantity?: boolean
    uom?: boolean
    fromWarehouseId?: boolean
    toWarehouseId?: boolean
    fromLocationId?: boolean
    toLocationId?: boolean
    reason?: boolean
    reference?: boolean
    documentType?: boolean
    documentId?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    fromWarehouse?: boolean | StockMove$fromWarehouseArgs<ExtArgs>
    toWarehouse?: boolean | StockMove$toWarehouseArgs<ExtArgs>
    fromLocation?: boolean | StockMove$fromLocationArgs<ExtArgs>
    toLocation?: boolean | StockMove$toLocationArgs<ExtArgs>
    createdBy?: boolean | StockMove$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["stockMove"]>

  export type StockMoveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moveNo?: boolean
    productId?: boolean
    quantity?: boolean
    uom?: boolean
    fromWarehouseId?: boolean
    toWarehouseId?: boolean
    fromLocationId?: boolean
    toLocationId?: boolean
    reason?: boolean
    reference?: boolean
    documentType?: boolean
    documentId?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    fromWarehouse?: boolean | StockMove$fromWarehouseArgs<ExtArgs>
    toWarehouse?: boolean | StockMove$toWarehouseArgs<ExtArgs>
    fromLocation?: boolean | StockMove$fromLocationArgs<ExtArgs>
    toLocation?: boolean | StockMove$toLocationArgs<ExtArgs>
    createdBy?: boolean | StockMove$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["stockMove"]>

  export type StockMoveSelectScalar = {
    id?: boolean
    moveNo?: boolean
    productId?: boolean
    quantity?: boolean
    uom?: boolean
    fromWarehouseId?: boolean
    toWarehouseId?: boolean
    fromLocationId?: boolean
    toLocationId?: boolean
    reason?: boolean
    reference?: boolean
    documentType?: boolean
    documentId?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type StockMoveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "moveNo" | "productId" | "quantity" | "uom" | "fromWarehouseId" | "toWarehouseId" | "fromLocationId" | "toLocationId" | "reason" | "reference" | "documentType" | "documentId" | "status" | "createdById" | "createdAt", ExtArgs["result"]["stockMove"]>
  export type StockMoveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    fromWarehouse?: boolean | StockMove$fromWarehouseArgs<ExtArgs>
    toWarehouse?: boolean | StockMove$toWarehouseArgs<ExtArgs>
    fromLocation?: boolean | StockMove$fromLocationArgs<ExtArgs>
    toLocation?: boolean | StockMove$toLocationArgs<ExtArgs>
    createdBy?: boolean | StockMove$createdByArgs<ExtArgs>
  }
  export type StockMoveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    fromWarehouse?: boolean | StockMove$fromWarehouseArgs<ExtArgs>
    toWarehouse?: boolean | StockMove$toWarehouseArgs<ExtArgs>
    fromLocation?: boolean | StockMove$fromLocationArgs<ExtArgs>
    toLocation?: boolean | StockMove$toLocationArgs<ExtArgs>
    createdBy?: boolean | StockMove$createdByArgs<ExtArgs>
  }
  export type StockMoveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    fromWarehouse?: boolean | StockMove$fromWarehouseArgs<ExtArgs>
    toWarehouse?: boolean | StockMove$toWarehouseArgs<ExtArgs>
    fromLocation?: boolean | StockMove$fromLocationArgs<ExtArgs>
    toLocation?: boolean | StockMove$toLocationArgs<ExtArgs>
    createdBy?: boolean | StockMove$createdByArgs<ExtArgs>
  }

  export type $StockMovePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockMove"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      fromWarehouse: Prisma.$WarehousePayload<ExtArgs> | null
      toWarehouse: Prisma.$WarehousePayload<ExtArgs> | null
      fromLocation: Prisma.$LocationPayload<ExtArgs> | null
      toLocation: Prisma.$LocationPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      moveNo: string | null
      productId: number
      quantity: Prisma.Decimal
      uom: string
      fromWarehouseId: number | null
      toWarehouseId: number | null
      fromLocationId: number | null
      toLocationId: number | null
      reason: string | null
      reference: string | null
      documentType: string | null
      documentId: number | null
      status: $Enums.DocumentStatus
      createdById: number | null
      createdAt: Date
    }, ExtArgs["result"]["stockMove"]>
    composites: {}
  }

  type StockMoveGetPayload<S extends boolean | null | undefined | StockMoveDefaultArgs> = $Result.GetResult<Prisma.$StockMovePayload, S>

  type StockMoveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockMoveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockMoveCountAggregateInputType | true
    }

  export interface StockMoveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockMove'], meta: { name: 'StockMove' } }
    /**
     * Find zero or one StockMove that matches the filter.
     * @param {StockMoveFindUniqueArgs} args - Arguments to find a StockMove
     * @example
     * // Get one StockMove
     * const stockMove = await prisma.stockMove.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockMoveFindUniqueArgs>(args: SelectSubset<T, StockMoveFindUniqueArgs<ExtArgs>>): Prisma__StockMoveClient<$Result.GetResult<Prisma.$StockMovePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockMove that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockMoveFindUniqueOrThrowArgs} args - Arguments to find a StockMove
     * @example
     * // Get one StockMove
     * const stockMove = await prisma.stockMove.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockMoveFindUniqueOrThrowArgs>(args: SelectSubset<T, StockMoveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockMoveClient<$Result.GetResult<Prisma.$StockMovePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockMove that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMoveFindFirstArgs} args - Arguments to find a StockMove
     * @example
     * // Get one StockMove
     * const stockMove = await prisma.stockMove.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockMoveFindFirstArgs>(args?: SelectSubset<T, StockMoveFindFirstArgs<ExtArgs>>): Prisma__StockMoveClient<$Result.GetResult<Prisma.$StockMovePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockMove that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMoveFindFirstOrThrowArgs} args - Arguments to find a StockMove
     * @example
     * // Get one StockMove
     * const stockMove = await prisma.stockMove.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockMoveFindFirstOrThrowArgs>(args?: SelectSubset<T, StockMoveFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockMoveClient<$Result.GetResult<Prisma.$StockMovePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockMoves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMoveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockMoves
     * const stockMoves = await prisma.stockMove.findMany()
     * 
     * // Get first 10 StockMoves
     * const stockMoves = await prisma.stockMove.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockMoveWithIdOnly = await prisma.stockMove.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockMoveFindManyArgs>(args?: SelectSubset<T, StockMoveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockMove.
     * @param {StockMoveCreateArgs} args - Arguments to create a StockMove.
     * @example
     * // Create one StockMove
     * const StockMove = await prisma.stockMove.create({
     *   data: {
     *     // ... data to create a StockMove
     *   }
     * })
     * 
     */
    create<T extends StockMoveCreateArgs>(args: SelectSubset<T, StockMoveCreateArgs<ExtArgs>>): Prisma__StockMoveClient<$Result.GetResult<Prisma.$StockMovePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockMoves.
     * @param {StockMoveCreateManyArgs} args - Arguments to create many StockMoves.
     * @example
     * // Create many StockMoves
     * const stockMove = await prisma.stockMove.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockMoveCreateManyArgs>(args?: SelectSubset<T, StockMoveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockMoves and returns the data saved in the database.
     * @param {StockMoveCreateManyAndReturnArgs} args - Arguments to create many StockMoves.
     * @example
     * // Create many StockMoves
     * const stockMove = await prisma.stockMove.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockMoves and only return the `id`
     * const stockMoveWithIdOnly = await prisma.stockMove.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockMoveCreateManyAndReturnArgs>(args?: SelectSubset<T, StockMoveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockMove.
     * @param {StockMoveDeleteArgs} args - Arguments to delete one StockMove.
     * @example
     * // Delete one StockMove
     * const StockMove = await prisma.stockMove.delete({
     *   where: {
     *     // ... filter to delete one StockMove
     *   }
     * })
     * 
     */
    delete<T extends StockMoveDeleteArgs>(args: SelectSubset<T, StockMoveDeleteArgs<ExtArgs>>): Prisma__StockMoveClient<$Result.GetResult<Prisma.$StockMovePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockMove.
     * @param {StockMoveUpdateArgs} args - Arguments to update one StockMove.
     * @example
     * // Update one StockMove
     * const stockMove = await prisma.stockMove.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockMoveUpdateArgs>(args: SelectSubset<T, StockMoveUpdateArgs<ExtArgs>>): Prisma__StockMoveClient<$Result.GetResult<Prisma.$StockMovePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockMoves.
     * @param {StockMoveDeleteManyArgs} args - Arguments to filter StockMoves to delete.
     * @example
     * // Delete a few StockMoves
     * const { count } = await prisma.stockMove.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockMoveDeleteManyArgs>(args?: SelectSubset<T, StockMoveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockMoves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMoveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockMoves
     * const stockMove = await prisma.stockMove.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockMoveUpdateManyArgs>(args: SelectSubset<T, StockMoveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockMoves and returns the data updated in the database.
     * @param {StockMoveUpdateManyAndReturnArgs} args - Arguments to update many StockMoves.
     * @example
     * // Update many StockMoves
     * const stockMove = await prisma.stockMove.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockMoves and only return the `id`
     * const stockMoveWithIdOnly = await prisma.stockMove.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockMoveUpdateManyAndReturnArgs>(args: SelectSubset<T, StockMoveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockMove.
     * @param {StockMoveUpsertArgs} args - Arguments to update or create a StockMove.
     * @example
     * // Update or create a StockMove
     * const stockMove = await prisma.stockMove.upsert({
     *   create: {
     *     // ... data to create a StockMove
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockMove we want to update
     *   }
     * })
     */
    upsert<T extends StockMoveUpsertArgs>(args: SelectSubset<T, StockMoveUpsertArgs<ExtArgs>>): Prisma__StockMoveClient<$Result.GetResult<Prisma.$StockMovePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockMoves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMoveCountArgs} args - Arguments to filter StockMoves to count.
     * @example
     * // Count the number of StockMoves
     * const count = await prisma.stockMove.count({
     *   where: {
     *     // ... the filter for the StockMoves we want to count
     *   }
     * })
    **/
    count<T extends StockMoveCountArgs>(
      args?: Subset<T, StockMoveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockMoveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockMove.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMoveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockMoveAggregateArgs>(args: Subset<T, StockMoveAggregateArgs>): Prisma.PrismaPromise<GetStockMoveAggregateType<T>>

    /**
     * Group by StockMove.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMoveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockMoveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockMoveGroupByArgs['orderBy'] }
        : { orderBy?: StockMoveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockMoveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockMoveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockMove model
   */
  readonly fields: StockMoveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockMove.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockMoveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fromWarehouse<T extends StockMove$fromWarehouseArgs<ExtArgs> = {}>(args?: Subset<T, StockMove$fromWarehouseArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    toWarehouse<T extends StockMove$toWarehouseArgs<ExtArgs> = {}>(args?: Subset<T, StockMove$toWarehouseArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fromLocation<T extends StockMove$fromLocationArgs<ExtArgs> = {}>(args?: Subset<T, StockMove$fromLocationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    toLocation<T extends StockMove$toLocationArgs<ExtArgs> = {}>(args?: Subset<T, StockMove$toLocationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends StockMove$createdByArgs<ExtArgs> = {}>(args?: Subset<T, StockMove$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockMove model
   */
  interface StockMoveFieldRefs {
    readonly id: FieldRef<"StockMove", 'Int'>
    readonly moveNo: FieldRef<"StockMove", 'String'>
    readonly productId: FieldRef<"StockMove", 'Int'>
    readonly quantity: FieldRef<"StockMove", 'Decimal'>
    readonly uom: FieldRef<"StockMove", 'String'>
    readonly fromWarehouseId: FieldRef<"StockMove", 'Int'>
    readonly toWarehouseId: FieldRef<"StockMove", 'Int'>
    readonly fromLocationId: FieldRef<"StockMove", 'Int'>
    readonly toLocationId: FieldRef<"StockMove", 'Int'>
    readonly reason: FieldRef<"StockMove", 'String'>
    readonly reference: FieldRef<"StockMove", 'String'>
    readonly documentType: FieldRef<"StockMove", 'String'>
    readonly documentId: FieldRef<"StockMove", 'Int'>
    readonly status: FieldRef<"StockMove", 'DocumentStatus'>
    readonly createdById: FieldRef<"StockMove", 'Int'>
    readonly createdAt: FieldRef<"StockMove", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockMove findUnique
   */
  export type StockMoveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMove
     */
    select?: StockMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMove
     */
    omit?: StockMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMoveInclude<ExtArgs> | null
    /**
     * Filter, which StockMove to fetch.
     */
    where: StockMoveWhereUniqueInput
  }

  /**
   * StockMove findUniqueOrThrow
   */
  export type StockMoveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMove
     */
    select?: StockMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMove
     */
    omit?: StockMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMoveInclude<ExtArgs> | null
    /**
     * Filter, which StockMove to fetch.
     */
    where: StockMoveWhereUniqueInput
  }

  /**
   * StockMove findFirst
   */
  export type StockMoveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMove
     */
    select?: StockMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMove
     */
    omit?: StockMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMoveInclude<ExtArgs> | null
    /**
     * Filter, which StockMove to fetch.
     */
    where?: StockMoveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMoves to fetch.
     */
    orderBy?: StockMoveOrderByWithRelationInput | StockMoveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockMoves.
     */
    cursor?: StockMoveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMoves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMoves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockMoves.
     */
    distinct?: StockMoveScalarFieldEnum | StockMoveScalarFieldEnum[]
  }

  /**
   * StockMove findFirstOrThrow
   */
  export type StockMoveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMove
     */
    select?: StockMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMove
     */
    omit?: StockMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMoveInclude<ExtArgs> | null
    /**
     * Filter, which StockMove to fetch.
     */
    where?: StockMoveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMoves to fetch.
     */
    orderBy?: StockMoveOrderByWithRelationInput | StockMoveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockMoves.
     */
    cursor?: StockMoveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMoves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMoves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockMoves.
     */
    distinct?: StockMoveScalarFieldEnum | StockMoveScalarFieldEnum[]
  }

  /**
   * StockMove findMany
   */
  export type StockMoveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMove
     */
    select?: StockMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMove
     */
    omit?: StockMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMoveInclude<ExtArgs> | null
    /**
     * Filter, which StockMoves to fetch.
     */
    where?: StockMoveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMoves to fetch.
     */
    orderBy?: StockMoveOrderByWithRelationInput | StockMoveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockMoves.
     */
    cursor?: StockMoveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMoves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMoves.
     */
    skip?: number
    distinct?: StockMoveScalarFieldEnum | StockMoveScalarFieldEnum[]
  }

  /**
   * StockMove create
   */
  export type StockMoveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMove
     */
    select?: StockMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMove
     */
    omit?: StockMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMoveInclude<ExtArgs> | null
    /**
     * The data needed to create a StockMove.
     */
    data: XOR<StockMoveCreateInput, StockMoveUncheckedCreateInput>
  }

  /**
   * StockMove createMany
   */
  export type StockMoveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockMoves.
     */
    data: StockMoveCreateManyInput | StockMoveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockMove createManyAndReturn
   */
  export type StockMoveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMove
     */
    select?: StockMoveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockMove
     */
    omit?: StockMoveOmit<ExtArgs> | null
    /**
     * The data used to create many StockMoves.
     */
    data: StockMoveCreateManyInput | StockMoveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMoveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockMove update
   */
  export type StockMoveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMove
     */
    select?: StockMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMove
     */
    omit?: StockMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMoveInclude<ExtArgs> | null
    /**
     * The data needed to update a StockMove.
     */
    data: XOR<StockMoveUpdateInput, StockMoveUncheckedUpdateInput>
    /**
     * Choose, which StockMove to update.
     */
    where: StockMoveWhereUniqueInput
  }

  /**
   * StockMove updateMany
   */
  export type StockMoveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockMoves.
     */
    data: XOR<StockMoveUpdateManyMutationInput, StockMoveUncheckedUpdateManyInput>
    /**
     * Filter which StockMoves to update
     */
    where?: StockMoveWhereInput
    /**
     * Limit how many StockMoves to update.
     */
    limit?: number
  }

  /**
   * StockMove updateManyAndReturn
   */
  export type StockMoveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMove
     */
    select?: StockMoveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockMove
     */
    omit?: StockMoveOmit<ExtArgs> | null
    /**
     * The data used to update StockMoves.
     */
    data: XOR<StockMoveUpdateManyMutationInput, StockMoveUncheckedUpdateManyInput>
    /**
     * Filter which StockMoves to update
     */
    where?: StockMoveWhereInput
    /**
     * Limit how many StockMoves to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMoveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockMove upsert
   */
  export type StockMoveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMove
     */
    select?: StockMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMove
     */
    omit?: StockMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMoveInclude<ExtArgs> | null
    /**
     * The filter to search for the StockMove to update in case it exists.
     */
    where: StockMoveWhereUniqueInput
    /**
     * In case the StockMove found by the `where` argument doesn't exist, create a new StockMove with this data.
     */
    create: XOR<StockMoveCreateInput, StockMoveUncheckedCreateInput>
    /**
     * In case the StockMove was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockMoveUpdateInput, StockMoveUncheckedUpdateInput>
  }

  /**
   * StockMove delete
   */
  export type StockMoveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMove
     */
    select?: StockMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMove
     */
    omit?: StockMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMoveInclude<ExtArgs> | null
    /**
     * Filter which StockMove to delete.
     */
    where: StockMoveWhereUniqueInput
  }

  /**
   * StockMove deleteMany
   */
  export type StockMoveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockMoves to delete
     */
    where?: StockMoveWhereInput
    /**
     * Limit how many StockMoves to delete.
     */
    limit?: number
  }

  /**
   * StockMove.fromWarehouse
   */
  export type StockMove$fromWarehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    where?: WarehouseWhereInput
  }

  /**
   * StockMove.toWarehouse
   */
  export type StockMove$toWarehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    where?: WarehouseWhereInput
  }

  /**
   * StockMove.fromLocation
   */
  export type StockMove$fromLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * StockMove.toLocation
   */
  export type StockMove$toLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * StockMove.createdBy
   */
  export type StockMove$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * StockMove without action
   */
  export type StockMoveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMove
     */
    select?: StockMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMove
     */
    omit?: StockMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMoveInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    passwordHash: 'passwordHash',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const OtpScalarFieldEnum: {
    id: 'id',
    email: 'email',
    code: 'code',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type OtpScalarFieldEnum = (typeof OtpScalarFieldEnum)[keyof typeof OtpScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    name: 'name',
    description: 'description',
    uom: 'uom',
    defaultPrice: 'defaultPrice',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    categoryId: 'categoryId'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ReorderRuleScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    warehouseId: 'warehouseId',
    minQty: 'minQty',
    maxQty: 'maxQty',
    createdAt: 'createdAt'
  };

  export type ReorderRuleScalarFieldEnum = (typeof ReorderRuleScalarFieldEnum)[keyof typeof ReorderRuleScalarFieldEnum]


  export const WarehouseScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    address: 'address',
    phone: 'phone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WarehouseScalarFieldEnum = (typeof WarehouseScalarFieldEnum)[keyof typeof WarehouseScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    warehouseId: 'warehouseId',
    parentId: 'parentId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const StockQuantScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    warehouseId: 'warehouseId',
    locationId: 'locationId',
    quantity: 'quantity',
    reserved: 'reserved',
    incoming: 'incoming',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StockQuantScalarFieldEnum = (typeof StockQuantScalarFieldEnum)[keyof typeof StockQuantScalarFieldEnum]


  export const ReceiptScalarFieldEnum: {
    id: 'id',
    receiptNo: 'receiptNo',
    reference: 'reference',
    warehouseId: 'warehouseId',
    partner: 'partner',
    status: 'status',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReceiptScalarFieldEnum = (typeof ReceiptScalarFieldEnum)[keyof typeof ReceiptScalarFieldEnum]


  export const ReceiptLineScalarFieldEnum: {
    id: 'id',
    receiptId: 'receiptId',
    productId: 'productId',
    quantity: 'quantity',
    uom: 'uom',
    unitPrice: 'unitPrice'
  };

  export type ReceiptLineScalarFieldEnum = (typeof ReceiptLineScalarFieldEnum)[keyof typeof ReceiptLineScalarFieldEnum]


  export const DeliveryScalarFieldEnum: {
    id: 'id',
    deliveryNo: 'deliveryNo',
    reference: 'reference',
    warehouseId: 'warehouseId',
    partner: 'partner',
    status: 'status',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeliveryScalarFieldEnum = (typeof DeliveryScalarFieldEnum)[keyof typeof DeliveryScalarFieldEnum]


  export const DeliveryLineScalarFieldEnum: {
    id: 'id',
    deliveryId: 'deliveryId',
    productId: 'productId',
    quantity: 'quantity',
    uom: 'uom',
    unitPrice: 'unitPrice'
  };

  export type DeliveryLineScalarFieldEnum = (typeof DeliveryLineScalarFieldEnum)[keyof typeof DeliveryLineScalarFieldEnum]


  export const TransferScalarFieldEnum: {
    id: 'id',
    transferNo: 'transferNo',
    reference: 'reference',
    fromWarehouseId: 'fromWarehouseId',
    toWarehouseId: 'toWarehouseId',
    status: 'status',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransferScalarFieldEnum = (typeof TransferScalarFieldEnum)[keyof typeof TransferScalarFieldEnum]


  export const TransferLineScalarFieldEnum: {
    id: 'id',
    transferId: 'transferId',
    productId: 'productId',
    quantity: 'quantity',
    uom: 'uom'
  };

  export type TransferLineScalarFieldEnum = (typeof TransferLineScalarFieldEnum)[keyof typeof TransferLineScalarFieldEnum]


  export const AdjustmentScalarFieldEnum: {
    id: 'id',
    adjustmentNo: 'adjustmentNo',
    warehouseId: 'warehouseId',
    reason: 'reason',
    status: 'status',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdjustmentScalarFieldEnum = (typeof AdjustmentScalarFieldEnum)[keyof typeof AdjustmentScalarFieldEnum]


  export const AdjustmentLineScalarFieldEnum: {
    id: 'id',
    adjustmentId: 'adjustmentId',
    productId: 'productId',
    quantity: 'quantity',
    uom: 'uom',
    note: 'note'
  };

  export type AdjustmentLineScalarFieldEnum = (typeof AdjustmentLineScalarFieldEnum)[keyof typeof AdjustmentLineScalarFieldEnum]


  export const StockMoveScalarFieldEnum: {
    id: 'id',
    moveNo: 'moveNo',
    productId: 'productId',
    quantity: 'quantity',
    uom: 'uom',
    fromWarehouseId: 'fromWarehouseId',
    toWarehouseId: 'toWarehouseId',
    fromLocationId: 'fromLocationId',
    toLocationId: 'toLocationId',
    reason: 'reason',
    reference: 'reference',
    documentType: 'documentType',
    documentId: 'documentId',
    status: 'status',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type StockMoveScalarFieldEnum = (typeof StockMoveScalarFieldEnum)[keyof typeof StockMoveScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DocumentStatus'
   */
  export type EnumDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentStatus'>
    


  /**
   * Reference to a field of type 'DocumentStatus[]'
   */
  export type ListEnumDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    receiptsCreated?: ReceiptListRelationFilter
    deliveriesCreated?: DeliveryListRelationFilter
    transfersCreated?: TransferListRelationFilter
    adjustmentsCreated?: AdjustmentListRelationFilter
    stockMovesCreated?: StockMoveListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    receiptsCreated?: ReceiptOrderByRelationAggregateInput
    deliveriesCreated?: DeliveryOrderByRelationAggregateInput
    transfersCreated?: TransferOrderByRelationAggregateInput
    adjustmentsCreated?: AdjustmentOrderByRelationAggregateInput
    stockMovesCreated?: StockMoveOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    receiptsCreated?: ReceiptListRelationFilter
    deliveriesCreated?: DeliveryListRelationFilter
    transfersCreated?: TransferListRelationFilter
    adjustmentsCreated?: AdjustmentListRelationFilter
    stockMovesCreated?: StockMoveListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type OtpWhereInput = {
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    id?: IntFilter<"Otp"> | number
    email?: StringFilter<"Otp"> | string
    code?: StringFilter<"Otp"> | string
    expiresAt?: DateTimeFilter<"Otp"> | Date | string
    createdAt?: DateTimeFilter<"Otp"> | Date | string
  }

  export type OtpOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OtpWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    email?: StringFilter<"Otp"> | string
    code?: StringFilter<"Otp"> | string
    expiresAt?: DateTimeFilter<"Otp"> | Date | string
    createdAt?: DateTimeFilter<"Otp"> | Date | string
  }, "id">

  export type OtpOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: OtpCountOrderByAggregateInput
    _avg?: OtpAvgOrderByAggregateInput
    _max?: OtpMaxOrderByAggregateInput
    _min?: OtpMinOrderByAggregateInput
    _sum?: OtpSumOrderByAggregateInput
  }

  export type OtpScalarWhereWithAggregatesInput = {
    AND?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    OR?: OtpScalarWhereWithAggregatesInput[]
    NOT?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Otp"> | number
    email?: StringWithAggregatesFilter<"Otp"> | string
    code?: StringWithAggregatesFilter<"Otp"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    sku?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    uom?: StringFilter<"Product"> | string
    defaultPrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    active?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    categoryId?: IntNullableFilter<"Product"> | number | null
    stockQuants?: StockQuantListRelationFilter
    stockMoves?: StockMoveListRelationFilter
    receiptLines?: ReceiptLineListRelationFilter
    deliveryLines?: DeliveryLineListRelationFilter
    transferLines?: TransferLineListRelationFilter
    adjustmentLines?: AdjustmentLineListRelationFilter
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    reorderRules?: ReorderRuleListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    uom?: SortOrder
    defaultPrice?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    stockQuants?: StockQuantOrderByRelationAggregateInput
    stockMoves?: StockMoveOrderByRelationAggregateInput
    receiptLines?: ReceiptLineOrderByRelationAggregateInput
    deliveryLines?: DeliveryLineOrderByRelationAggregateInput
    transferLines?: TransferLineOrderByRelationAggregateInput
    adjustmentLines?: AdjustmentLineOrderByRelationAggregateInput
    category?: CategoryOrderByWithRelationInput
    reorderRules?: ReorderRuleOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sku?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    uom?: StringFilter<"Product"> | string
    defaultPrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    active?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    categoryId?: IntNullableFilter<"Product"> | number | null
    stockQuants?: StockQuantListRelationFilter
    stockMoves?: StockMoveListRelationFilter
    receiptLines?: ReceiptLineListRelationFilter
    deliveryLines?: DeliveryLineListRelationFilter
    transferLines?: TransferLineListRelationFilter
    adjustmentLines?: AdjustmentLineListRelationFilter
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    reorderRules?: ReorderRuleListRelationFilter
  }, "id" | "sku">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    uom?: SortOrder
    defaultPrice?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    sku?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    uom?: StringWithAggregatesFilter<"Product"> | string
    defaultPrice?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    active?: BoolWithAggregatesFilter<"Product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    categoryId?: IntNullableWithAggregatesFilter<"Product"> | number | null
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    parentId?: IntNullableFilter<"Category"> | number | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    products?: ProductListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    parentId?: IntNullableFilter<"Category"> | number | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    products?: ProductListRelationFilter
  }, "id" | "name">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Category"> | number
    name?: StringWithAggregatesFilter<"Category"> | string
    parentId?: IntNullableWithAggregatesFilter<"Category"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type ReorderRuleWhereInput = {
    AND?: ReorderRuleWhereInput | ReorderRuleWhereInput[]
    OR?: ReorderRuleWhereInput[]
    NOT?: ReorderRuleWhereInput | ReorderRuleWhereInput[]
    id?: IntFilter<"ReorderRule"> | number
    productId?: IntFilter<"ReorderRule"> | number
    warehouseId?: IntFilter<"ReorderRule"> | number
    minQty?: DecimalFilter<"ReorderRule"> | Decimal | DecimalJsLike | number | string
    maxQty?: DecimalNullableFilter<"ReorderRule"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ReorderRule"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
  }

  export type ReorderRuleOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    minQty?: SortOrder
    maxQty?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
  }

  export type ReorderRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    productId_warehouseId?: ReorderRuleProductIdWarehouseIdCompoundUniqueInput
    AND?: ReorderRuleWhereInput | ReorderRuleWhereInput[]
    OR?: ReorderRuleWhereInput[]
    NOT?: ReorderRuleWhereInput | ReorderRuleWhereInput[]
    productId?: IntFilter<"ReorderRule"> | number
    warehouseId?: IntFilter<"ReorderRule"> | number
    minQty?: DecimalFilter<"ReorderRule"> | Decimal | DecimalJsLike | number | string
    maxQty?: DecimalNullableFilter<"ReorderRule"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ReorderRule"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
  }, "id" | "productId_warehouseId">

  export type ReorderRuleOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    minQty?: SortOrder
    maxQty?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ReorderRuleCountOrderByAggregateInput
    _avg?: ReorderRuleAvgOrderByAggregateInput
    _max?: ReorderRuleMaxOrderByAggregateInput
    _min?: ReorderRuleMinOrderByAggregateInput
    _sum?: ReorderRuleSumOrderByAggregateInput
  }

  export type ReorderRuleScalarWhereWithAggregatesInput = {
    AND?: ReorderRuleScalarWhereWithAggregatesInput | ReorderRuleScalarWhereWithAggregatesInput[]
    OR?: ReorderRuleScalarWhereWithAggregatesInput[]
    NOT?: ReorderRuleScalarWhereWithAggregatesInput | ReorderRuleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReorderRule"> | number
    productId?: IntWithAggregatesFilter<"ReorderRule"> | number
    warehouseId?: IntWithAggregatesFilter<"ReorderRule"> | number
    minQty?: DecimalWithAggregatesFilter<"ReorderRule"> | Decimal | DecimalJsLike | number | string
    maxQty?: DecimalNullableWithAggregatesFilter<"ReorderRule"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ReorderRule"> | Date | string
  }

  export type WarehouseWhereInput = {
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    id?: IntFilter<"Warehouse"> | number
    code?: StringFilter<"Warehouse"> | string
    name?: StringFilter<"Warehouse"> | string
    address?: StringNullableFilter<"Warehouse"> | string | null
    phone?: StringNullableFilter<"Warehouse"> | string | null
    createdAt?: DateTimeFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeFilter<"Warehouse"> | Date | string
    locations?: LocationListRelationFilter
    stockQuants?: StockQuantListRelationFilter
    receipts?: ReceiptListRelationFilter
    deliveries?: DeliveryListRelationFilter
    transfersFrom?: TransferListRelationFilter
    transfersTo?: TransferListRelationFilter
    adjustments?: AdjustmentListRelationFilter
    stockMovesFrom?: StockMoveListRelationFilter
    stockMovesTo?: StockMoveListRelationFilter
    reorderRules?: ReorderRuleListRelationFilter
  }

  export type WarehouseOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locations?: LocationOrderByRelationAggregateInput
    stockQuants?: StockQuantOrderByRelationAggregateInput
    receipts?: ReceiptOrderByRelationAggregateInput
    deliveries?: DeliveryOrderByRelationAggregateInput
    transfersFrom?: TransferOrderByRelationAggregateInput
    transfersTo?: TransferOrderByRelationAggregateInput
    adjustments?: AdjustmentOrderByRelationAggregateInput
    stockMovesFrom?: StockMoveOrderByRelationAggregateInput
    stockMovesTo?: StockMoveOrderByRelationAggregateInput
    reorderRules?: ReorderRuleOrderByRelationAggregateInput
  }

  export type WarehouseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    name?: StringFilter<"Warehouse"> | string
    address?: StringNullableFilter<"Warehouse"> | string | null
    phone?: StringNullableFilter<"Warehouse"> | string | null
    createdAt?: DateTimeFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeFilter<"Warehouse"> | Date | string
    locations?: LocationListRelationFilter
    stockQuants?: StockQuantListRelationFilter
    receipts?: ReceiptListRelationFilter
    deliveries?: DeliveryListRelationFilter
    transfersFrom?: TransferListRelationFilter
    transfersTo?: TransferListRelationFilter
    adjustments?: AdjustmentListRelationFilter
    stockMovesFrom?: StockMoveListRelationFilter
    stockMovesTo?: StockMoveListRelationFilter
    reorderRules?: ReorderRuleListRelationFilter
  }, "id" | "code">

  export type WarehouseOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WarehouseCountOrderByAggregateInput
    _avg?: WarehouseAvgOrderByAggregateInput
    _max?: WarehouseMaxOrderByAggregateInput
    _min?: WarehouseMinOrderByAggregateInput
    _sum?: WarehouseSumOrderByAggregateInput
  }

  export type WarehouseScalarWhereWithAggregatesInput = {
    AND?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    OR?: WarehouseScalarWhereWithAggregatesInput[]
    NOT?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Warehouse"> | number
    code?: StringWithAggregatesFilter<"Warehouse"> | string
    name?: StringWithAggregatesFilter<"Warehouse"> | string
    address?: StringNullableWithAggregatesFilter<"Warehouse"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Warehouse"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Warehouse"> | Date | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: IntFilter<"Location"> | number
    code?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    warehouseId?: IntFilter<"Location"> | number
    parentId?: IntNullableFilter<"Location"> | number | null
    isActive?: BoolFilter<"Location"> | boolean
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    stockQuants?: StockQuantListRelationFilter
    stockMovesFrom?: StockMoveListRelationFilter
    stockMovesTo?: StockMoveListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    warehouseId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    warehouse?: WarehouseOrderByWithRelationInput
    stockQuants?: StockQuantOrderByRelationAggregateInput
    stockMovesFrom?: StockMoveOrderByRelationAggregateInput
    stockMovesTo?: StockMoveOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code_warehouseId?: LocationCodeWarehouseIdCompoundUniqueInput
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    code?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    warehouseId?: IntFilter<"Location"> | number
    parentId?: IntNullableFilter<"Location"> | number | null
    isActive?: BoolFilter<"Location"> | boolean
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    stockQuants?: StockQuantListRelationFilter
    stockMovesFrom?: StockMoveListRelationFilter
    stockMovesTo?: StockMoveListRelationFilter
  }, "id" | "code_warehouseId">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    warehouseId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Location"> | number
    code?: StringWithAggregatesFilter<"Location"> | string
    name?: StringWithAggregatesFilter<"Location"> | string
    warehouseId?: IntWithAggregatesFilter<"Location"> | number
    parentId?: IntNullableWithAggregatesFilter<"Location"> | number | null
    isActive?: BoolWithAggregatesFilter<"Location"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
  }

  export type StockQuantWhereInput = {
    AND?: StockQuantWhereInput | StockQuantWhereInput[]
    OR?: StockQuantWhereInput[]
    NOT?: StockQuantWhereInput | StockQuantWhereInput[]
    id?: IntFilter<"StockQuant"> | number
    productId?: IntFilter<"StockQuant"> | number
    warehouseId?: IntFilter<"StockQuant"> | number
    locationId?: IntNullableFilter<"StockQuant"> | number | null
    quantity?: DecimalFilter<"StockQuant"> | Decimal | DecimalJsLike | number | string
    reserved?: DecimalFilter<"StockQuant"> | Decimal | DecimalJsLike | number | string
    incoming?: DecimalFilter<"StockQuant"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"StockQuant"> | Date | string
    updatedAt?: DateTimeFilter<"StockQuant"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
  }

  export type StockQuantOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    locationId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    reserved?: SortOrder
    incoming?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
  }

  export type StockQuantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    productId_warehouseId_locationId?: StockQuantProductIdWarehouseIdLocationIdCompoundUniqueInput
    AND?: StockQuantWhereInput | StockQuantWhereInput[]
    OR?: StockQuantWhereInput[]
    NOT?: StockQuantWhereInput | StockQuantWhereInput[]
    productId?: IntFilter<"StockQuant"> | number
    warehouseId?: IntFilter<"StockQuant"> | number
    locationId?: IntNullableFilter<"StockQuant"> | number | null
    quantity?: DecimalFilter<"StockQuant"> | Decimal | DecimalJsLike | number | string
    reserved?: DecimalFilter<"StockQuant"> | Decimal | DecimalJsLike | number | string
    incoming?: DecimalFilter<"StockQuant"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"StockQuant"> | Date | string
    updatedAt?: DateTimeFilter<"StockQuant"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
  }, "id" | "productId_warehouseId_locationId">

  export type StockQuantOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    locationId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    reserved?: SortOrder
    incoming?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StockQuantCountOrderByAggregateInput
    _avg?: StockQuantAvgOrderByAggregateInput
    _max?: StockQuantMaxOrderByAggregateInput
    _min?: StockQuantMinOrderByAggregateInput
    _sum?: StockQuantSumOrderByAggregateInput
  }

  export type StockQuantScalarWhereWithAggregatesInput = {
    AND?: StockQuantScalarWhereWithAggregatesInput | StockQuantScalarWhereWithAggregatesInput[]
    OR?: StockQuantScalarWhereWithAggregatesInput[]
    NOT?: StockQuantScalarWhereWithAggregatesInput | StockQuantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StockQuant"> | number
    productId?: IntWithAggregatesFilter<"StockQuant"> | number
    warehouseId?: IntWithAggregatesFilter<"StockQuant"> | number
    locationId?: IntNullableWithAggregatesFilter<"StockQuant"> | number | null
    quantity?: DecimalWithAggregatesFilter<"StockQuant"> | Decimal | DecimalJsLike | number | string
    reserved?: DecimalWithAggregatesFilter<"StockQuant"> | Decimal | DecimalJsLike | number | string
    incoming?: DecimalWithAggregatesFilter<"StockQuant"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"StockQuant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StockQuant"> | Date | string
  }

  export type ReceiptWhereInput = {
    AND?: ReceiptWhereInput | ReceiptWhereInput[]
    OR?: ReceiptWhereInput[]
    NOT?: ReceiptWhereInput | ReceiptWhereInput[]
    id?: IntFilter<"Receipt"> | number
    receiptNo?: StringFilter<"Receipt"> | string
    reference?: StringNullableFilter<"Receipt"> | string | null
    warehouseId?: IntFilter<"Receipt"> | number
    partner?: StringNullableFilter<"Receipt"> | string | null
    status?: EnumDocumentStatusFilter<"Receipt"> | $Enums.DocumentStatus
    createdById?: IntNullableFilter<"Receipt"> | number | null
    createdAt?: DateTimeFilter<"Receipt"> | Date | string
    updatedAt?: DateTimeFilter<"Receipt"> | Date | string
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    lines?: ReceiptLineListRelationFilter
  }

  export type ReceiptOrderByWithRelationInput = {
    id?: SortOrder
    receiptNo?: SortOrder
    reference?: SortOrderInput | SortOrder
    warehouseId?: SortOrder
    partner?: SortOrderInput | SortOrder
    status?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    warehouse?: WarehouseOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    lines?: ReceiptLineOrderByRelationAggregateInput
  }

  export type ReceiptWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    receiptNo?: string
    AND?: ReceiptWhereInput | ReceiptWhereInput[]
    OR?: ReceiptWhereInput[]
    NOT?: ReceiptWhereInput | ReceiptWhereInput[]
    reference?: StringNullableFilter<"Receipt"> | string | null
    warehouseId?: IntFilter<"Receipt"> | number
    partner?: StringNullableFilter<"Receipt"> | string | null
    status?: EnumDocumentStatusFilter<"Receipt"> | $Enums.DocumentStatus
    createdById?: IntNullableFilter<"Receipt"> | number | null
    createdAt?: DateTimeFilter<"Receipt"> | Date | string
    updatedAt?: DateTimeFilter<"Receipt"> | Date | string
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    lines?: ReceiptLineListRelationFilter
  }, "id" | "receiptNo">

  export type ReceiptOrderByWithAggregationInput = {
    id?: SortOrder
    receiptNo?: SortOrder
    reference?: SortOrderInput | SortOrder
    warehouseId?: SortOrder
    partner?: SortOrderInput | SortOrder
    status?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReceiptCountOrderByAggregateInput
    _avg?: ReceiptAvgOrderByAggregateInput
    _max?: ReceiptMaxOrderByAggregateInput
    _min?: ReceiptMinOrderByAggregateInput
    _sum?: ReceiptSumOrderByAggregateInput
  }

  export type ReceiptScalarWhereWithAggregatesInput = {
    AND?: ReceiptScalarWhereWithAggregatesInput | ReceiptScalarWhereWithAggregatesInput[]
    OR?: ReceiptScalarWhereWithAggregatesInput[]
    NOT?: ReceiptScalarWhereWithAggregatesInput | ReceiptScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Receipt"> | number
    receiptNo?: StringWithAggregatesFilter<"Receipt"> | string
    reference?: StringNullableWithAggregatesFilter<"Receipt"> | string | null
    warehouseId?: IntWithAggregatesFilter<"Receipt"> | number
    partner?: StringNullableWithAggregatesFilter<"Receipt"> | string | null
    status?: EnumDocumentStatusWithAggregatesFilter<"Receipt"> | $Enums.DocumentStatus
    createdById?: IntNullableWithAggregatesFilter<"Receipt"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Receipt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Receipt"> | Date | string
  }

  export type ReceiptLineWhereInput = {
    AND?: ReceiptLineWhereInput | ReceiptLineWhereInput[]
    OR?: ReceiptLineWhereInput[]
    NOT?: ReceiptLineWhereInput | ReceiptLineWhereInput[]
    id?: IntFilter<"ReceiptLine"> | number
    receiptId?: IntFilter<"ReceiptLine"> | number
    productId?: IntFilter<"ReceiptLine"> | number
    quantity?: DecimalFilter<"ReceiptLine"> | Decimal | DecimalJsLike | number | string
    uom?: StringFilter<"ReceiptLine"> | string
    unitPrice?: DecimalNullableFilter<"ReceiptLine"> | Decimal | DecimalJsLike | number | string | null
    receipt?: XOR<ReceiptScalarRelationFilter, ReceiptWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ReceiptLineOrderByWithRelationInput = {
    id?: SortOrder
    receiptId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
    unitPrice?: SortOrderInput | SortOrder
    receipt?: ReceiptOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type ReceiptLineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReceiptLineWhereInput | ReceiptLineWhereInput[]
    OR?: ReceiptLineWhereInput[]
    NOT?: ReceiptLineWhereInput | ReceiptLineWhereInput[]
    receiptId?: IntFilter<"ReceiptLine"> | number
    productId?: IntFilter<"ReceiptLine"> | number
    quantity?: DecimalFilter<"ReceiptLine"> | Decimal | DecimalJsLike | number | string
    uom?: StringFilter<"ReceiptLine"> | string
    unitPrice?: DecimalNullableFilter<"ReceiptLine"> | Decimal | DecimalJsLike | number | string | null
    receipt?: XOR<ReceiptScalarRelationFilter, ReceiptWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ReceiptLineOrderByWithAggregationInput = {
    id?: SortOrder
    receiptId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
    unitPrice?: SortOrderInput | SortOrder
    _count?: ReceiptLineCountOrderByAggregateInput
    _avg?: ReceiptLineAvgOrderByAggregateInput
    _max?: ReceiptLineMaxOrderByAggregateInput
    _min?: ReceiptLineMinOrderByAggregateInput
    _sum?: ReceiptLineSumOrderByAggregateInput
  }

  export type ReceiptLineScalarWhereWithAggregatesInput = {
    AND?: ReceiptLineScalarWhereWithAggregatesInput | ReceiptLineScalarWhereWithAggregatesInput[]
    OR?: ReceiptLineScalarWhereWithAggregatesInput[]
    NOT?: ReceiptLineScalarWhereWithAggregatesInput | ReceiptLineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReceiptLine"> | number
    receiptId?: IntWithAggregatesFilter<"ReceiptLine"> | number
    productId?: IntWithAggregatesFilter<"ReceiptLine"> | number
    quantity?: DecimalWithAggregatesFilter<"ReceiptLine"> | Decimal | DecimalJsLike | number | string
    uom?: StringWithAggregatesFilter<"ReceiptLine"> | string
    unitPrice?: DecimalNullableWithAggregatesFilter<"ReceiptLine"> | Decimal | DecimalJsLike | number | string | null
  }

  export type DeliveryWhereInput = {
    AND?: DeliveryWhereInput | DeliveryWhereInput[]
    OR?: DeliveryWhereInput[]
    NOT?: DeliveryWhereInput | DeliveryWhereInput[]
    id?: IntFilter<"Delivery"> | number
    deliveryNo?: StringFilter<"Delivery"> | string
    reference?: StringNullableFilter<"Delivery"> | string | null
    warehouseId?: IntFilter<"Delivery"> | number
    partner?: StringNullableFilter<"Delivery"> | string | null
    status?: EnumDocumentStatusFilter<"Delivery"> | $Enums.DocumentStatus
    createdById?: IntNullableFilter<"Delivery"> | number | null
    createdAt?: DateTimeFilter<"Delivery"> | Date | string
    updatedAt?: DateTimeFilter<"Delivery"> | Date | string
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    lines?: DeliveryLineListRelationFilter
  }

  export type DeliveryOrderByWithRelationInput = {
    id?: SortOrder
    deliveryNo?: SortOrder
    reference?: SortOrderInput | SortOrder
    warehouseId?: SortOrder
    partner?: SortOrderInput | SortOrder
    status?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    warehouse?: WarehouseOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    lines?: DeliveryLineOrderByRelationAggregateInput
  }

  export type DeliveryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    deliveryNo?: string
    AND?: DeliveryWhereInput | DeliveryWhereInput[]
    OR?: DeliveryWhereInput[]
    NOT?: DeliveryWhereInput | DeliveryWhereInput[]
    reference?: StringNullableFilter<"Delivery"> | string | null
    warehouseId?: IntFilter<"Delivery"> | number
    partner?: StringNullableFilter<"Delivery"> | string | null
    status?: EnumDocumentStatusFilter<"Delivery"> | $Enums.DocumentStatus
    createdById?: IntNullableFilter<"Delivery"> | number | null
    createdAt?: DateTimeFilter<"Delivery"> | Date | string
    updatedAt?: DateTimeFilter<"Delivery"> | Date | string
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    lines?: DeliveryLineListRelationFilter
  }, "id" | "deliveryNo">

  export type DeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    deliveryNo?: SortOrder
    reference?: SortOrderInput | SortOrder
    warehouseId?: SortOrder
    partner?: SortOrderInput | SortOrder
    status?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeliveryCountOrderByAggregateInput
    _avg?: DeliveryAvgOrderByAggregateInput
    _max?: DeliveryMaxOrderByAggregateInput
    _min?: DeliveryMinOrderByAggregateInput
    _sum?: DeliverySumOrderByAggregateInput
  }

  export type DeliveryScalarWhereWithAggregatesInput = {
    AND?: DeliveryScalarWhereWithAggregatesInput | DeliveryScalarWhereWithAggregatesInput[]
    OR?: DeliveryScalarWhereWithAggregatesInput[]
    NOT?: DeliveryScalarWhereWithAggregatesInput | DeliveryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Delivery"> | number
    deliveryNo?: StringWithAggregatesFilter<"Delivery"> | string
    reference?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    warehouseId?: IntWithAggregatesFilter<"Delivery"> | number
    partner?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    status?: EnumDocumentStatusWithAggregatesFilter<"Delivery"> | $Enums.DocumentStatus
    createdById?: IntNullableWithAggregatesFilter<"Delivery"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Delivery"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Delivery"> | Date | string
  }

  export type DeliveryLineWhereInput = {
    AND?: DeliveryLineWhereInput | DeliveryLineWhereInput[]
    OR?: DeliveryLineWhereInput[]
    NOT?: DeliveryLineWhereInput | DeliveryLineWhereInput[]
    id?: IntFilter<"DeliveryLine"> | number
    deliveryId?: IntFilter<"DeliveryLine"> | number
    productId?: IntFilter<"DeliveryLine"> | number
    quantity?: DecimalFilter<"DeliveryLine"> | Decimal | DecimalJsLike | number | string
    uom?: StringFilter<"DeliveryLine"> | string
    unitPrice?: DecimalNullableFilter<"DeliveryLine"> | Decimal | DecimalJsLike | number | string | null
    delivery?: XOR<DeliveryScalarRelationFilter, DeliveryWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type DeliveryLineOrderByWithRelationInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
    unitPrice?: SortOrderInput | SortOrder
    delivery?: DeliveryOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type DeliveryLineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeliveryLineWhereInput | DeliveryLineWhereInput[]
    OR?: DeliveryLineWhereInput[]
    NOT?: DeliveryLineWhereInput | DeliveryLineWhereInput[]
    deliveryId?: IntFilter<"DeliveryLine"> | number
    productId?: IntFilter<"DeliveryLine"> | number
    quantity?: DecimalFilter<"DeliveryLine"> | Decimal | DecimalJsLike | number | string
    uom?: StringFilter<"DeliveryLine"> | string
    unitPrice?: DecimalNullableFilter<"DeliveryLine"> | Decimal | DecimalJsLike | number | string | null
    delivery?: XOR<DeliveryScalarRelationFilter, DeliveryWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type DeliveryLineOrderByWithAggregationInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
    unitPrice?: SortOrderInput | SortOrder
    _count?: DeliveryLineCountOrderByAggregateInput
    _avg?: DeliveryLineAvgOrderByAggregateInput
    _max?: DeliveryLineMaxOrderByAggregateInput
    _min?: DeliveryLineMinOrderByAggregateInput
    _sum?: DeliveryLineSumOrderByAggregateInput
  }

  export type DeliveryLineScalarWhereWithAggregatesInput = {
    AND?: DeliveryLineScalarWhereWithAggregatesInput | DeliveryLineScalarWhereWithAggregatesInput[]
    OR?: DeliveryLineScalarWhereWithAggregatesInput[]
    NOT?: DeliveryLineScalarWhereWithAggregatesInput | DeliveryLineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeliveryLine"> | number
    deliveryId?: IntWithAggregatesFilter<"DeliveryLine"> | number
    productId?: IntWithAggregatesFilter<"DeliveryLine"> | number
    quantity?: DecimalWithAggregatesFilter<"DeliveryLine"> | Decimal | DecimalJsLike | number | string
    uom?: StringWithAggregatesFilter<"DeliveryLine"> | string
    unitPrice?: DecimalNullableWithAggregatesFilter<"DeliveryLine"> | Decimal | DecimalJsLike | number | string | null
  }

  export type TransferWhereInput = {
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    id?: IntFilter<"Transfer"> | number
    transferNo?: StringFilter<"Transfer"> | string
    reference?: StringNullableFilter<"Transfer"> | string | null
    fromWarehouseId?: IntFilter<"Transfer"> | number
    toWarehouseId?: IntFilter<"Transfer"> | number
    status?: EnumDocumentStatusFilter<"Transfer"> | $Enums.DocumentStatus
    createdById?: IntNullableFilter<"Transfer"> | number | null
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeFilter<"Transfer"> | Date | string
    fromWarehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    toWarehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    lines?: TransferLineListRelationFilter
  }

  export type TransferOrderByWithRelationInput = {
    id?: SortOrder
    transferNo?: SortOrder
    reference?: SortOrderInput | SortOrder
    fromWarehouseId?: SortOrder
    toWarehouseId?: SortOrder
    status?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fromWarehouse?: WarehouseOrderByWithRelationInput
    toWarehouse?: WarehouseOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    lines?: TransferLineOrderByRelationAggregateInput
  }

  export type TransferWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    transferNo?: string
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    reference?: StringNullableFilter<"Transfer"> | string | null
    fromWarehouseId?: IntFilter<"Transfer"> | number
    toWarehouseId?: IntFilter<"Transfer"> | number
    status?: EnumDocumentStatusFilter<"Transfer"> | $Enums.DocumentStatus
    createdById?: IntNullableFilter<"Transfer"> | number | null
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeFilter<"Transfer"> | Date | string
    fromWarehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    toWarehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    lines?: TransferLineListRelationFilter
  }, "id" | "transferNo">

  export type TransferOrderByWithAggregationInput = {
    id?: SortOrder
    transferNo?: SortOrder
    reference?: SortOrderInput | SortOrder
    fromWarehouseId?: SortOrder
    toWarehouseId?: SortOrder
    status?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransferCountOrderByAggregateInput
    _avg?: TransferAvgOrderByAggregateInput
    _max?: TransferMaxOrderByAggregateInput
    _min?: TransferMinOrderByAggregateInput
    _sum?: TransferSumOrderByAggregateInput
  }

  export type TransferScalarWhereWithAggregatesInput = {
    AND?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    OR?: TransferScalarWhereWithAggregatesInput[]
    NOT?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transfer"> | number
    transferNo?: StringWithAggregatesFilter<"Transfer"> | string
    reference?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    fromWarehouseId?: IntWithAggregatesFilter<"Transfer"> | number
    toWarehouseId?: IntWithAggregatesFilter<"Transfer"> | number
    status?: EnumDocumentStatusWithAggregatesFilter<"Transfer"> | $Enums.DocumentStatus
    createdById?: IntNullableWithAggregatesFilter<"Transfer"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
  }

  export type TransferLineWhereInput = {
    AND?: TransferLineWhereInput | TransferLineWhereInput[]
    OR?: TransferLineWhereInput[]
    NOT?: TransferLineWhereInput | TransferLineWhereInput[]
    id?: IntFilter<"TransferLine"> | number
    transferId?: IntFilter<"TransferLine"> | number
    productId?: IntFilter<"TransferLine"> | number
    quantity?: DecimalFilter<"TransferLine"> | Decimal | DecimalJsLike | number | string
    uom?: StringFilter<"TransferLine"> | string
    transfer?: XOR<TransferScalarRelationFilter, TransferWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type TransferLineOrderByWithRelationInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
    transfer?: TransferOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type TransferLineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransferLineWhereInput | TransferLineWhereInput[]
    OR?: TransferLineWhereInput[]
    NOT?: TransferLineWhereInput | TransferLineWhereInput[]
    transferId?: IntFilter<"TransferLine"> | number
    productId?: IntFilter<"TransferLine"> | number
    quantity?: DecimalFilter<"TransferLine"> | Decimal | DecimalJsLike | number | string
    uom?: StringFilter<"TransferLine"> | string
    transfer?: XOR<TransferScalarRelationFilter, TransferWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type TransferLineOrderByWithAggregationInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
    _count?: TransferLineCountOrderByAggregateInput
    _avg?: TransferLineAvgOrderByAggregateInput
    _max?: TransferLineMaxOrderByAggregateInput
    _min?: TransferLineMinOrderByAggregateInput
    _sum?: TransferLineSumOrderByAggregateInput
  }

  export type TransferLineScalarWhereWithAggregatesInput = {
    AND?: TransferLineScalarWhereWithAggregatesInput | TransferLineScalarWhereWithAggregatesInput[]
    OR?: TransferLineScalarWhereWithAggregatesInput[]
    NOT?: TransferLineScalarWhereWithAggregatesInput | TransferLineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TransferLine"> | number
    transferId?: IntWithAggregatesFilter<"TransferLine"> | number
    productId?: IntWithAggregatesFilter<"TransferLine"> | number
    quantity?: DecimalWithAggregatesFilter<"TransferLine"> | Decimal | DecimalJsLike | number | string
    uom?: StringWithAggregatesFilter<"TransferLine"> | string
  }

  export type AdjustmentWhereInput = {
    AND?: AdjustmentWhereInput | AdjustmentWhereInput[]
    OR?: AdjustmentWhereInput[]
    NOT?: AdjustmentWhereInput | AdjustmentWhereInput[]
    id?: IntFilter<"Adjustment"> | number
    adjustmentNo?: StringFilter<"Adjustment"> | string
    warehouseId?: IntFilter<"Adjustment"> | number
    reason?: StringNullableFilter<"Adjustment"> | string | null
    status?: EnumDocumentStatusFilter<"Adjustment"> | $Enums.DocumentStatus
    createdById?: IntNullableFilter<"Adjustment"> | number | null
    createdAt?: DateTimeFilter<"Adjustment"> | Date | string
    updatedAt?: DateTimeFilter<"Adjustment"> | Date | string
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    lines?: AdjustmentLineListRelationFilter
  }

  export type AdjustmentOrderByWithRelationInput = {
    id?: SortOrder
    adjustmentNo?: SortOrder
    warehouseId?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    warehouse?: WarehouseOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    lines?: AdjustmentLineOrderByRelationAggregateInput
  }

  export type AdjustmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    adjustmentNo?: string
    AND?: AdjustmentWhereInput | AdjustmentWhereInput[]
    OR?: AdjustmentWhereInput[]
    NOT?: AdjustmentWhereInput | AdjustmentWhereInput[]
    warehouseId?: IntFilter<"Adjustment"> | number
    reason?: StringNullableFilter<"Adjustment"> | string | null
    status?: EnumDocumentStatusFilter<"Adjustment"> | $Enums.DocumentStatus
    createdById?: IntNullableFilter<"Adjustment"> | number | null
    createdAt?: DateTimeFilter<"Adjustment"> | Date | string
    updatedAt?: DateTimeFilter<"Adjustment"> | Date | string
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    lines?: AdjustmentLineListRelationFilter
  }, "id" | "adjustmentNo">

  export type AdjustmentOrderByWithAggregationInput = {
    id?: SortOrder
    adjustmentNo?: SortOrder
    warehouseId?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdjustmentCountOrderByAggregateInput
    _avg?: AdjustmentAvgOrderByAggregateInput
    _max?: AdjustmentMaxOrderByAggregateInput
    _min?: AdjustmentMinOrderByAggregateInput
    _sum?: AdjustmentSumOrderByAggregateInput
  }

  export type AdjustmentScalarWhereWithAggregatesInput = {
    AND?: AdjustmentScalarWhereWithAggregatesInput | AdjustmentScalarWhereWithAggregatesInput[]
    OR?: AdjustmentScalarWhereWithAggregatesInput[]
    NOT?: AdjustmentScalarWhereWithAggregatesInput | AdjustmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Adjustment"> | number
    adjustmentNo?: StringWithAggregatesFilter<"Adjustment"> | string
    warehouseId?: IntWithAggregatesFilter<"Adjustment"> | number
    reason?: StringNullableWithAggregatesFilter<"Adjustment"> | string | null
    status?: EnumDocumentStatusWithAggregatesFilter<"Adjustment"> | $Enums.DocumentStatus
    createdById?: IntNullableWithAggregatesFilter<"Adjustment"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Adjustment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Adjustment"> | Date | string
  }

  export type AdjustmentLineWhereInput = {
    AND?: AdjustmentLineWhereInput | AdjustmentLineWhereInput[]
    OR?: AdjustmentLineWhereInput[]
    NOT?: AdjustmentLineWhereInput | AdjustmentLineWhereInput[]
    id?: IntFilter<"AdjustmentLine"> | number
    adjustmentId?: IntFilter<"AdjustmentLine"> | number
    productId?: IntFilter<"AdjustmentLine"> | number
    quantity?: DecimalFilter<"AdjustmentLine"> | Decimal | DecimalJsLike | number | string
    uom?: StringFilter<"AdjustmentLine"> | string
    note?: StringNullableFilter<"AdjustmentLine"> | string | null
    adjustment?: XOR<AdjustmentScalarRelationFilter, AdjustmentWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type AdjustmentLineOrderByWithRelationInput = {
    id?: SortOrder
    adjustmentId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
    note?: SortOrderInput | SortOrder
    adjustment?: AdjustmentOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type AdjustmentLineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AdjustmentLineWhereInput | AdjustmentLineWhereInput[]
    OR?: AdjustmentLineWhereInput[]
    NOT?: AdjustmentLineWhereInput | AdjustmentLineWhereInput[]
    adjustmentId?: IntFilter<"AdjustmentLine"> | number
    productId?: IntFilter<"AdjustmentLine"> | number
    quantity?: DecimalFilter<"AdjustmentLine"> | Decimal | DecimalJsLike | number | string
    uom?: StringFilter<"AdjustmentLine"> | string
    note?: StringNullableFilter<"AdjustmentLine"> | string | null
    adjustment?: XOR<AdjustmentScalarRelationFilter, AdjustmentWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type AdjustmentLineOrderByWithAggregationInput = {
    id?: SortOrder
    adjustmentId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
    note?: SortOrderInput | SortOrder
    _count?: AdjustmentLineCountOrderByAggregateInput
    _avg?: AdjustmentLineAvgOrderByAggregateInput
    _max?: AdjustmentLineMaxOrderByAggregateInput
    _min?: AdjustmentLineMinOrderByAggregateInput
    _sum?: AdjustmentLineSumOrderByAggregateInput
  }

  export type AdjustmentLineScalarWhereWithAggregatesInput = {
    AND?: AdjustmentLineScalarWhereWithAggregatesInput | AdjustmentLineScalarWhereWithAggregatesInput[]
    OR?: AdjustmentLineScalarWhereWithAggregatesInput[]
    NOT?: AdjustmentLineScalarWhereWithAggregatesInput | AdjustmentLineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AdjustmentLine"> | number
    adjustmentId?: IntWithAggregatesFilter<"AdjustmentLine"> | number
    productId?: IntWithAggregatesFilter<"AdjustmentLine"> | number
    quantity?: DecimalWithAggregatesFilter<"AdjustmentLine"> | Decimal | DecimalJsLike | number | string
    uom?: StringWithAggregatesFilter<"AdjustmentLine"> | string
    note?: StringNullableWithAggregatesFilter<"AdjustmentLine"> | string | null
  }

  export type StockMoveWhereInput = {
    AND?: StockMoveWhereInput | StockMoveWhereInput[]
    OR?: StockMoveWhereInput[]
    NOT?: StockMoveWhereInput | StockMoveWhereInput[]
    id?: IntFilter<"StockMove"> | number
    moveNo?: StringNullableFilter<"StockMove"> | string | null
    productId?: IntFilter<"StockMove"> | number
    quantity?: DecimalFilter<"StockMove"> | Decimal | DecimalJsLike | number | string
    uom?: StringFilter<"StockMove"> | string
    fromWarehouseId?: IntNullableFilter<"StockMove"> | number | null
    toWarehouseId?: IntNullableFilter<"StockMove"> | number | null
    fromLocationId?: IntNullableFilter<"StockMove"> | number | null
    toLocationId?: IntNullableFilter<"StockMove"> | number | null
    reason?: StringNullableFilter<"StockMove"> | string | null
    reference?: StringNullableFilter<"StockMove"> | string | null
    documentType?: StringNullableFilter<"StockMove"> | string | null
    documentId?: IntNullableFilter<"StockMove"> | number | null
    status?: EnumDocumentStatusFilter<"StockMove"> | $Enums.DocumentStatus
    createdById?: IntNullableFilter<"StockMove"> | number | null
    createdAt?: DateTimeFilter<"StockMove"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    fromWarehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    toWarehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    fromLocation?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    toLocation?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type StockMoveOrderByWithRelationInput = {
    id?: SortOrder
    moveNo?: SortOrderInput | SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
    fromWarehouseId?: SortOrderInput | SortOrder
    toWarehouseId?: SortOrderInput | SortOrder
    fromLocationId?: SortOrderInput | SortOrder
    toLocationId?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    documentType?: SortOrderInput | SortOrder
    documentId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    fromWarehouse?: WarehouseOrderByWithRelationInput
    toWarehouse?: WarehouseOrderByWithRelationInput
    fromLocation?: LocationOrderByWithRelationInput
    toLocation?: LocationOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type StockMoveWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    moveNo?: string
    AND?: StockMoveWhereInput | StockMoveWhereInput[]
    OR?: StockMoveWhereInput[]
    NOT?: StockMoveWhereInput | StockMoveWhereInput[]
    productId?: IntFilter<"StockMove"> | number
    quantity?: DecimalFilter<"StockMove"> | Decimal | DecimalJsLike | number | string
    uom?: StringFilter<"StockMove"> | string
    fromWarehouseId?: IntNullableFilter<"StockMove"> | number | null
    toWarehouseId?: IntNullableFilter<"StockMove"> | number | null
    fromLocationId?: IntNullableFilter<"StockMove"> | number | null
    toLocationId?: IntNullableFilter<"StockMove"> | number | null
    reason?: StringNullableFilter<"StockMove"> | string | null
    reference?: StringNullableFilter<"StockMove"> | string | null
    documentType?: StringNullableFilter<"StockMove"> | string | null
    documentId?: IntNullableFilter<"StockMove"> | number | null
    status?: EnumDocumentStatusFilter<"StockMove"> | $Enums.DocumentStatus
    createdById?: IntNullableFilter<"StockMove"> | number | null
    createdAt?: DateTimeFilter<"StockMove"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    fromWarehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    toWarehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    fromLocation?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    toLocation?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "moveNo">

  export type StockMoveOrderByWithAggregationInput = {
    id?: SortOrder
    moveNo?: SortOrderInput | SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
    fromWarehouseId?: SortOrderInput | SortOrder
    toWarehouseId?: SortOrderInput | SortOrder
    fromLocationId?: SortOrderInput | SortOrder
    toLocationId?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    documentType?: SortOrderInput | SortOrder
    documentId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StockMoveCountOrderByAggregateInput
    _avg?: StockMoveAvgOrderByAggregateInput
    _max?: StockMoveMaxOrderByAggregateInput
    _min?: StockMoveMinOrderByAggregateInput
    _sum?: StockMoveSumOrderByAggregateInput
  }

  export type StockMoveScalarWhereWithAggregatesInput = {
    AND?: StockMoveScalarWhereWithAggregatesInput | StockMoveScalarWhereWithAggregatesInput[]
    OR?: StockMoveScalarWhereWithAggregatesInput[]
    NOT?: StockMoveScalarWhereWithAggregatesInput | StockMoveScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StockMove"> | number
    moveNo?: StringNullableWithAggregatesFilter<"StockMove"> | string | null
    productId?: IntWithAggregatesFilter<"StockMove"> | number
    quantity?: DecimalWithAggregatesFilter<"StockMove"> | Decimal | DecimalJsLike | number | string
    uom?: StringWithAggregatesFilter<"StockMove"> | string
    fromWarehouseId?: IntNullableWithAggregatesFilter<"StockMove"> | number | null
    toWarehouseId?: IntNullableWithAggregatesFilter<"StockMove"> | number | null
    fromLocationId?: IntNullableWithAggregatesFilter<"StockMove"> | number | null
    toLocationId?: IntNullableWithAggregatesFilter<"StockMove"> | number | null
    reason?: StringNullableWithAggregatesFilter<"StockMove"> | string | null
    reference?: StringNullableWithAggregatesFilter<"StockMove"> | string | null
    documentType?: StringNullableWithAggregatesFilter<"StockMove"> | string | null
    documentId?: IntNullableWithAggregatesFilter<"StockMove"> | number | null
    status?: EnumDocumentStatusWithAggregatesFilter<"StockMove"> | $Enums.DocumentStatus
    createdById?: IntNullableWithAggregatesFilter<"StockMove"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"StockMove"> | Date | string
  }

  export type UserCreateInput = {
    name?: string | null
    email: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    receiptsCreated?: ReceiptCreateNestedManyWithoutCreatedByInput
    deliveriesCreated?: DeliveryCreateNestedManyWithoutCreatedByInput
    transfersCreated?: TransferCreateNestedManyWithoutCreatedByInput
    adjustmentsCreated?: AdjustmentCreateNestedManyWithoutCreatedByInput
    stockMovesCreated?: StockMoveCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name?: string | null
    email: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    receiptsCreated?: ReceiptUncheckedCreateNestedManyWithoutCreatedByInput
    deliveriesCreated?: DeliveryUncheckedCreateNestedManyWithoutCreatedByInput
    transfersCreated?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    adjustmentsCreated?: AdjustmentUncheckedCreateNestedManyWithoutCreatedByInput
    stockMovesCreated?: StockMoveUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptsCreated?: ReceiptUpdateManyWithoutCreatedByNestedInput
    deliveriesCreated?: DeliveryUpdateManyWithoutCreatedByNestedInput
    transfersCreated?: TransferUpdateManyWithoutCreatedByNestedInput
    adjustmentsCreated?: AdjustmentUpdateManyWithoutCreatedByNestedInput
    stockMovesCreated?: StockMoveUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptsCreated?: ReceiptUncheckedUpdateManyWithoutCreatedByNestedInput
    deliveriesCreated?: DeliveryUncheckedUpdateManyWithoutCreatedByNestedInput
    transfersCreated?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    adjustmentsCreated?: AdjustmentUncheckedUpdateManyWithoutCreatedByNestedInput
    stockMovesCreated?: StockMoveUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name?: string | null
    email: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpCreateInput = {
    email: string
    code: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OtpUncheckedCreateInput = {
    id?: number
    email: string
    code: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OtpUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpCreateManyInput = {
    id?: number
    email: string
    code: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OtpUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    sku: string
    name: string
    description?: string | null
    uom: string
    defaultPrice: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockQuants?: StockQuantCreateNestedManyWithoutProductInput
    stockMoves?: StockMoveCreateNestedManyWithoutProductInput
    receiptLines?: ReceiptLineCreateNestedManyWithoutProductInput
    deliveryLines?: DeliveryLineCreateNestedManyWithoutProductInput
    transferLines?: TransferLineCreateNestedManyWithoutProductInput
    adjustmentLines?: AdjustmentLineCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    reorderRules?: ReorderRuleCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    sku: string
    name: string
    description?: string | null
    uom: string
    defaultPrice: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: number | null
    stockQuants?: StockQuantUncheckedCreateNestedManyWithoutProductInput
    stockMoves?: StockMoveUncheckedCreateNestedManyWithoutProductInput
    receiptLines?: ReceiptLineUncheckedCreateNestedManyWithoutProductInput
    deliveryLines?: DeliveryLineUncheckedCreateNestedManyWithoutProductInput
    transferLines?: TransferLineUncheckedCreateNestedManyWithoutProductInput
    adjustmentLines?: AdjustmentLineUncheckedCreateNestedManyWithoutProductInput
    reorderRules?: ReorderRuleUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuants?: StockQuantUpdateManyWithoutProductNestedInput
    stockMoves?: StockMoveUpdateManyWithoutProductNestedInput
    receiptLines?: ReceiptLineUpdateManyWithoutProductNestedInput
    deliveryLines?: DeliveryLineUpdateManyWithoutProductNestedInput
    transferLines?: TransferLineUpdateManyWithoutProductNestedInput
    adjustmentLines?: AdjustmentLineUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    reorderRules?: ReorderRuleUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuants?: StockQuantUncheckedUpdateManyWithoutProductNestedInput
    stockMoves?: StockMoveUncheckedUpdateManyWithoutProductNestedInput
    receiptLines?: ReceiptLineUncheckedUpdateManyWithoutProductNestedInput
    deliveryLines?: DeliveryLineUncheckedUpdateManyWithoutProductNestedInput
    transferLines?: TransferLineUncheckedUpdateManyWithoutProductNestedInput
    adjustmentLines?: AdjustmentLineUncheckedUpdateManyWithoutProductNestedInput
    reorderRules?: ReorderRuleUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    sku: string
    name: string
    description?: string | null
    uom: string
    defaultPrice: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: number | null
  }

  export type ProductUpdateManyMutationInput = {
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CategoryCreateInput = {
    name: string
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    name: string
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    name: string
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReorderRuleCreateInput = {
    minQty: Decimal | DecimalJsLike | number | string
    maxQty?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutReorderRulesInput
    warehouse: WarehouseCreateNestedOneWithoutReorderRulesInput
  }

  export type ReorderRuleUncheckedCreateInput = {
    id?: number
    productId: number
    warehouseId: number
    minQty: Decimal | DecimalJsLike | number | string
    maxQty?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type ReorderRuleUpdateInput = {
    minQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxQty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutReorderRulesNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutReorderRulesNestedInput
  }

  export type ReorderRuleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    minQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxQty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReorderRuleCreateManyInput = {
    id?: number
    productId: number
    warehouseId: number
    minQty: Decimal | DecimalJsLike | number | string
    maxQty?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type ReorderRuleUpdateManyMutationInput = {
    minQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxQty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReorderRuleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    minQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxQty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseCreateInput = {
    code: string
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutWarehouseInput
    stockQuants?: StockQuantCreateNestedManyWithoutWarehouseInput
    receipts?: ReceiptCreateNestedManyWithoutWarehouseInput
    deliveries?: DeliveryCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferCreateNestedManyWithoutToWarehouseInput
    adjustments?: AdjustmentCreateNestedManyWithoutWarehouseInput
    stockMovesFrom?: StockMoveCreateNestedManyWithoutFromWarehouseInput
    stockMovesTo?: StockMoveCreateNestedManyWithoutToWarehouseInput
    reorderRules?: ReorderRuleCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutWarehouseInput
    stockQuants?: StockQuantUncheckedCreateNestedManyWithoutWarehouseInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutWarehouseInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToWarehouseInput
    adjustments?: AdjustmentUncheckedCreateNestedManyWithoutWarehouseInput
    stockMovesFrom?: StockMoveUncheckedCreateNestedManyWithoutFromWarehouseInput
    stockMovesTo?: StockMoveUncheckedCreateNestedManyWithoutToWarehouseInput
    reorderRules?: ReorderRuleUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutWarehouseNestedInput
    stockQuants?: StockQuantUpdateManyWithoutWarehouseNestedInput
    receipts?: ReceiptUpdateManyWithoutWarehouseNestedInput
    deliveries?: DeliveryUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUpdateManyWithoutToWarehouseNestedInput
    adjustments?: AdjustmentUpdateManyWithoutWarehouseNestedInput
    stockMovesFrom?: StockMoveUpdateManyWithoutFromWarehouseNestedInput
    stockMovesTo?: StockMoveUpdateManyWithoutToWarehouseNestedInput
    reorderRules?: ReorderRuleUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutWarehouseNestedInput
    stockQuants?: StockQuantUncheckedUpdateManyWithoutWarehouseNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutWarehouseNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToWarehouseNestedInput
    adjustments?: AdjustmentUncheckedUpdateManyWithoutWarehouseNestedInput
    stockMovesFrom?: StockMoveUncheckedUpdateManyWithoutFromWarehouseNestedInput
    stockMovesTo?: StockMoveUncheckedUpdateManyWithoutToWarehouseNestedInput
    reorderRules?: ReorderRuleUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseCreateManyInput = {
    id?: number
    code: string
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateInput = {
    code: string
    name: string
    parentId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutLocationsInput
    stockQuants?: StockQuantCreateNestedManyWithoutLocationInput
    stockMovesFrom?: StockMoveCreateNestedManyWithoutFromLocationInput
    stockMovesTo?: StockMoveCreateNestedManyWithoutToLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    warehouseId: number
    parentId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockQuants?: StockQuantUncheckedCreateNestedManyWithoutLocationInput
    stockMovesFrom?: StockMoveUncheckedCreateNestedManyWithoutFromLocationInput
    stockMovesTo?: StockMoveUncheckedCreateNestedManyWithoutToLocationInput
  }

  export type LocationUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutLocationsNestedInput
    stockQuants?: StockQuantUpdateManyWithoutLocationNestedInput
    stockMovesFrom?: StockMoveUpdateManyWithoutFromLocationNestedInput
    stockMovesTo?: StockMoveUpdateManyWithoutToLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    warehouseId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuants?: StockQuantUncheckedUpdateManyWithoutLocationNestedInput
    stockMovesFrom?: StockMoveUncheckedUpdateManyWithoutFromLocationNestedInput
    stockMovesTo?: StockMoveUncheckedUpdateManyWithoutToLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: number
    code: string
    name: string
    warehouseId: number
    parentId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    warehouseId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockQuantCreateInput = {
    quantity?: Decimal | DecimalJsLike | number | string
    reserved?: Decimal | DecimalJsLike | number | string
    incoming?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutStockQuantsInput
    warehouse: WarehouseCreateNestedOneWithoutStockQuantsInput
    location?: LocationCreateNestedOneWithoutStockQuantsInput
  }

  export type StockQuantUncheckedCreateInput = {
    id?: number
    productId: number
    warehouseId: number
    locationId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string
    reserved?: Decimal | DecimalJsLike | number | string
    incoming?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockQuantUpdateInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reserved?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incoming?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStockQuantsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutStockQuantsNestedInput
    location?: LocationUpdateOneWithoutStockQuantsNestedInput
  }

  export type StockQuantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reserved?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incoming?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockQuantCreateManyInput = {
    id?: number
    productId: number
    warehouseId: number
    locationId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string
    reserved?: Decimal | DecimalJsLike | number | string
    incoming?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockQuantUpdateManyMutationInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reserved?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incoming?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockQuantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reserved?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incoming?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptCreateInput = {
    receiptNo: string
    reference?: string | null
    partner?: string | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutReceiptsInput
    createdBy?: UserCreateNestedOneWithoutReceiptsCreatedInput
    lines?: ReceiptLineCreateNestedManyWithoutReceiptInput
  }

  export type ReceiptUncheckedCreateInput = {
    id?: number
    receiptNo: string
    reference?: string | null
    warehouseId: number
    partner?: string | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: ReceiptLineUncheckedCreateNestedManyWithoutReceiptInput
  }

  export type ReceiptUpdateInput = {
    receiptNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutReceiptsNestedInput
    createdBy?: UserUpdateOneWithoutReceiptsCreatedNestedInput
    lines?: ReceiptLineUpdateManyWithoutReceiptNestedInput
  }

  export type ReceiptUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: IntFieldUpdateOperationsInput | number
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: ReceiptLineUncheckedUpdateManyWithoutReceiptNestedInput
  }

  export type ReceiptCreateManyInput = {
    id?: number
    receiptNo: string
    reference?: string | null
    warehouseId: number
    partner?: string | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceiptUpdateManyMutationInput = {
    receiptNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: IntFieldUpdateOperationsInput | number
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptLineCreateInput = {
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    receipt: ReceiptCreateNestedOneWithoutLinesInput
    product: ProductCreateNestedOneWithoutReceiptLinesInput
  }

  export type ReceiptLineUncheckedCreateInput = {
    id?: number
    receiptId: number
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
  }

  export type ReceiptLineUpdateInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    receipt?: ReceiptUpdateOneRequiredWithoutLinesNestedInput
    product?: ProductUpdateOneRequiredWithoutReceiptLinesNestedInput
  }

  export type ReceiptLineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ReceiptLineCreateManyInput = {
    id?: number
    receiptId: number
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
  }

  export type ReceiptLineUpdateManyMutationInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ReceiptLineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type DeliveryCreateInput = {
    deliveryNo: string
    reference?: string | null
    partner?: string | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutDeliveriesInput
    createdBy?: UserCreateNestedOneWithoutDeliveriesCreatedInput
    lines?: DeliveryLineCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateInput = {
    id?: number
    deliveryNo: string
    reference?: string | null
    warehouseId: number
    partner?: string | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: DeliveryLineUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUpdateInput = {
    deliveryNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutDeliveriesNestedInput
    createdBy?: UserUpdateOneWithoutDeliveriesCreatedNestedInput
    lines?: DeliveryLineUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    deliveryNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: IntFieldUpdateOperationsInput | number
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: DeliveryLineUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryCreateManyInput = {
    id?: number
    deliveryNo: string
    reference?: string | null
    warehouseId: number
    partner?: string | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryUpdateManyMutationInput = {
    deliveryNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    deliveryNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: IntFieldUpdateOperationsInput | number
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryLineCreateInput = {
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    delivery: DeliveryCreateNestedOneWithoutLinesInput
    product: ProductCreateNestedOneWithoutDeliveryLinesInput
  }

  export type DeliveryLineUncheckedCreateInput = {
    id?: number
    deliveryId: number
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
  }

  export type DeliveryLineUpdateInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery?: DeliveryUpdateOneRequiredWithoutLinesNestedInput
    product?: ProductUpdateOneRequiredWithoutDeliveryLinesNestedInput
  }

  export type DeliveryLineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    deliveryId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type DeliveryLineCreateManyInput = {
    id?: number
    deliveryId: number
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
  }

  export type DeliveryLineUpdateManyMutationInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type DeliveryLineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    deliveryId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type TransferCreateInput = {
    transferNo: string
    reference?: string | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    fromWarehouse: WarehouseCreateNestedOneWithoutTransfersFromInput
    toWarehouse: WarehouseCreateNestedOneWithoutTransfersToInput
    createdBy?: UserCreateNestedOneWithoutTransfersCreatedInput
    lines?: TransferLineCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateInput = {
    id?: number
    transferNo: string
    reference?: string | null
    fromWarehouseId: number
    toWarehouseId: number
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: TransferLineUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferUpdateInput = {
    transferNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromWarehouse?: WarehouseUpdateOneRequiredWithoutTransfersFromNestedInput
    toWarehouse?: WarehouseUpdateOneRequiredWithoutTransfersToNestedInput
    createdBy?: UserUpdateOneWithoutTransfersCreatedNestedInput
    lines?: TransferLineUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transferNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    fromWarehouseId?: IntFieldUpdateOperationsInput | number
    toWarehouseId?: IntFieldUpdateOperationsInput | number
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: TransferLineUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferCreateManyInput = {
    id?: number
    transferNo: string
    reference?: string | null
    fromWarehouseId: number
    toWarehouseId: number
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferUpdateManyMutationInput = {
    transferNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transferNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    fromWarehouseId?: IntFieldUpdateOperationsInput | number
    toWarehouseId?: IntFieldUpdateOperationsInput | number
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferLineCreateInput = {
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    transfer: TransferCreateNestedOneWithoutLinesInput
    product: ProductCreateNestedOneWithoutTransferLinesInput
  }

  export type TransferLineUncheckedCreateInput = {
    id?: number
    transferId: number
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
  }

  export type TransferLineUpdateInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    transfer?: TransferUpdateOneRequiredWithoutLinesNestedInput
    product?: ProductUpdateOneRequiredWithoutTransferLinesNestedInput
  }

  export type TransferLineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transferId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
  }

  export type TransferLineCreateManyInput = {
    id?: number
    transferId: number
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
  }

  export type TransferLineUpdateManyMutationInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
  }

  export type TransferLineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transferId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
  }

  export type AdjustmentCreateInput = {
    adjustmentNo: string
    reason?: string | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutAdjustmentsInput
    createdBy?: UserCreateNestedOneWithoutAdjustmentsCreatedInput
    lines?: AdjustmentLineCreateNestedManyWithoutAdjustmentInput
  }

  export type AdjustmentUncheckedCreateInput = {
    id?: number
    adjustmentNo: string
    warehouseId: number
    reason?: string | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: AdjustmentLineUncheckedCreateNestedManyWithoutAdjustmentInput
  }

  export type AdjustmentUpdateInput = {
    adjustmentNo?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutAdjustmentsNestedInput
    createdBy?: UserUpdateOneWithoutAdjustmentsCreatedNestedInput
    lines?: AdjustmentLineUpdateManyWithoutAdjustmentNestedInput
  }

  export type AdjustmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    adjustmentNo?: StringFieldUpdateOperationsInput | string
    warehouseId?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: AdjustmentLineUncheckedUpdateManyWithoutAdjustmentNestedInput
  }

  export type AdjustmentCreateManyInput = {
    id?: number
    adjustmentNo: string
    warehouseId: number
    reason?: string | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdjustmentUpdateManyMutationInput = {
    adjustmentNo?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdjustmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    adjustmentNo?: StringFieldUpdateOperationsInput | string
    warehouseId?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdjustmentLineCreateInput = {
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    note?: string | null
    adjustment: AdjustmentCreateNestedOneWithoutLinesInput
    product: ProductCreateNestedOneWithoutAdjustmentLinesInput
  }

  export type AdjustmentLineUncheckedCreateInput = {
    id?: number
    adjustmentId: number
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    note?: string | null
  }

  export type AdjustmentLineUpdateInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    adjustment?: AdjustmentUpdateOneRequiredWithoutLinesNestedInput
    product?: ProductUpdateOneRequiredWithoutAdjustmentLinesNestedInput
  }

  export type AdjustmentLineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    adjustmentId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdjustmentLineCreateManyInput = {
    id?: number
    adjustmentId: number
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    note?: string | null
  }

  export type AdjustmentLineUpdateManyMutationInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdjustmentLineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    adjustmentId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockMoveCreateInput = {
    moveNo?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    reason?: string | null
    reference?: string | null
    documentType?: string | null
    documentId?: number | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutStockMovesInput
    fromWarehouse?: WarehouseCreateNestedOneWithoutStockMovesFromInput
    toWarehouse?: WarehouseCreateNestedOneWithoutStockMovesToInput
    fromLocation?: LocationCreateNestedOneWithoutStockMovesFromInput
    toLocation?: LocationCreateNestedOneWithoutStockMovesToInput
    createdBy?: UserCreateNestedOneWithoutStockMovesCreatedInput
  }

  export type StockMoveUncheckedCreateInput = {
    id?: number
    moveNo?: string | null
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    fromWarehouseId?: number | null
    toWarehouseId?: number | null
    fromLocationId?: number | null
    toLocationId?: number | null
    reason?: string | null
    reference?: string | null
    documentType?: string | null
    documentId?: number | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
  }

  export type StockMoveUpdateInput = {
    moveNo?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStockMovesNestedInput
    fromWarehouse?: WarehouseUpdateOneWithoutStockMovesFromNestedInput
    toWarehouse?: WarehouseUpdateOneWithoutStockMovesToNestedInput
    fromLocation?: LocationUpdateOneWithoutStockMovesFromNestedInput
    toLocation?: LocationUpdateOneWithoutStockMovesToNestedInput
    createdBy?: UserUpdateOneWithoutStockMovesCreatedNestedInput
  }

  export type StockMoveUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    moveNo?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    toWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    fromLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    toLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMoveCreateManyInput = {
    id?: number
    moveNo?: string | null
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    fromWarehouseId?: number | null
    toWarehouseId?: number | null
    fromLocationId?: number | null
    toLocationId?: number | null
    reason?: string | null
    reference?: string | null
    documentType?: string | null
    documentId?: number | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
  }

  export type StockMoveUpdateManyMutationInput = {
    moveNo?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMoveUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    moveNo?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    toWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    fromLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    toLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ReceiptListRelationFilter = {
    every?: ReceiptWhereInput
    some?: ReceiptWhereInput
    none?: ReceiptWhereInput
  }

  export type DeliveryListRelationFilter = {
    every?: DeliveryWhereInput
    some?: DeliveryWhereInput
    none?: DeliveryWhereInput
  }

  export type TransferListRelationFilter = {
    every?: TransferWhereInput
    some?: TransferWhereInput
    none?: TransferWhereInput
  }

  export type AdjustmentListRelationFilter = {
    every?: AdjustmentWhereInput
    some?: AdjustmentWhereInput
    none?: AdjustmentWhereInput
  }

  export type StockMoveListRelationFilter = {
    every?: StockMoveWhereInput
    some?: StockMoveWhereInput
    none?: StockMoveWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ReceiptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdjustmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockMoveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type OtpCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OtpAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OtpMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OtpMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OtpSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StockQuantListRelationFilter = {
    every?: StockQuantWhereInput
    some?: StockQuantWhereInput
    none?: StockQuantWhereInput
  }

  export type ReceiptLineListRelationFilter = {
    every?: ReceiptLineWhereInput
    some?: ReceiptLineWhereInput
    none?: ReceiptLineWhereInput
  }

  export type DeliveryLineListRelationFilter = {
    every?: DeliveryLineWhereInput
    some?: DeliveryLineWhereInput
    none?: DeliveryLineWhereInput
  }

  export type TransferLineListRelationFilter = {
    every?: TransferLineWhereInput
    some?: TransferLineWhereInput
    none?: TransferLineWhereInput
  }

  export type AdjustmentLineListRelationFilter = {
    every?: AdjustmentLineWhereInput
    some?: AdjustmentLineWhereInput
    none?: AdjustmentLineWhereInput
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type ReorderRuleListRelationFilter = {
    every?: ReorderRuleWhereInput
    some?: ReorderRuleWhereInput
    none?: ReorderRuleWhereInput
  }

  export type StockQuantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReceiptLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransferLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdjustmentLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReorderRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    uom?: SortOrder
    defaultPrice?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    defaultPrice?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    uom?: SortOrder
    defaultPrice?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    uom?: SortOrder
    defaultPrice?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    defaultPrice?: SortOrder
    categoryId?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type WarehouseScalarRelationFilter = {
    is?: WarehouseWhereInput
    isNot?: WarehouseWhereInput
  }

  export type ReorderRuleProductIdWarehouseIdCompoundUniqueInput = {
    productId: number
    warehouseId: number
  }

  export type ReorderRuleCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    minQty?: SortOrder
    maxQty?: SortOrder
    createdAt?: SortOrder
  }

  export type ReorderRuleAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    minQty?: SortOrder
    maxQty?: SortOrder
  }

  export type ReorderRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    minQty?: SortOrder
    maxQty?: SortOrder
    createdAt?: SortOrder
  }

  export type ReorderRuleMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    minQty?: SortOrder
    maxQty?: SortOrder
    createdAt?: SortOrder
  }

  export type ReorderRuleSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    minQty?: SortOrder
    maxQty?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type LocationListRelationFilter = {
    every?: LocationWhereInput
    some?: LocationWhereInput
    none?: LocationWhereInput
  }

  export type LocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WarehouseMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LocationCodeWarehouseIdCompoundUniqueInput = {
    code: string
    warehouseId: number
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    warehouseId?: SortOrder
    parentId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    id?: SortOrder
    warehouseId?: SortOrder
    parentId?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    warehouseId?: SortOrder
    parentId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    warehouseId?: SortOrder
    parentId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    id?: SortOrder
    warehouseId?: SortOrder
    parentId?: SortOrder
  }

  export type LocationNullableScalarRelationFilter = {
    is?: LocationWhereInput | null
    isNot?: LocationWhereInput | null
  }

  export type StockQuantProductIdWarehouseIdLocationIdCompoundUniqueInput = {
    productId: number
    warehouseId: number
    locationId: number
  }

  export type StockQuantCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    locationId?: SortOrder
    quantity?: SortOrder
    reserved?: SortOrder
    incoming?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockQuantAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    locationId?: SortOrder
    quantity?: SortOrder
    reserved?: SortOrder
    incoming?: SortOrder
  }

  export type StockQuantMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    locationId?: SortOrder
    quantity?: SortOrder
    reserved?: SortOrder
    incoming?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockQuantMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    locationId?: SortOrder
    quantity?: SortOrder
    reserved?: SortOrder
    incoming?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockQuantSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    locationId?: SortOrder
    quantity?: SortOrder
    reserved?: SortOrder
    incoming?: SortOrder
  }

  export type EnumDocumentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusFilter<$PrismaModel> | $Enums.DocumentStatus
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ReceiptCountOrderByAggregateInput = {
    id?: SortOrder
    receiptNo?: SortOrder
    reference?: SortOrder
    warehouseId?: SortOrder
    partner?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceiptAvgOrderByAggregateInput = {
    id?: SortOrder
    warehouseId?: SortOrder
    createdById?: SortOrder
  }

  export type ReceiptMaxOrderByAggregateInput = {
    id?: SortOrder
    receiptNo?: SortOrder
    reference?: SortOrder
    warehouseId?: SortOrder
    partner?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceiptMinOrderByAggregateInput = {
    id?: SortOrder
    receiptNo?: SortOrder
    reference?: SortOrder
    warehouseId?: SortOrder
    partner?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceiptSumOrderByAggregateInput = {
    id?: SortOrder
    warehouseId?: SortOrder
    createdById?: SortOrder
  }

  export type EnumDocumentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentStatusFilter<$PrismaModel>
  }

  export type ReceiptScalarRelationFilter = {
    is?: ReceiptWhereInput
    isNot?: ReceiptWhereInput
  }

  export type ReceiptLineCountOrderByAggregateInput = {
    id?: SortOrder
    receiptId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
    unitPrice?: SortOrder
  }

  export type ReceiptLineAvgOrderByAggregateInput = {
    id?: SortOrder
    receiptId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type ReceiptLineMaxOrderByAggregateInput = {
    id?: SortOrder
    receiptId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
    unitPrice?: SortOrder
  }

  export type ReceiptLineMinOrderByAggregateInput = {
    id?: SortOrder
    receiptId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
    unitPrice?: SortOrder
  }

  export type ReceiptLineSumOrderByAggregateInput = {
    id?: SortOrder
    receiptId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type DeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    deliveryNo?: SortOrder
    reference?: SortOrder
    warehouseId?: SortOrder
    partner?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryAvgOrderByAggregateInput = {
    id?: SortOrder
    warehouseId?: SortOrder
    createdById?: SortOrder
  }

  export type DeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    deliveryNo?: SortOrder
    reference?: SortOrder
    warehouseId?: SortOrder
    partner?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    deliveryNo?: SortOrder
    reference?: SortOrder
    warehouseId?: SortOrder
    partner?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliverySumOrderByAggregateInput = {
    id?: SortOrder
    warehouseId?: SortOrder
    createdById?: SortOrder
  }

  export type DeliveryScalarRelationFilter = {
    is?: DeliveryWhereInput
    isNot?: DeliveryWhereInput
  }

  export type DeliveryLineCountOrderByAggregateInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
    unitPrice?: SortOrder
  }

  export type DeliveryLineAvgOrderByAggregateInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type DeliveryLineMaxOrderByAggregateInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
    unitPrice?: SortOrder
  }

  export type DeliveryLineMinOrderByAggregateInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
    unitPrice?: SortOrder
  }

  export type DeliveryLineSumOrderByAggregateInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type TransferCountOrderByAggregateInput = {
    id?: SortOrder
    transferNo?: SortOrder
    reference?: SortOrder
    fromWarehouseId?: SortOrder
    toWarehouseId?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferAvgOrderByAggregateInput = {
    id?: SortOrder
    fromWarehouseId?: SortOrder
    toWarehouseId?: SortOrder
    createdById?: SortOrder
  }

  export type TransferMaxOrderByAggregateInput = {
    id?: SortOrder
    transferNo?: SortOrder
    reference?: SortOrder
    fromWarehouseId?: SortOrder
    toWarehouseId?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferMinOrderByAggregateInput = {
    id?: SortOrder
    transferNo?: SortOrder
    reference?: SortOrder
    fromWarehouseId?: SortOrder
    toWarehouseId?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferSumOrderByAggregateInput = {
    id?: SortOrder
    fromWarehouseId?: SortOrder
    toWarehouseId?: SortOrder
    createdById?: SortOrder
  }

  export type TransferScalarRelationFilter = {
    is?: TransferWhereInput
    isNot?: TransferWhereInput
  }

  export type TransferLineCountOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
  }

  export type TransferLineAvgOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type TransferLineMaxOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
  }

  export type TransferLineMinOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
  }

  export type TransferLineSumOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type AdjustmentCountOrderByAggregateInput = {
    id?: SortOrder
    adjustmentNo?: SortOrder
    warehouseId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdjustmentAvgOrderByAggregateInput = {
    id?: SortOrder
    warehouseId?: SortOrder
    createdById?: SortOrder
  }

  export type AdjustmentMaxOrderByAggregateInput = {
    id?: SortOrder
    adjustmentNo?: SortOrder
    warehouseId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdjustmentMinOrderByAggregateInput = {
    id?: SortOrder
    adjustmentNo?: SortOrder
    warehouseId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdjustmentSumOrderByAggregateInput = {
    id?: SortOrder
    warehouseId?: SortOrder
    createdById?: SortOrder
  }

  export type AdjustmentScalarRelationFilter = {
    is?: AdjustmentWhereInput
    isNot?: AdjustmentWhereInput
  }

  export type AdjustmentLineCountOrderByAggregateInput = {
    id?: SortOrder
    adjustmentId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
    note?: SortOrder
  }

  export type AdjustmentLineAvgOrderByAggregateInput = {
    id?: SortOrder
    adjustmentId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type AdjustmentLineMaxOrderByAggregateInput = {
    id?: SortOrder
    adjustmentId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
    note?: SortOrder
  }

  export type AdjustmentLineMinOrderByAggregateInput = {
    id?: SortOrder
    adjustmentId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
    note?: SortOrder
  }

  export type AdjustmentLineSumOrderByAggregateInput = {
    id?: SortOrder
    adjustmentId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type WarehouseNullableScalarRelationFilter = {
    is?: WarehouseWhereInput | null
    isNot?: WarehouseWhereInput | null
  }

  export type StockMoveCountOrderByAggregateInput = {
    id?: SortOrder
    moveNo?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
    fromWarehouseId?: SortOrder
    toWarehouseId?: SortOrder
    fromLocationId?: SortOrder
    toLocationId?: SortOrder
    reason?: SortOrder
    reference?: SortOrder
    documentType?: SortOrder
    documentId?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMoveAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    fromWarehouseId?: SortOrder
    toWarehouseId?: SortOrder
    fromLocationId?: SortOrder
    toLocationId?: SortOrder
    documentId?: SortOrder
    createdById?: SortOrder
  }

  export type StockMoveMaxOrderByAggregateInput = {
    id?: SortOrder
    moveNo?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
    fromWarehouseId?: SortOrder
    toWarehouseId?: SortOrder
    fromLocationId?: SortOrder
    toLocationId?: SortOrder
    reason?: SortOrder
    reference?: SortOrder
    documentType?: SortOrder
    documentId?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMoveMinOrderByAggregateInput = {
    id?: SortOrder
    moveNo?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    uom?: SortOrder
    fromWarehouseId?: SortOrder
    toWarehouseId?: SortOrder
    fromLocationId?: SortOrder
    toLocationId?: SortOrder
    reason?: SortOrder
    reference?: SortOrder
    documentType?: SortOrder
    documentId?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMoveSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    fromWarehouseId?: SortOrder
    toWarehouseId?: SortOrder
    fromLocationId?: SortOrder
    toLocationId?: SortOrder
    documentId?: SortOrder
    createdById?: SortOrder
  }

  export type ReceiptCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ReceiptCreateWithoutCreatedByInput, ReceiptUncheckedCreateWithoutCreatedByInput> | ReceiptCreateWithoutCreatedByInput[] | ReceiptUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutCreatedByInput | ReceiptCreateOrConnectWithoutCreatedByInput[]
    createMany?: ReceiptCreateManyCreatedByInputEnvelope
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
  }

  export type DeliveryCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<DeliveryCreateWithoutCreatedByInput, DeliveryUncheckedCreateWithoutCreatedByInput> | DeliveryCreateWithoutCreatedByInput[] | DeliveryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutCreatedByInput | DeliveryCreateOrConnectWithoutCreatedByInput[]
    createMany?: DeliveryCreateManyCreatedByInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TransferCreateWithoutCreatedByInput, TransferUncheckedCreateWithoutCreatedByInput> | TransferCreateWithoutCreatedByInput[] | TransferUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutCreatedByInput | TransferCreateOrConnectWithoutCreatedByInput[]
    createMany?: TransferCreateManyCreatedByInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type AdjustmentCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AdjustmentCreateWithoutCreatedByInput, AdjustmentUncheckedCreateWithoutCreatedByInput> | AdjustmentCreateWithoutCreatedByInput[] | AdjustmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AdjustmentCreateOrConnectWithoutCreatedByInput | AdjustmentCreateOrConnectWithoutCreatedByInput[]
    createMany?: AdjustmentCreateManyCreatedByInputEnvelope
    connect?: AdjustmentWhereUniqueInput | AdjustmentWhereUniqueInput[]
  }

  export type StockMoveCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<StockMoveCreateWithoutCreatedByInput, StockMoveUncheckedCreateWithoutCreatedByInput> | StockMoveCreateWithoutCreatedByInput[] | StockMoveUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutCreatedByInput | StockMoveCreateOrConnectWithoutCreatedByInput[]
    createMany?: StockMoveCreateManyCreatedByInputEnvelope
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
  }

  export type ReceiptUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ReceiptCreateWithoutCreatedByInput, ReceiptUncheckedCreateWithoutCreatedByInput> | ReceiptCreateWithoutCreatedByInput[] | ReceiptUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutCreatedByInput | ReceiptCreateOrConnectWithoutCreatedByInput[]
    createMany?: ReceiptCreateManyCreatedByInputEnvelope
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
  }

  export type DeliveryUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<DeliveryCreateWithoutCreatedByInput, DeliveryUncheckedCreateWithoutCreatedByInput> | DeliveryCreateWithoutCreatedByInput[] | DeliveryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutCreatedByInput | DeliveryCreateOrConnectWithoutCreatedByInput[]
    createMany?: DeliveryCreateManyCreatedByInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TransferCreateWithoutCreatedByInput, TransferUncheckedCreateWithoutCreatedByInput> | TransferCreateWithoutCreatedByInput[] | TransferUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutCreatedByInput | TransferCreateOrConnectWithoutCreatedByInput[]
    createMany?: TransferCreateManyCreatedByInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type AdjustmentUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AdjustmentCreateWithoutCreatedByInput, AdjustmentUncheckedCreateWithoutCreatedByInput> | AdjustmentCreateWithoutCreatedByInput[] | AdjustmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AdjustmentCreateOrConnectWithoutCreatedByInput | AdjustmentCreateOrConnectWithoutCreatedByInput[]
    createMany?: AdjustmentCreateManyCreatedByInputEnvelope
    connect?: AdjustmentWhereUniqueInput | AdjustmentWhereUniqueInput[]
  }

  export type StockMoveUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<StockMoveCreateWithoutCreatedByInput, StockMoveUncheckedCreateWithoutCreatedByInput> | StockMoveCreateWithoutCreatedByInput[] | StockMoveUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutCreatedByInput | StockMoveCreateOrConnectWithoutCreatedByInput[]
    createMany?: StockMoveCreateManyCreatedByInputEnvelope
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ReceiptUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ReceiptCreateWithoutCreatedByInput, ReceiptUncheckedCreateWithoutCreatedByInput> | ReceiptCreateWithoutCreatedByInput[] | ReceiptUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutCreatedByInput | ReceiptCreateOrConnectWithoutCreatedByInput[]
    upsert?: ReceiptUpsertWithWhereUniqueWithoutCreatedByInput | ReceiptUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ReceiptCreateManyCreatedByInputEnvelope
    set?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    disconnect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    delete?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    update?: ReceiptUpdateWithWhereUniqueWithoutCreatedByInput | ReceiptUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ReceiptUpdateManyWithWhereWithoutCreatedByInput | ReceiptUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ReceiptScalarWhereInput | ReceiptScalarWhereInput[]
  }

  export type DeliveryUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<DeliveryCreateWithoutCreatedByInput, DeliveryUncheckedCreateWithoutCreatedByInput> | DeliveryCreateWithoutCreatedByInput[] | DeliveryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutCreatedByInput | DeliveryCreateOrConnectWithoutCreatedByInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutCreatedByInput | DeliveryUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: DeliveryCreateManyCreatedByInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutCreatedByInput | DeliveryUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutCreatedByInput | DeliveryUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TransferCreateWithoutCreatedByInput, TransferUncheckedCreateWithoutCreatedByInput> | TransferCreateWithoutCreatedByInput[] | TransferUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutCreatedByInput | TransferCreateOrConnectWithoutCreatedByInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutCreatedByInput | TransferUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TransferCreateManyCreatedByInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutCreatedByInput | TransferUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutCreatedByInput | TransferUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type AdjustmentUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AdjustmentCreateWithoutCreatedByInput, AdjustmentUncheckedCreateWithoutCreatedByInput> | AdjustmentCreateWithoutCreatedByInput[] | AdjustmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AdjustmentCreateOrConnectWithoutCreatedByInput | AdjustmentCreateOrConnectWithoutCreatedByInput[]
    upsert?: AdjustmentUpsertWithWhereUniqueWithoutCreatedByInput | AdjustmentUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AdjustmentCreateManyCreatedByInputEnvelope
    set?: AdjustmentWhereUniqueInput | AdjustmentWhereUniqueInput[]
    disconnect?: AdjustmentWhereUniqueInput | AdjustmentWhereUniqueInput[]
    delete?: AdjustmentWhereUniqueInput | AdjustmentWhereUniqueInput[]
    connect?: AdjustmentWhereUniqueInput | AdjustmentWhereUniqueInput[]
    update?: AdjustmentUpdateWithWhereUniqueWithoutCreatedByInput | AdjustmentUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AdjustmentUpdateManyWithWhereWithoutCreatedByInput | AdjustmentUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AdjustmentScalarWhereInput | AdjustmentScalarWhereInput[]
  }

  export type StockMoveUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<StockMoveCreateWithoutCreatedByInput, StockMoveUncheckedCreateWithoutCreatedByInput> | StockMoveCreateWithoutCreatedByInput[] | StockMoveUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutCreatedByInput | StockMoveCreateOrConnectWithoutCreatedByInput[]
    upsert?: StockMoveUpsertWithWhereUniqueWithoutCreatedByInput | StockMoveUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: StockMoveCreateManyCreatedByInputEnvelope
    set?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    disconnect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    delete?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    update?: StockMoveUpdateWithWhereUniqueWithoutCreatedByInput | StockMoveUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: StockMoveUpdateManyWithWhereWithoutCreatedByInput | StockMoveUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: StockMoveScalarWhereInput | StockMoveScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ReceiptUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ReceiptCreateWithoutCreatedByInput, ReceiptUncheckedCreateWithoutCreatedByInput> | ReceiptCreateWithoutCreatedByInput[] | ReceiptUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutCreatedByInput | ReceiptCreateOrConnectWithoutCreatedByInput[]
    upsert?: ReceiptUpsertWithWhereUniqueWithoutCreatedByInput | ReceiptUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ReceiptCreateManyCreatedByInputEnvelope
    set?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    disconnect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    delete?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    update?: ReceiptUpdateWithWhereUniqueWithoutCreatedByInput | ReceiptUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ReceiptUpdateManyWithWhereWithoutCreatedByInput | ReceiptUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ReceiptScalarWhereInput | ReceiptScalarWhereInput[]
  }

  export type DeliveryUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<DeliveryCreateWithoutCreatedByInput, DeliveryUncheckedCreateWithoutCreatedByInput> | DeliveryCreateWithoutCreatedByInput[] | DeliveryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutCreatedByInput | DeliveryCreateOrConnectWithoutCreatedByInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutCreatedByInput | DeliveryUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: DeliveryCreateManyCreatedByInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutCreatedByInput | DeliveryUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutCreatedByInput | DeliveryUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TransferCreateWithoutCreatedByInput, TransferUncheckedCreateWithoutCreatedByInput> | TransferCreateWithoutCreatedByInput[] | TransferUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutCreatedByInput | TransferCreateOrConnectWithoutCreatedByInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutCreatedByInput | TransferUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TransferCreateManyCreatedByInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutCreatedByInput | TransferUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutCreatedByInput | TransferUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type AdjustmentUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AdjustmentCreateWithoutCreatedByInput, AdjustmentUncheckedCreateWithoutCreatedByInput> | AdjustmentCreateWithoutCreatedByInput[] | AdjustmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AdjustmentCreateOrConnectWithoutCreatedByInput | AdjustmentCreateOrConnectWithoutCreatedByInput[]
    upsert?: AdjustmentUpsertWithWhereUniqueWithoutCreatedByInput | AdjustmentUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AdjustmentCreateManyCreatedByInputEnvelope
    set?: AdjustmentWhereUniqueInput | AdjustmentWhereUniqueInput[]
    disconnect?: AdjustmentWhereUniqueInput | AdjustmentWhereUniqueInput[]
    delete?: AdjustmentWhereUniqueInput | AdjustmentWhereUniqueInput[]
    connect?: AdjustmentWhereUniqueInput | AdjustmentWhereUniqueInput[]
    update?: AdjustmentUpdateWithWhereUniqueWithoutCreatedByInput | AdjustmentUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AdjustmentUpdateManyWithWhereWithoutCreatedByInput | AdjustmentUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AdjustmentScalarWhereInput | AdjustmentScalarWhereInput[]
  }

  export type StockMoveUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<StockMoveCreateWithoutCreatedByInput, StockMoveUncheckedCreateWithoutCreatedByInput> | StockMoveCreateWithoutCreatedByInput[] | StockMoveUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutCreatedByInput | StockMoveCreateOrConnectWithoutCreatedByInput[]
    upsert?: StockMoveUpsertWithWhereUniqueWithoutCreatedByInput | StockMoveUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: StockMoveCreateManyCreatedByInputEnvelope
    set?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    disconnect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    delete?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    update?: StockMoveUpdateWithWhereUniqueWithoutCreatedByInput | StockMoveUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: StockMoveUpdateManyWithWhereWithoutCreatedByInput | StockMoveUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: StockMoveScalarWhereInput | StockMoveScalarWhereInput[]
  }

  export type StockQuantCreateNestedManyWithoutProductInput = {
    create?: XOR<StockQuantCreateWithoutProductInput, StockQuantUncheckedCreateWithoutProductInput> | StockQuantCreateWithoutProductInput[] | StockQuantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockQuantCreateOrConnectWithoutProductInput | StockQuantCreateOrConnectWithoutProductInput[]
    createMany?: StockQuantCreateManyProductInputEnvelope
    connect?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
  }

  export type StockMoveCreateNestedManyWithoutProductInput = {
    create?: XOR<StockMoveCreateWithoutProductInput, StockMoveUncheckedCreateWithoutProductInput> | StockMoveCreateWithoutProductInput[] | StockMoveUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutProductInput | StockMoveCreateOrConnectWithoutProductInput[]
    createMany?: StockMoveCreateManyProductInputEnvelope
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
  }

  export type ReceiptLineCreateNestedManyWithoutProductInput = {
    create?: XOR<ReceiptLineCreateWithoutProductInput, ReceiptLineUncheckedCreateWithoutProductInput> | ReceiptLineCreateWithoutProductInput[] | ReceiptLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReceiptLineCreateOrConnectWithoutProductInput | ReceiptLineCreateOrConnectWithoutProductInput[]
    createMany?: ReceiptLineCreateManyProductInputEnvelope
    connect?: ReceiptLineWhereUniqueInput | ReceiptLineWhereUniqueInput[]
  }

  export type DeliveryLineCreateNestedManyWithoutProductInput = {
    create?: XOR<DeliveryLineCreateWithoutProductInput, DeliveryLineUncheckedCreateWithoutProductInput> | DeliveryLineCreateWithoutProductInput[] | DeliveryLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: DeliveryLineCreateOrConnectWithoutProductInput | DeliveryLineCreateOrConnectWithoutProductInput[]
    createMany?: DeliveryLineCreateManyProductInputEnvelope
    connect?: DeliveryLineWhereUniqueInput | DeliveryLineWhereUniqueInput[]
  }

  export type TransferLineCreateNestedManyWithoutProductInput = {
    create?: XOR<TransferLineCreateWithoutProductInput, TransferLineUncheckedCreateWithoutProductInput> | TransferLineCreateWithoutProductInput[] | TransferLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransferLineCreateOrConnectWithoutProductInput | TransferLineCreateOrConnectWithoutProductInput[]
    createMany?: TransferLineCreateManyProductInputEnvelope
    connect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
  }

  export type AdjustmentLineCreateNestedManyWithoutProductInput = {
    create?: XOR<AdjustmentLineCreateWithoutProductInput, AdjustmentLineUncheckedCreateWithoutProductInput> | AdjustmentLineCreateWithoutProductInput[] | AdjustmentLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AdjustmentLineCreateOrConnectWithoutProductInput | AdjustmentLineCreateOrConnectWithoutProductInput[]
    createMany?: AdjustmentLineCreateManyProductInputEnvelope
    connect?: AdjustmentLineWhereUniqueInput | AdjustmentLineWhereUniqueInput[]
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type ReorderRuleCreateNestedManyWithoutProductInput = {
    create?: XOR<ReorderRuleCreateWithoutProductInput, ReorderRuleUncheckedCreateWithoutProductInput> | ReorderRuleCreateWithoutProductInput[] | ReorderRuleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReorderRuleCreateOrConnectWithoutProductInput | ReorderRuleCreateOrConnectWithoutProductInput[]
    createMany?: ReorderRuleCreateManyProductInputEnvelope
    connect?: ReorderRuleWhereUniqueInput | ReorderRuleWhereUniqueInput[]
  }

  export type StockQuantUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<StockQuantCreateWithoutProductInput, StockQuantUncheckedCreateWithoutProductInput> | StockQuantCreateWithoutProductInput[] | StockQuantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockQuantCreateOrConnectWithoutProductInput | StockQuantCreateOrConnectWithoutProductInput[]
    createMany?: StockQuantCreateManyProductInputEnvelope
    connect?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
  }

  export type StockMoveUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<StockMoveCreateWithoutProductInput, StockMoveUncheckedCreateWithoutProductInput> | StockMoveCreateWithoutProductInput[] | StockMoveUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutProductInput | StockMoveCreateOrConnectWithoutProductInput[]
    createMany?: StockMoveCreateManyProductInputEnvelope
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
  }

  export type ReceiptLineUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ReceiptLineCreateWithoutProductInput, ReceiptLineUncheckedCreateWithoutProductInput> | ReceiptLineCreateWithoutProductInput[] | ReceiptLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReceiptLineCreateOrConnectWithoutProductInput | ReceiptLineCreateOrConnectWithoutProductInput[]
    createMany?: ReceiptLineCreateManyProductInputEnvelope
    connect?: ReceiptLineWhereUniqueInput | ReceiptLineWhereUniqueInput[]
  }

  export type DeliveryLineUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<DeliveryLineCreateWithoutProductInput, DeliveryLineUncheckedCreateWithoutProductInput> | DeliveryLineCreateWithoutProductInput[] | DeliveryLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: DeliveryLineCreateOrConnectWithoutProductInput | DeliveryLineCreateOrConnectWithoutProductInput[]
    createMany?: DeliveryLineCreateManyProductInputEnvelope
    connect?: DeliveryLineWhereUniqueInput | DeliveryLineWhereUniqueInput[]
  }

  export type TransferLineUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<TransferLineCreateWithoutProductInput, TransferLineUncheckedCreateWithoutProductInput> | TransferLineCreateWithoutProductInput[] | TransferLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransferLineCreateOrConnectWithoutProductInput | TransferLineCreateOrConnectWithoutProductInput[]
    createMany?: TransferLineCreateManyProductInputEnvelope
    connect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
  }

  export type AdjustmentLineUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<AdjustmentLineCreateWithoutProductInput, AdjustmentLineUncheckedCreateWithoutProductInput> | AdjustmentLineCreateWithoutProductInput[] | AdjustmentLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AdjustmentLineCreateOrConnectWithoutProductInput | AdjustmentLineCreateOrConnectWithoutProductInput[]
    createMany?: AdjustmentLineCreateManyProductInputEnvelope
    connect?: AdjustmentLineWhereUniqueInput | AdjustmentLineWhereUniqueInput[]
  }

  export type ReorderRuleUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ReorderRuleCreateWithoutProductInput, ReorderRuleUncheckedCreateWithoutProductInput> | ReorderRuleCreateWithoutProductInput[] | ReorderRuleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReorderRuleCreateOrConnectWithoutProductInput | ReorderRuleCreateOrConnectWithoutProductInput[]
    createMany?: ReorderRuleCreateManyProductInputEnvelope
    connect?: ReorderRuleWhereUniqueInput | ReorderRuleWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type StockQuantUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockQuantCreateWithoutProductInput, StockQuantUncheckedCreateWithoutProductInput> | StockQuantCreateWithoutProductInput[] | StockQuantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockQuantCreateOrConnectWithoutProductInput | StockQuantCreateOrConnectWithoutProductInput[]
    upsert?: StockQuantUpsertWithWhereUniqueWithoutProductInput | StockQuantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockQuantCreateManyProductInputEnvelope
    set?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    disconnect?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    delete?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    connect?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    update?: StockQuantUpdateWithWhereUniqueWithoutProductInput | StockQuantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockQuantUpdateManyWithWhereWithoutProductInput | StockQuantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockQuantScalarWhereInput | StockQuantScalarWhereInput[]
  }

  export type StockMoveUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockMoveCreateWithoutProductInput, StockMoveUncheckedCreateWithoutProductInput> | StockMoveCreateWithoutProductInput[] | StockMoveUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutProductInput | StockMoveCreateOrConnectWithoutProductInput[]
    upsert?: StockMoveUpsertWithWhereUniqueWithoutProductInput | StockMoveUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockMoveCreateManyProductInputEnvelope
    set?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    disconnect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    delete?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    update?: StockMoveUpdateWithWhereUniqueWithoutProductInput | StockMoveUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockMoveUpdateManyWithWhereWithoutProductInput | StockMoveUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockMoveScalarWhereInput | StockMoveScalarWhereInput[]
  }

  export type ReceiptLineUpdateManyWithoutProductNestedInput = {
    create?: XOR<ReceiptLineCreateWithoutProductInput, ReceiptLineUncheckedCreateWithoutProductInput> | ReceiptLineCreateWithoutProductInput[] | ReceiptLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReceiptLineCreateOrConnectWithoutProductInput | ReceiptLineCreateOrConnectWithoutProductInput[]
    upsert?: ReceiptLineUpsertWithWhereUniqueWithoutProductInput | ReceiptLineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ReceiptLineCreateManyProductInputEnvelope
    set?: ReceiptLineWhereUniqueInput | ReceiptLineWhereUniqueInput[]
    disconnect?: ReceiptLineWhereUniqueInput | ReceiptLineWhereUniqueInput[]
    delete?: ReceiptLineWhereUniqueInput | ReceiptLineWhereUniqueInput[]
    connect?: ReceiptLineWhereUniqueInput | ReceiptLineWhereUniqueInput[]
    update?: ReceiptLineUpdateWithWhereUniqueWithoutProductInput | ReceiptLineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ReceiptLineUpdateManyWithWhereWithoutProductInput | ReceiptLineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ReceiptLineScalarWhereInput | ReceiptLineScalarWhereInput[]
  }

  export type DeliveryLineUpdateManyWithoutProductNestedInput = {
    create?: XOR<DeliveryLineCreateWithoutProductInput, DeliveryLineUncheckedCreateWithoutProductInput> | DeliveryLineCreateWithoutProductInput[] | DeliveryLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: DeliveryLineCreateOrConnectWithoutProductInput | DeliveryLineCreateOrConnectWithoutProductInput[]
    upsert?: DeliveryLineUpsertWithWhereUniqueWithoutProductInput | DeliveryLineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: DeliveryLineCreateManyProductInputEnvelope
    set?: DeliveryLineWhereUniqueInput | DeliveryLineWhereUniqueInput[]
    disconnect?: DeliveryLineWhereUniqueInput | DeliveryLineWhereUniqueInput[]
    delete?: DeliveryLineWhereUniqueInput | DeliveryLineWhereUniqueInput[]
    connect?: DeliveryLineWhereUniqueInput | DeliveryLineWhereUniqueInput[]
    update?: DeliveryLineUpdateWithWhereUniqueWithoutProductInput | DeliveryLineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: DeliveryLineUpdateManyWithWhereWithoutProductInput | DeliveryLineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: DeliveryLineScalarWhereInput | DeliveryLineScalarWhereInput[]
  }

  export type TransferLineUpdateManyWithoutProductNestedInput = {
    create?: XOR<TransferLineCreateWithoutProductInput, TransferLineUncheckedCreateWithoutProductInput> | TransferLineCreateWithoutProductInput[] | TransferLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransferLineCreateOrConnectWithoutProductInput | TransferLineCreateOrConnectWithoutProductInput[]
    upsert?: TransferLineUpsertWithWhereUniqueWithoutProductInput | TransferLineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TransferLineCreateManyProductInputEnvelope
    set?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    disconnect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    delete?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    connect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    update?: TransferLineUpdateWithWhereUniqueWithoutProductInput | TransferLineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TransferLineUpdateManyWithWhereWithoutProductInput | TransferLineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TransferLineScalarWhereInput | TransferLineScalarWhereInput[]
  }

  export type AdjustmentLineUpdateManyWithoutProductNestedInput = {
    create?: XOR<AdjustmentLineCreateWithoutProductInput, AdjustmentLineUncheckedCreateWithoutProductInput> | AdjustmentLineCreateWithoutProductInput[] | AdjustmentLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AdjustmentLineCreateOrConnectWithoutProductInput | AdjustmentLineCreateOrConnectWithoutProductInput[]
    upsert?: AdjustmentLineUpsertWithWhereUniqueWithoutProductInput | AdjustmentLineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: AdjustmentLineCreateManyProductInputEnvelope
    set?: AdjustmentLineWhereUniqueInput | AdjustmentLineWhereUniqueInput[]
    disconnect?: AdjustmentLineWhereUniqueInput | AdjustmentLineWhereUniqueInput[]
    delete?: AdjustmentLineWhereUniqueInput | AdjustmentLineWhereUniqueInput[]
    connect?: AdjustmentLineWhereUniqueInput | AdjustmentLineWhereUniqueInput[]
    update?: AdjustmentLineUpdateWithWhereUniqueWithoutProductInput | AdjustmentLineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: AdjustmentLineUpdateManyWithWhereWithoutProductInput | AdjustmentLineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: AdjustmentLineScalarWhereInput | AdjustmentLineScalarWhereInput[]
  }

  export type CategoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ReorderRuleUpdateManyWithoutProductNestedInput = {
    create?: XOR<ReorderRuleCreateWithoutProductInput, ReorderRuleUncheckedCreateWithoutProductInput> | ReorderRuleCreateWithoutProductInput[] | ReorderRuleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReorderRuleCreateOrConnectWithoutProductInput | ReorderRuleCreateOrConnectWithoutProductInput[]
    upsert?: ReorderRuleUpsertWithWhereUniqueWithoutProductInput | ReorderRuleUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ReorderRuleCreateManyProductInputEnvelope
    set?: ReorderRuleWhereUniqueInput | ReorderRuleWhereUniqueInput[]
    disconnect?: ReorderRuleWhereUniqueInput | ReorderRuleWhereUniqueInput[]
    delete?: ReorderRuleWhereUniqueInput | ReorderRuleWhereUniqueInput[]
    connect?: ReorderRuleWhereUniqueInput | ReorderRuleWhereUniqueInput[]
    update?: ReorderRuleUpdateWithWhereUniqueWithoutProductInput | ReorderRuleUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ReorderRuleUpdateManyWithWhereWithoutProductInput | ReorderRuleUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ReorderRuleScalarWhereInput | ReorderRuleScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StockQuantUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockQuantCreateWithoutProductInput, StockQuantUncheckedCreateWithoutProductInput> | StockQuantCreateWithoutProductInput[] | StockQuantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockQuantCreateOrConnectWithoutProductInput | StockQuantCreateOrConnectWithoutProductInput[]
    upsert?: StockQuantUpsertWithWhereUniqueWithoutProductInput | StockQuantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockQuantCreateManyProductInputEnvelope
    set?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    disconnect?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    delete?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    connect?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    update?: StockQuantUpdateWithWhereUniqueWithoutProductInput | StockQuantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockQuantUpdateManyWithWhereWithoutProductInput | StockQuantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockQuantScalarWhereInput | StockQuantScalarWhereInput[]
  }

  export type StockMoveUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockMoveCreateWithoutProductInput, StockMoveUncheckedCreateWithoutProductInput> | StockMoveCreateWithoutProductInput[] | StockMoveUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutProductInput | StockMoveCreateOrConnectWithoutProductInput[]
    upsert?: StockMoveUpsertWithWhereUniqueWithoutProductInput | StockMoveUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockMoveCreateManyProductInputEnvelope
    set?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    disconnect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    delete?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    update?: StockMoveUpdateWithWhereUniqueWithoutProductInput | StockMoveUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockMoveUpdateManyWithWhereWithoutProductInput | StockMoveUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockMoveScalarWhereInput | StockMoveScalarWhereInput[]
  }

  export type ReceiptLineUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ReceiptLineCreateWithoutProductInput, ReceiptLineUncheckedCreateWithoutProductInput> | ReceiptLineCreateWithoutProductInput[] | ReceiptLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReceiptLineCreateOrConnectWithoutProductInput | ReceiptLineCreateOrConnectWithoutProductInput[]
    upsert?: ReceiptLineUpsertWithWhereUniqueWithoutProductInput | ReceiptLineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ReceiptLineCreateManyProductInputEnvelope
    set?: ReceiptLineWhereUniqueInput | ReceiptLineWhereUniqueInput[]
    disconnect?: ReceiptLineWhereUniqueInput | ReceiptLineWhereUniqueInput[]
    delete?: ReceiptLineWhereUniqueInput | ReceiptLineWhereUniqueInput[]
    connect?: ReceiptLineWhereUniqueInput | ReceiptLineWhereUniqueInput[]
    update?: ReceiptLineUpdateWithWhereUniqueWithoutProductInput | ReceiptLineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ReceiptLineUpdateManyWithWhereWithoutProductInput | ReceiptLineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ReceiptLineScalarWhereInput | ReceiptLineScalarWhereInput[]
  }

  export type DeliveryLineUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<DeliveryLineCreateWithoutProductInput, DeliveryLineUncheckedCreateWithoutProductInput> | DeliveryLineCreateWithoutProductInput[] | DeliveryLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: DeliveryLineCreateOrConnectWithoutProductInput | DeliveryLineCreateOrConnectWithoutProductInput[]
    upsert?: DeliveryLineUpsertWithWhereUniqueWithoutProductInput | DeliveryLineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: DeliveryLineCreateManyProductInputEnvelope
    set?: DeliveryLineWhereUniqueInput | DeliveryLineWhereUniqueInput[]
    disconnect?: DeliveryLineWhereUniqueInput | DeliveryLineWhereUniqueInput[]
    delete?: DeliveryLineWhereUniqueInput | DeliveryLineWhereUniqueInput[]
    connect?: DeliveryLineWhereUniqueInput | DeliveryLineWhereUniqueInput[]
    update?: DeliveryLineUpdateWithWhereUniqueWithoutProductInput | DeliveryLineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: DeliveryLineUpdateManyWithWhereWithoutProductInput | DeliveryLineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: DeliveryLineScalarWhereInput | DeliveryLineScalarWhereInput[]
  }

  export type TransferLineUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<TransferLineCreateWithoutProductInput, TransferLineUncheckedCreateWithoutProductInput> | TransferLineCreateWithoutProductInput[] | TransferLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransferLineCreateOrConnectWithoutProductInput | TransferLineCreateOrConnectWithoutProductInput[]
    upsert?: TransferLineUpsertWithWhereUniqueWithoutProductInput | TransferLineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TransferLineCreateManyProductInputEnvelope
    set?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    disconnect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    delete?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    connect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    update?: TransferLineUpdateWithWhereUniqueWithoutProductInput | TransferLineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TransferLineUpdateManyWithWhereWithoutProductInput | TransferLineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TransferLineScalarWhereInput | TransferLineScalarWhereInput[]
  }

  export type AdjustmentLineUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<AdjustmentLineCreateWithoutProductInput, AdjustmentLineUncheckedCreateWithoutProductInput> | AdjustmentLineCreateWithoutProductInput[] | AdjustmentLineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AdjustmentLineCreateOrConnectWithoutProductInput | AdjustmentLineCreateOrConnectWithoutProductInput[]
    upsert?: AdjustmentLineUpsertWithWhereUniqueWithoutProductInput | AdjustmentLineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: AdjustmentLineCreateManyProductInputEnvelope
    set?: AdjustmentLineWhereUniqueInput | AdjustmentLineWhereUniqueInput[]
    disconnect?: AdjustmentLineWhereUniqueInput | AdjustmentLineWhereUniqueInput[]
    delete?: AdjustmentLineWhereUniqueInput | AdjustmentLineWhereUniqueInput[]
    connect?: AdjustmentLineWhereUniqueInput | AdjustmentLineWhereUniqueInput[]
    update?: AdjustmentLineUpdateWithWhereUniqueWithoutProductInput | AdjustmentLineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: AdjustmentLineUpdateManyWithWhereWithoutProductInput | AdjustmentLineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: AdjustmentLineScalarWhereInput | AdjustmentLineScalarWhereInput[]
  }

  export type ReorderRuleUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ReorderRuleCreateWithoutProductInput, ReorderRuleUncheckedCreateWithoutProductInput> | ReorderRuleCreateWithoutProductInput[] | ReorderRuleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReorderRuleCreateOrConnectWithoutProductInput | ReorderRuleCreateOrConnectWithoutProductInput[]
    upsert?: ReorderRuleUpsertWithWhereUniqueWithoutProductInput | ReorderRuleUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ReorderRuleCreateManyProductInputEnvelope
    set?: ReorderRuleWhereUniqueInput | ReorderRuleWhereUniqueInput[]
    disconnect?: ReorderRuleWhereUniqueInput | ReorderRuleWhereUniqueInput[]
    delete?: ReorderRuleWhereUniqueInput | ReorderRuleWhereUniqueInput[]
    connect?: ReorderRuleWhereUniqueInput | ReorderRuleWhereUniqueInput[]
    update?: ReorderRuleUpdateWithWhereUniqueWithoutProductInput | ReorderRuleUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ReorderRuleUpdateManyWithWhereWithoutProductInput | ReorderRuleUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ReorderRuleScalarWhereInput | ReorderRuleScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutReorderRulesInput = {
    create?: XOR<ProductCreateWithoutReorderRulesInput, ProductUncheckedCreateWithoutReorderRulesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReorderRulesInput
    connect?: ProductWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutReorderRulesInput = {
    create?: XOR<WarehouseCreateWithoutReorderRulesInput, WarehouseUncheckedCreateWithoutReorderRulesInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutReorderRulesInput
    connect?: WarehouseWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ProductUpdateOneRequiredWithoutReorderRulesNestedInput = {
    create?: XOR<ProductCreateWithoutReorderRulesInput, ProductUncheckedCreateWithoutReorderRulesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReorderRulesInput
    upsert?: ProductUpsertWithoutReorderRulesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutReorderRulesInput, ProductUpdateWithoutReorderRulesInput>, ProductUncheckedUpdateWithoutReorderRulesInput>
  }

  export type WarehouseUpdateOneRequiredWithoutReorderRulesNestedInput = {
    create?: XOR<WarehouseCreateWithoutReorderRulesInput, WarehouseUncheckedCreateWithoutReorderRulesInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutReorderRulesInput
    upsert?: WarehouseUpsertWithoutReorderRulesInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutReorderRulesInput, WarehouseUpdateWithoutReorderRulesInput>, WarehouseUncheckedUpdateWithoutReorderRulesInput>
  }

  export type LocationCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<LocationCreateWithoutWarehouseInput, LocationUncheckedCreateWithoutWarehouseInput> | LocationCreateWithoutWarehouseInput[] | LocationUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutWarehouseInput | LocationCreateOrConnectWithoutWarehouseInput[]
    createMany?: LocationCreateManyWarehouseInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type StockQuantCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<StockQuantCreateWithoutWarehouseInput, StockQuantUncheckedCreateWithoutWarehouseInput> | StockQuantCreateWithoutWarehouseInput[] | StockQuantUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: StockQuantCreateOrConnectWithoutWarehouseInput | StockQuantCreateOrConnectWithoutWarehouseInput[]
    createMany?: StockQuantCreateManyWarehouseInputEnvelope
    connect?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
  }

  export type ReceiptCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<ReceiptCreateWithoutWarehouseInput, ReceiptUncheckedCreateWithoutWarehouseInput> | ReceiptCreateWithoutWarehouseInput[] | ReceiptUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutWarehouseInput | ReceiptCreateOrConnectWithoutWarehouseInput[]
    createMany?: ReceiptCreateManyWarehouseInputEnvelope
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
  }

  export type DeliveryCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<DeliveryCreateWithoutWarehouseInput, DeliveryUncheckedCreateWithoutWarehouseInput> | DeliveryCreateWithoutWarehouseInput[] | DeliveryUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutWarehouseInput | DeliveryCreateOrConnectWithoutWarehouseInput[]
    createMany?: DeliveryCreateManyWarehouseInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutFromWarehouseInput = {
    create?: XOR<TransferCreateWithoutFromWarehouseInput, TransferUncheckedCreateWithoutFromWarehouseInput> | TransferCreateWithoutFromWarehouseInput[] | TransferUncheckedCreateWithoutFromWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromWarehouseInput | TransferCreateOrConnectWithoutFromWarehouseInput[]
    createMany?: TransferCreateManyFromWarehouseInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutToWarehouseInput = {
    create?: XOR<TransferCreateWithoutToWarehouseInput, TransferUncheckedCreateWithoutToWarehouseInput> | TransferCreateWithoutToWarehouseInput[] | TransferUncheckedCreateWithoutToWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToWarehouseInput | TransferCreateOrConnectWithoutToWarehouseInput[]
    createMany?: TransferCreateManyToWarehouseInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type AdjustmentCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<AdjustmentCreateWithoutWarehouseInput, AdjustmentUncheckedCreateWithoutWarehouseInput> | AdjustmentCreateWithoutWarehouseInput[] | AdjustmentUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: AdjustmentCreateOrConnectWithoutWarehouseInput | AdjustmentCreateOrConnectWithoutWarehouseInput[]
    createMany?: AdjustmentCreateManyWarehouseInputEnvelope
    connect?: AdjustmentWhereUniqueInput | AdjustmentWhereUniqueInput[]
  }

  export type StockMoveCreateNestedManyWithoutFromWarehouseInput = {
    create?: XOR<StockMoveCreateWithoutFromWarehouseInput, StockMoveUncheckedCreateWithoutFromWarehouseInput> | StockMoveCreateWithoutFromWarehouseInput[] | StockMoveUncheckedCreateWithoutFromWarehouseInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutFromWarehouseInput | StockMoveCreateOrConnectWithoutFromWarehouseInput[]
    createMany?: StockMoveCreateManyFromWarehouseInputEnvelope
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
  }

  export type StockMoveCreateNestedManyWithoutToWarehouseInput = {
    create?: XOR<StockMoveCreateWithoutToWarehouseInput, StockMoveUncheckedCreateWithoutToWarehouseInput> | StockMoveCreateWithoutToWarehouseInput[] | StockMoveUncheckedCreateWithoutToWarehouseInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutToWarehouseInput | StockMoveCreateOrConnectWithoutToWarehouseInput[]
    createMany?: StockMoveCreateManyToWarehouseInputEnvelope
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
  }

  export type ReorderRuleCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<ReorderRuleCreateWithoutWarehouseInput, ReorderRuleUncheckedCreateWithoutWarehouseInput> | ReorderRuleCreateWithoutWarehouseInput[] | ReorderRuleUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ReorderRuleCreateOrConnectWithoutWarehouseInput | ReorderRuleCreateOrConnectWithoutWarehouseInput[]
    createMany?: ReorderRuleCreateManyWarehouseInputEnvelope
    connect?: ReorderRuleWhereUniqueInput | ReorderRuleWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<LocationCreateWithoutWarehouseInput, LocationUncheckedCreateWithoutWarehouseInput> | LocationCreateWithoutWarehouseInput[] | LocationUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutWarehouseInput | LocationCreateOrConnectWithoutWarehouseInput[]
    createMany?: LocationCreateManyWarehouseInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type StockQuantUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<StockQuantCreateWithoutWarehouseInput, StockQuantUncheckedCreateWithoutWarehouseInput> | StockQuantCreateWithoutWarehouseInput[] | StockQuantUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: StockQuantCreateOrConnectWithoutWarehouseInput | StockQuantCreateOrConnectWithoutWarehouseInput[]
    createMany?: StockQuantCreateManyWarehouseInputEnvelope
    connect?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
  }

  export type ReceiptUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<ReceiptCreateWithoutWarehouseInput, ReceiptUncheckedCreateWithoutWarehouseInput> | ReceiptCreateWithoutWarehouseInput[] | ReceiptUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutWarehouseInput | ReceiptCreateOrConnectWithoutWarehouseInput[]
    createMany?: ReceiptCreateManyWarehouseInputEnvelope
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
  }

  export type DeliveryUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<DeliveryCreateWithoutWarehouseInput, DeliveryUncheckedCreateWithoutWarehouseInput> | DeliveryCreateWithoutWarehouseInput[] | DeliveryUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutWarehouseInput | DeliveryCreateOrConnectWithoutWarehouseInput[]
    createMany?: DeliveryCreateManyWarehouseInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutFromWarehouseInput = {
    create?: XOR<TransferCreateWithoutFromWarehouseInput, TransferUncheckedCreateWithoutFromWarehouseInput> | TransferCreateWithoutFromWarehouseInput[] | TransferUncheckedCreateWithoutFromWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromWarehouseInput | TransferCreateOrConnectWithoutFromWarehouseInput[]
    createMany?: TransferCreateManyFromWarehouseInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutToWarehouseInput = {
    create?: XOR<TransferCreateWithoutToWarehouseInput, TransferUncheckedCreateWithoutToWarehouseInput> | TransferCreateWithoutToWarehouseInput[] | TransferUncheckedCreateWithoutToWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToWarehouseInput | TransferCreateOrConnectWithoutToWarehouseInput[]
    createMany?: TransferCreateManyToWarehouseInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type AdjustmentUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<AdjustmentCreateWithoutWarehouseInput, AdjustmentUncheckedCreateWithoutWarehouseInput> | AdjustmentCreateWithoutWarehouseInput[] | AdjustmentUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: AdjustmentCreateOrConnectWithoutWarehouseInput | AdjustmentCreateOrConnectWithoutWarehouseInput[]
    createMany?: AdjustmentCreateManyWarehouseInputEnvelope
    connect?: AdjustmentWhereUniqueInput | AdjustmentWhereUniqueInput[]
  }

  export type StockMoveUncheckedCreateNestedManyWithoutFromWarehouseInput = {
    create?: XOR<StockMoveCreateWithoutFromWarehouseInput, StockMoveUncheckedCreateWithoutFromWarehouseInput> | StockMoveCreateWithoutFromWarehouseInput[] | StockMoveUncheckedCreateWithoutFromWarehouseInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutFromWarehouseInput | StockMoveCreateOrConnectWithoutFromWarehouseInput[]
    createMany?: StockMoveCreateManyFromWarehouseInputEnvelope
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
  }

  export type StockMoveUncheckedCreateNestedManyWithoutToWarehouseInput = {
    create?: XOR<StockMoveCreateWithoutToWarehouseInput, StockMoveUncheckedCreateWithoutToWarehouseInput> | StockMoveCreateWithoutToWarehouseInput[] | StockMoveUncheckedCreateWithoutToWarehouseInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutToWarehouseInput | StockMoveCreateOrConnectWithoutToWarehouseInput[]
    createMany?: StockMoveCreateManyToWarehouseInputEnvelope
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
  }

  export type ReorderRuleUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<ReorderRuleCreateWithoutWarehouseInput, ReorderRuleUncheckedCreateWithoutWarehouseInput> | ReorderRuleCreateWithoutWarehouseInput[] | ReorderRuleUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ReorderRuleCreateOrConnectWithoutWarehouseInput | ReorderRuleCreateOrConnectWithoutWarehouseInput[]
    createMany?: ReorderRuleCreateManyWarehouseInputEnvelope
    connect?: ReorderRuleWhereUniqueInput | ReorderRuleWhereUniqueInput[]
  }

  export type LocationUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<LocationCreateWithoutWarehouseInput, LocationUncheckedCreateWithoutWarehouseInput> | LocationCreateWithoutWarehouseInput[] | LocationUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutWarehouseInput | LocationCreateOrConnectWithoutWarehouseInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutWarehouseInput | LocationUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: LocationCreateManyWarehouseInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutWarehouseInput | LocationUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutWarehouseInput | LocationUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type StockQuantUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<StockQuantCreateWithoutWarehouseInput, StockQuantUncheckedCreateWithoutWarehouseInput> | StockQuantCreateWithoutWarehouseInput[] | StockQuantUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: StockQuantCreateOrConnectWithoutWarehouseInput | StockQuantCreateOrConnectWithoutWarehouseInput[]
    upsert?: StockQuantUpsertWithWhereUniqueWithoutWarehouseInput | StockQuantUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: StockQuantCreateManyWarehouseInputEnvelope
    set?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    disconnect?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    delete?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    connect?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    update?: StockQuantUpdateWithWhereUniqueWithoutWarehouseInput | StockQuantUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: StockQuantUpdateManyWithWhereWithoutWarehouseInput | StockQuantUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: StockQuantScalarWhereInput | StockQuantScalarWhereInput[]
  }

  export type ReceiptUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<ReceiptCreateWithoutWarehouseInput, ReceiptUncheckedCreateWithoutWarehouseInput> | ReceiptCreateWithoutWarehouseInput[] | ReceiptUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutWarehouseInput | ReceiptCreateOrConnectWithoutWarehouseInput[]
    upsert?: ReceiptUpsertWithWhereUniqueWithoutWarehouseInput | ReceiptUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: ReceiptCreateManyWarehouseInputEnvelope
    set?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    disconnect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    delete?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    update?: ReceiptUpdateWithWhereUniqueWithoutWarehouseInput | ReceiptUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: ReceiptUpdateManyWithWhereWithoutWarehouseInput | ReceiptUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: ReceiptScalarWhereInput | ReceiptScalarWhereInput[]
  }

  export type DeliveryUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<DeliveryCreateWithoutWarehouseInput, DeliveryUncheckedCreateWithoutWarehouseInput> | DeliveryCreateWithoutWarehouseInput[] | DeliveryUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutWarehouseInput | DeliveryCreateOrConnectWithoutWarehouseInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutWarehouseInput | DeliveryUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: DeliveryCreateManyWarehouseInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutWarehouseInput | DeliveryUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutWarehouseInput | DeliveryUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutFromWarehouseNestedInput = {
    create?: XOR<TransferCreateWithoutFromWarehouseInput, TransferUncheckedCreateWithoutFromWarehouseInput> | TransferCreateWithoutFromWarehouseInput[] | TransferUncheckedCreateWithoutFromWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromWarehouseInput | TransferCreateOrConnectWithoutFromWarehouseInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutFromWarehouseInput | TransferUpsertWithWhereUniqueWithoutFromWarehouseInput[]
    createMany?: TransferCreateManyFromWarehouseInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutFromWarehouseInput | TransferUpdateWithWhereUniqueWithoutFromWarehouseInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutFromWarehouseInput | TransferUpdateManyWithWhereWithoutFromWarehouseInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutToWarehouseNestedInput = {
    create?: XOR<TransferCreateWithoutToWarehouseInput, TransferUncheckedCreateWithoutToWarehouseInput> | TransferCreateWithoutToWarehouseInput[] | TransferUncheckedCreateWithoutToWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToWarehouseInput | TransferCreateOrConnectWithoutToWarehouseInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutToWarehouseInput | TransferUpsertWithWhereUniqueWithoutToWarehouseInput[]
    createMany?: TransferCreateManyToWarehouseInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutToWarehouseInput | TransferUpdateWithWhereUniqueWithoutToWarehouseInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutToWarehouseInput | TransferUpdateManyWithWhereWithoutToWarehouseInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type AdjustmentUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<AdjustmentCreateWithoutWarehouseInput, AdjustmentUncheckedCreateWithoutWarehouseInput> | AdjustmentCreateWithoutWarehouseInput[] | AdjustmentUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: AdjustmentCreateOrConnectWithoutWarehouseInput | AdjustmentCreateOrConnectWithoutWarehouseInput[]
    upsert?: AdjustmentUpsertWithWhereUniqueWithoutWarehouseInput | AdjustmentUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: AdjustmentCreateManyWarehouseInputEnvelope
    set?: AdjustmentWhereUniqueInput | AdjustmentWhereUniqueInput[]
    disconnect?: AdjustmentWhereUniqueInput | AdjustmentWhereUniqueInput[]
    delete?: AdjustmentWhereUniqueInput | AdjustmentWhereUniqueInput[]
    connect?: AdjustmentWhereUniqueInput | AdjustmentWhereUniqueInput[]
    update?: AdjustmentUpdateWithWhereUniqueWithoutWarehouseInput | AdjustmentUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: AdjustmentUpdateManyWithWhereWithoutWarehouseInput | AdjustmentUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: AdjustmentScalarWhereInput | AdjustmentScalarWhereInput[]
  }

  export type StockMoveUpdateManyWithoutFromWarehouseNestedInput = {
    create?: XOR<StockMoveCreateWithoutFromWarehouseInput, StockMoveUncheckedCreateWithoutFromWarehouseInput> | StockMoveCreateWithoutFromWarehouseInput[] | StockMoveUncheckedCreateWithoutFromWarehouseInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutFromWarehouseInput | StockMoveCreateOrConnectWithoutFromWarehouseInput[]
    upsert?: StockMoveUpsertWithWhereUniqueWithoutFromWarehouseInput | StockMoveUpsertWithWhereUniqueWithoutFromWarehouseInput[]
    createMany?: StockMoveCreateManyFromWarehouseInputEnvelope
    set?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    disconnect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    delete?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    update?: StockMoveUpdateWithWhereUniqueWithoutFromWarehouseInput | StockMoveUpdateWithWhereUniqueWithoutFromWarehouseInput[]
    updateMany?: StockMoveUpdateManyWithWhereWithoutFromWarehouseInput | StockMoveUpdateManyWithWhereWithoutFromWarehouseInput[]
    deleteMany?: StockMoveScalarWhereInput | StockMoveScalarWhereInput[]
  }

  export type StockMoveUpdateManyWithoutToWarehouseNestedInput = {
    create?: XOR<StockMoveCreateWithoutToWarehouseInput, StockMoveUncheckedCreateWithoutToWarehouseInput> | StockMoveCreateWithoutToWarehouseInput[] | StockMoveUncheckedCreateWithoutToWarehouseInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutToWarehouseInput | StockMoveCreateOrConnectWithoutToWarehouseInput[]
    upsert?: StockMoveUpsertWithWhereUniqueWithoutToWarehouseInput | StockMoveUpsertWithWhereUniqueWithoutToWarehouseInput[]
    createMany?: StockMoveCreateManyToWarehouseInputEnvelope
    set?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    disconnect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    delete?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    update?: StockMoveUpdateWithWhereUniqueWithoutToWarehouseInput | StockMoveUpdateWithWhereUniqueWithoutToWarehouseInput[]
    updateMany?: StockMoveUpdateManyWithWhereWithoutToWarehouseInput | StockMoveUpdateManyWithWhereWithoutToWarehouseInput[]
    deleteMany?: StockMoveScalarWhereInput | StockMoveScalarWhereInput[]
  }

  export type ReorderRuleUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<ReorderRuleCreateWithoutWarehouseInput, ReorderRuleUncheckedCreateWithoutWarehouseInput> | ReorderRuleCreateWithoutWarehouseInput[] | ReorderRuleUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ReorderRuleCreateOrConnectWithoutWarehouseInput | ReorderRuleCreateOrConnectWithoutWarehouseInput[]
    upsert?: ReorderRuleUpsertWithWhereUniqueWithoutWarehouseInput | ReorderRuleUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: ReorderRuleCreateManyWarehouseInputEnvelope
    set?: ReorderRuleWhereUniqueInput | ReorderRuleWhereUniqueInput[]
    disconnect?: ReorderRuleWhereUniqueInput | ReorderRuleWhereUniqueInput[]
    delete?: ReorderRuleWhereUniqueInput | ReorderRuleWhereUniqueInput[]
    connect?: ReorderRuleWhereUniqueInput | ReorderRuleWhereUniqueInput[]
    update?: ReorderRuleUpdateWithWhereUniqueWithoutWarehouseInput | ReorderRuleUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: ReorderRuleUpdateManyWithWhereWithoutWarehouseInput | ReorderRuleUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: ReorderRuleScalarWhereInput | ReorderRuleScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<LocationCreateWithoutWarehouseInput, LocationUncheckedCreateWithoutWarehouseInput> | LocationCreateWithoutWarehouseInput[] | LocationUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutWarehouseInput | LocationCreateOrConnectWithoutWarehouseInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutWarehouseInput | LocationUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: LocationCreateManyWarehouseInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutWarehouseInput | LocationUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutWarehouseInput | LocationUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type StockQuantUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<StockQuantCreateWithoutWarehouseInput, StockQuantUncheckedCreateWithoutWarehouseInput> | StockQuantCreateWithoutWarehouseInput[] | StockQuantUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: StockQuantCreateOrConnectWithoutWarehouseInput | StockQuantCreateOrConnectWithoutWarehouseInput[]
    upsert?: StockQuantUpsertWithWhereUniqueWithoutWarehouseInput | StockQuantUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: StockQuantCreateManyWarehouseInputEnvelope
    set?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    disconnect?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    delete?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    connect?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    update?: StockQuantUpdateWithWhereUniqueWithoutWarehouseInput | StockQuantUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: StockQuantUpdateManyWithWhereWithoutWarehouseInput | StockQuantUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: StockQuantScalarWhereInput | StockQuantScalarWhereInput[]
  }

  export type ReceiptUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<ReceiptCreateWithoutWarehouseInput, ReceiptUncheckedCreateWithoutWarehouseInput> | ReceiptCreateWithoutWarehouseInput[] | ReceiptUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutWarehouseInput | ReceiptCreateOrConnectWithoutWarehouseInput[]
    upsert?: ReceiptUpsertWithWhereUniqueWithoutWarehouseInput | ReceiptUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: ReceiptCreateManyWarehouseInputEnvelope
    set?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    disconnect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    delete?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    update?: ReceiptUpdateWithWhereUniqueWithoutWarehouseInput | ReceiptUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: ReceiptUpdateManyWithWhereWithoutWarehouseInput | ReceiptUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: ReceiptScalarWhereInput | ReceiptScalarWhereInput[]
  }

  export type DeliveryUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<DeliveryCreateWithoutWarehouseInput, DeliveryUncheckedCreateWithoutWarehouseInput> | DeliveryCreateWithoutWarehouseInput[] | DeliveryUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutWarehouseInput | DeliveryCreateOrConnectWithoutWarehouseInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutWarehouseInput | DeliveryUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: DeliveryCreateManyWarehouseInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutWarehouseInput | DeliveryUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutWarehouseInput | DeliveryUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutFromWarehouseNestedInput = {
    create?: XOR<TransferCreateWithoutFromWarehouseInput, TransferUncheckedCreateWithoutFromWarehouseInput> | TransferCreateWithoutFromWarehouseInput[] | TransferUncheckedCreateWithoutFromWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromWarehouseInput | TransferCreateOrConnectWithoutFromWarehouseInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutFromWarehouseInput | TransferUpsertWithWhereUniqueWithoutFromWarehouseInput[]
    createMany?: TransferCreateManyFromWarehouseInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutFromWarehouseInput | TransferUpdateWithWhereUniqueWithoutFromWarehouseInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutFromWarehouseInput | TransferUpdateManyWithWhereWithoutFromWarehouseInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutToWarehouseNestedInput = {
    create?: XOR<TransferCreateWithoutToWarehouseInput, TransferUncheckedCreateWithoutToWarehouseInput> | TransferCreateWithoutToWarehouseInput[] | TransferUncheckedCreateWithoutToWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToWarehouseInput | TransferCreateOrConnectWithoutToWarehouseInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutToWarehouseInput | TransferUpsertWithWhereUniqueWithoutToWarehouseInput[]
    createMany?: TransferCreateManyToWarehouseInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutToWarehouseInput | TransferUpdateWithWhereUniqueWithoutToWarehouseInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutToWarehouseInput | TransferUpdateManyWithWhereWithoutToWarehouseInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type AdjustmentUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<AdjustmentCreateWithoutWarehouseInput, AdjustmentUncheckedCreateWithoutWarehouseInput> | AdjustmentCreateWithoutWarehouseInput[] | AdjustmentUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: AdjustmentCreateOrConnectWithoutWarehouseInput | AdjustmentCreateOrConnectWithoutWarehouseInput[]
    upsert?: AdjustmentUpsertWithWhereUniqueWithoutWarehouseInput | AdjustmentUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: AdjustmentCreateManyWarehouseInputEnvelope
    set?: AdjustmentWhereUniqueInput | AdjustmentWhereUniqueInput[]
    disconnect?: AdjustmentWhereUniqueInput | AdjustmentWhereUniqueInput[]
    delete?: AdjustmentWhereUniqueInput | AdjustmentWhereUniqueInput[]
    connect?: AdjustmentWhereUniqueInput | AdjustmentWhereUniqueInput[]
    update?: AdjustmentUpdateWithWhereUniqueWithoutWarehouseInput | AdjustmentUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: AdjustmentUpdateManyWithWhereWithoutWarehouseInput | AdjustmentUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: AdjustmentScalarWhereInput | AdjustmentScalarWhereInput[]
  }

  export type StockMoveUncheckedUpdateManyWithoutFromWarehouseNestedInput = {
    create?: XOR<StockMoveCreateWithoutFromWarehouseInput, StockMoveUncheckedCreateWithoutFromWarehouseInput> | StockMoveCreateWithoutFromWarehouseInput[] | StockMoveUncheckedCreateWithoutFromWarehouseInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutFromWarehouseInput | StockMoveCreateOrConnectWithoutFromWarehouseInput[]
    upsert?: StockMoveUpsertWithWhereUniqueWithoutFromWarehouseInput | StockMoveUpsertWithWhereUniqueWithoutFromWarehouseInput[]
    createMany?: StockMoveCreateManyFromWarehouseInputEnvelope
    set?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    disconnect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    delete?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    update?: StockMoveUpdateWithWhereUniqueWithoutFromWarehouseInput | StockMoveUpdateWithWhereUniqueWithoutFromWarehouseInput[]
    updateMany?: StockMoveUpdateManyWithWhereWithoutFromWarehouseInput | StockMoveUpdateManyWithWhereWithoutFromWarehouseInput[]
    deleteMany?: StockMoveScalarWhereInput | StockMoveScalarWhereInput[]
  }

  export type StockMoveUncheckedUpdateManyWithoutToWarehouseNestedInput = {
    create?: XOR<StockMoveCreateWithoutToWarehouseInput, StockMoveUncheckedCreateWithoutToWarehouseInput> | StockMoveCreateWithoutToWarehouseInput[] | StockMoveUncheckedCreateWithoutToWarehouseInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutToWarehouseInput | StockMoveCreateOrConnectWithoutToWarehouseInput[]
    upsert?: StockMoveUpsertWithWhereUniqueWithoutToWarehouseInput | StockMoveUpsertWithWhereUniqueWithoutToWarehouseInput[]
    createMany?: StockMoveCreateManyToWarehouseInputEnvelope
    set?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    disconnect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    delete?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    update?: StockMoveUpdateWithWhereUniqueWithoutToWarehouseInput | StockMoveUpdateWithWhereUniqueWithoutToWarehouseInput[]
    updateMany?: StockMoveUpdateManyWithWhereWithoutToWarehouseInput | StockMoveUpdateManyWithWhereWithoutToWarehouseInput[]
    deleteMany?: StockMoveScalarWhereInput | StockMoveScalarWhereInput[]
  }

  export type ReorderRuleUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<ReorderRuleCreateWithoutWarehouseInput, ReorderRuleUncheckedCreateWithoutWarehouseInput> | ReorderRuleCreateWithoutWarehouseInput[] | ReorderRuleUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ReorderRuleCreateOrConnectWithoutWarehouseInput | ReorderRuleCreateOrConnectWithoutWarehouseInput[]
    upsert?: ReorderRuleUpsertWithWhereUniqueWithoutWarehouseInput | ReorderRuleUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: ReorderRuleCreateManyWarehouseInputEnvelope
    set?: ReorderRuleWhereUniqueInput | ReorderRuleWhereUniqueInput[]
    disconnect?: ReorderRuleWhereUniqueInput | ReorderRuleWhereUniqueInput[]
    delete?: ReorderRuleWhereUniqueInput | ReorderRuleWhereUniqueInput[]
    connect?: ReorderRuleWhereUniqueInput | ReorderRuleWhereUniqueInput[]
    update?: ReorderRuleUpdateWithWhereUniqueWithoutWarehouseInput | ReorderRuleUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: ReorderRuleUpdateManyWithWhereWithoutWarehouseInput | ReorderRuleUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: ReorderRuleScalarWhereInput | ReorderRuleScalarWhereInput[]
  }

  export type WarehouseCreateNestedOneWithoutLocationsInput = {
    create?: XOR<WarehouseCreateWithoutLocationsInput, WarehouseUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutLocationsInput
    connect?: WarehouseWhereUniqueInput
  }

  export type StockQuantCreateNestedManyWithoutLocationInput = {
    create?: XOR<StockQuantCreateWithoutLocationInput, StockQuantUncheckedCreateWithoutLocationInput> | StockQuantCreateWithoutLocationInput[] | StockQuantUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StockQuantCreateOrConnectWithoutLocationInput | StockQuantCreateOrConnectWithoutLocationInput[]
    createMany?: StockQuantCreateManyLocationInputEnvelope
    connect?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
  }

  export type StockMoveCreateNestedManyWithoutFromLocationInput = {
    create?: XOR<StockMoveCreateWithoutFromLocationInput, StockMoveUncheckedCreateWithoutFromLocationInput> | StockMoveCreateWithoutFromLocationInput[] | StockMoveUncheckedCreateWithoutFromLocationInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutFromLocationInput | StockMoveCreateOrConnectWithoutFromLocationInput[]
    createMany?: StockMoveCreateManyFromLocationInputEnvelope
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
  }

  export type StockMoveCreateNestedManyWithoutToLocationInput = {
    create?: XOR<StockMoveCreateWithoutToLocationInput, StockMoveUncheckedCreateWithoutToLocationInput> | StockMoveCreateWithoutToLocationInput[] | StockMoveUncheckedCreateWithoutToLocationInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutToLocationInput | StockMoveCreateOrConnectWithoutToLocationInput[]
    createMany?: StockMoveCreateManyToLocationInputEnvelope
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
  }

  export type StockQuantUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<StockQuantCreateWithoutLocationInput, StockQuantUncheckedCreateWithoutLocationInput> | StockQuantCreateWithoutLocationInput[] | StockQuantUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StockQuantCreateOrConnectWithoutLocationInput | StockQuantCreateOrConnectWithoutLocationInput[]
    createMany?: StockQuantCreateManyLocationInputEnvelope
    connect?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
  }

  export type StockMoveUncheckedCreateNestedManyWithoutFromLocationInput = {
    create?: XOR<StockMoveCreateWithoutFromLocationInput, StockMoveUncheckedCreateWithoutFromLocationInput> | StockMoveCreateWithoutFromLocationInput[] | StockMoveUncheckedCreateWithoutFromLocationInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutFromLocationInput | StockMoveCreateOrConnectWithoutFromLocationInput[]
    createMany?: StockMoveCreateManyFromLocationInputEnvelope
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
  }

  export type StockMoveUncheckedCreateNestedManyWithoutToLocationInput = {
    create?: XOR<StockMoveCreateWithoutToLocationInput, StockMoveUncheckedCreateWithoutToLocationInput> | StockMoveCreateWithoutToLocationInput[] | StockMoveUncheckedCreateWithoutToLocationInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutToLocationInput | StockMoveCreateOrConnectWithoutToLocationInput[]
    createMany?: StockMoveCreateManyToLocationInputEnvelope
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
  }

  export type WarehouseUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<WarehouseCreateWithoutLocationsInput, WarehouseUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutLocationsInput
    upsert?: WarehouseUpsertWithoutLocationsInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutLocationsInput, WarehouseUpdateWithoutLocationsInput>, WarehouseUncheckedUpdateWithoutLocationsInput>
  }

  export type StockQuantUpdateManyWithoutLocationNestedInput = {
    create?: XOR<StockQuantCreateWithoutLocationInput, StockQuantUncheckedCreateWithoutLocationInput> | StockQuantCreateWithoutLocationInput[] | StockQuantUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StockQuantCreateOrConnectWithoutLocationInput | StockQuantCreateOrConnectWithoutLocationInput[]
    upsert?: StockQuantUpsertWithWhereUniqueWithoutLocationInput | StockQuantUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: StockQuantCreateManyLocationInputEnvelope
    set?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    disconnect?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    delete?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    connect?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    update?: StockQuantUpdateWithWhereUniqueWithoutLocationInput | StockQuantUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: StockQuantUpdateManyWithWhereWithoutLocationInput | StockQuantUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: StockQuantScalarWhereInput | StockQuantScalarWhereInput[]
  }

  export type StockMoveUpdateManyWithoutFromLocationNestedInput = {
    create?: XOR<StockMoveCreateWithoutFromLocationInput, StockMoveUncheckedCreateWithoutFromLocationInput> | StockMoveCreateWithoutFromLocationInput[] | StockMoveUncheckedCreateWithoutFromLocationInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutFromLocationInput | StockMoveCreateOrConnectWithoutFromLocationInput[]
    upsert?: StockMoveUpsertWithWhereUniqueWithoutFromLocationInput | StockMoveUpsertWithWhereUniqueWithoutFromLocationInput[]
    createMany?: StockMoveCreateManyFromLocationInputEnvelope
    set?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    disconnect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    delete?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    update?: StockMoveUpdateWithWhereUniqueWithoutFromLocationInput | StockMoveUpdateWithWhereUniqueWithoutFromLocationInput[]
    updateMany?: StockMoveUpdateManyWithWhereWithoutFromLocationInput | StockMoveUpdateManyWithWhereWithoutFromLocationInput[]
    deleteMany?: StockMoveScalarWhereInput | StockMoveScalarWhereInput[]
  }

  export type StockMoveUpdateManyWithoutToLocationNestedInput = {
    create?: XOR<StockMoveCreateWithoutToLocationInput, StockMoveUncheckedCreateWithoutToLocationInput> | StockMoveCreateWithoutToLocationInput[] | StockMoveUncheckedCreateWithoutToLocationInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutToLocationInput | StockMoveCreateOrConnectWithoutToLocationInput[]
    upsert?: StockMoveUpsertWithWhereUniqueWithoutToLocationInput | StockMoveUpsertWithWhereUniqueWithoutToLocationInput[]
    createMany?: StockMoveCreateManyToLocationInputEnvelope
    set?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    disconnect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    delete?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    update?: StockMoveUpdateWithWhereUniqueWithoutToLocationInput | StockMoveUpdateWithWhereUniqueWithoutToLocationInput[]
    updateMany?: StockMoveUpdateManyWithWhereWithoutToLocationInput | StockMoveUpdateManyWithWhereWithoutToLocationInput[]
    deleteMany?: StockMoveScalarWhereInput | StockMoveScalarWhereInput[]
  }

  export type StockQuantUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<StockQuantCreateWithoutLocationInput, StockQuantUncheckedCreateWithoutLocationInput> | StockQuantCreateWithoutLocationInput[] | StockQuantUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StockQuantCreateOrConnectWithoutLocationInput | StockQuantCreateOrConnectWithoutLocationInput[]
    upsert?: StockQuantUpsertWithWhereUniqueWithoutLocationInput | StockQuantUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: StockQuantCreateManyLocationInputEnvelope
    set?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    disconnect?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    delete?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    connect?: StockQuantWhereUniqueInput | StockQuantWhereUniqueInput[]
    update?: StockQuantUpdateWithWhereUniqueWithoutLocationInput | StockQuantUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: StockQuantUpdateManyWithWhereWithoutLocationInput | StockQuantUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: StockQuantScalarWhereInput | StockQuantScalarWhereInput[]
  }

  export type StockMoveUncheckedUpdateManyWithoutFromLocationNestedInput = {
    create?: XOR<StockMoveCreateWithoutFromLocationInput, StockMoveUncheckedCreateWithoutFromLocationInput> | StockMoveCreateWithoutFromLocationInput[] | StockMoveUncheckedCreateWithoutFromLocationInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutFromLocationInput | StockMoveCreateOrConnectWithoutFromLocationInput[]
    upsert?: StockMoveUpsertWithWhereUniqueWithoutFromLocationInput | StockMoveUpsertWithWhereUniqueWithoutFromLocationInput[]
    createMany?: StockMoveCreateManyFromLocationInputEnvelope
    set?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    disconnect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    delete?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    update?: StockMoveUpdateWithWhereUniqueWithoutFromLocationInput | StockMoveUpdateWithWhereUniqueWithoutFromLocationInput[]
    updateMany?: StockMoveUpdateManyWithWhereWithoutFromLocationInput | StockMoveUpdateManyWithWhereWithoutFromLocationInput[]
    deleteMany?: StockMoveScalarWhereInput | StockMoveScalarWhereInput[]
  }

  export type StockMoveUncheckedUpdateManyWithoutToLocationNestedInput = {
    create?: XOR<StockMoveCreateWithoutToLocationInput, StockMoveUncheckedCreateWithoutToLocationInput> | StockMoveCreateWithoutToLocationInput[] | StockMoveUncheckedCreateWithoutToLocationInput[]
    connectOrCreate?: StockMoveCreateOrConnectWithoutToLocationInput | StockMoveCreateOrConnectWithoutToLocationInput[]
    upsert?: StockMoveUpsertWithWhereUniqueWithoutToLocationInput | StockMoveUpsertWithWhereUniqueWithoutToLocationInput[]
    createMany?: StockMoveCreateManyToLocationInputEnvelope
    set?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    disconnect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    delete?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    connect?: StockMoveWhereUniqueInput | StockMoveWhereUniqueInput[]
    update?: StockMoveUpdateWithWhereUniqueWithoutToLocationInput | StockMoveUpdateWithWhereUniqueWithoutToLocationInput[]
    updateMany?: StockMoveUpdateManyWithWhereWithoutToLocationInput | StockMoveUpdateManyWithWhereWithoutToLocationInput[]
    deleteMany?: StockMoveScalarWhereInput | StockMoveScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutStockQuantsInput = {
    create?: XOR<ProductCreateWithoutStockQuantsInput, ProductUncheckedCreateWithoutStockQuantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockQuantsInput
    connect?: ProductWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutStockQuantsInput = {
    create?: XOR<WarehouseCreateWithoutStockQuantsInput, WarehouseUncheckedCreateWithoutStockQuantsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutStockQuantsInput
    connect?: WarehouseWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutStockQuantsInput = {
    create?: XOR<LocationCreateWithoutStockQuantsInput, LocationUncheckedCreateWithoutStockQuantsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutStockQuantsInput
    connect?: LocationWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutStockQuantsNestedInput = {
    create?: XOR<ProductCreateWithoutStockQuantsInput, ProductUncheckedCreateWithoutStockQuantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockQuantsInput
    upsert?: ProductUpsertWithoutStockQuantsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutStockQuantsInput, ProductUpdateWithoutStockQuantsInput>, ProductUncheckedUpdateWithoutStockQuantsInput>
  }

  export type WarehouseUpdateOneRequiredWithoutStockQuantsNestedInput = {
    create?: XOR<WarehouseCreateWithoutStockQuantsInput, WarehouseUncheckedCreateWithoutStockQuantsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutStockQuantsInput
    upsert?: WarehouseUpsertWithoutStockQuantsInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutStockQuantsInput, WarehouseUpdateWithoutStockQuantsInput>, WarehouseUncheckedUpdateWithoutStockQuantsInput>
  }

  export type LocationUpdateOneWithoutStockQuantsNestedInput = {
    create?: XOR<LocationCreateWithoutStockQuantsInput, LocationUncheckedCreateWithoutStockQuantsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutStockQuantsInput
    upsert?: LocationUpsertWithoutStockQuantsInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutStockQuantsInput, LocationUpdateWithoutStockQuantsInput>, LocationUncheckedUpdateWithoutStockQuantsInput>
  }

  export type WarehouseCreateNestedOneWithoutReceiptsInput = {
    create?: XOR<WarehouseCreateWithoutReceiptsInput, WarehouseUncheckedCreateWithoutReceiptsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutReceiptsInput
    connect?: WarehouseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceiptsCreatedInput = {
    create?: XOR<UserCreateWithoutReceiptsCreatedInput, UserUncheckedCreateWithoutReceiptsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceiptsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type ReceiptLineCreateNestedManyWithoutReceiptInput = {
    create?: XOR<ReceiptLineCreateWithoutReceiptInput, ReceiptLineUncheckedCreateWithoutReceiptInput> | ReceiptLineCreateWithoutReceiptInput[] | ReceiptLineUncheckedCreateWithoutReceiptInput[]
    connectOrCreate?: ReceiptLineCreateOrConnectWithoutReceiptInput | ReceiptLineCreateOrConnectWithoutReceiptInput[]
    createMany?: ReceiptLineCreateManyReceiptInputEnvelope
    connect?: ReceiptLineWhereUniqueInput | ReceiptLineWhereUniqueInput[]
  }

  export type ReceiptLineUncheckedCreateNestedManyWithoutReceiptInput = {
    create?: XOR<ReceiptLineCreateWithoutReceiptInput, ReceiptLineUncheckedCreateWithoutReceiptInput> | ReceiptLineCreateWithoutReceiptInput[] | ReceiptLineUncheckedCreateWithoutReceiptInput[]
    connectOrCreate?: ReceiptLineCreateOrConnectWithoutReceiptInput | ReceiptLineCreateOrConnectWithoutReceiptInput[]
    createMany?: ReceiptLineCreateManyReceiptInputEnvelope
    connect?: ReceiptLineWhereUniqueInput | ReceiptLineWhereUniqueInput[]
  }

  export type EnumDocumentStatusFieldUpdateOperationsInput = {
    set?: $Enums.DocumentStatus
  }

  export type WarehouseUpdateOneRequiredWithoutReceiptsNestedInput = {
    create?: XOR<WarehouseCreateWithoutReceiptsInput, WarehouseUncheckedCreateWithoutReceiptsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutReceiptsInput
    upsert?: WarehouseUpsertWithoutReceiptsInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutReceiptsInput, WarehouseUpdateWithoutReceiptsInput>, WarehouseUncheckedUpdateWithoutReceiptsInput>
  }

  export type UserUpdateOneWithoutReceiptsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutReceiptsCreatedInput, UserUncheckedCreateWithoutReceiptsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceiptsCreatedInput
    upsert?: UserUpsertWithoutReceiptsCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceiptsCreatedInput, UserUpdateWithoutReceiptsCreatedInput>, UserUncheckedUpdateWithoutReceiptsCreatedInput>
  }

  export type ReceiptLineUpdateManyWithoutReceiptNestedInput = {
    create?: XOR<ReceiptLineCreateWithoutReceiptInput, ReceiptLineUncheckedCreateWithoutReceiptInput> | ReceiptLineCreateWithoutReceiptInput[] | ReceiptLineUncheckedCreateWithoutReceiptInput[]
    connectOrCreate?: ReceiptLineCreateOrConnectWithoutReceiptInput | ReceiptLineCreateOrConnectWithoutReceiptInput[]
    upsert?: ReceiptLineUpsertWithWhereUniqueWithoutReceiptInput | ReceiptLineUpsertWithWhereUniqueWithoutReceiptInput[]
    createMany?: ReceiptLineCreateManyReceiptInputEnvelope
    set?: ReceiptLineWhereUniqueInput | ReceiptLineWhereUniqueInput[]
    disconnect?: ReceiptLineWhereUniqueInput | ReceiptLineWhereUniqueInput[]
    delete?: ReceiptLineWhereUniqueInput | ReceiptLineWhereUniqueInput[]
    connect?: ReceiptLineWhereUniqueInput | ReceiptLineWhereUniqueInput[]
    update?: ReceiptLineUpdateWithWhereUniqueWithoutReceiptInput | ReceiptLineUpdateWithWhereUniqueWithoutReceiptInput[]
    updateMany?: ReceiptLineUpdateManyWithWhereWithoutReceiptInput | ReceiptLineUpdateManyWithWhereWithoutReceiptInput[]
    deleteMany?: ReceiptLineScalarWhereInput | ReceiptLineScalarWhereInput[]
  }

  export type ReceiptLineUncheckedUpdateManyWithoutReceiptNestedInput = {
    create?: XOR<ReceiptLineCreateWithoutReceiptInput, ReceiptLineUncheckedCreateWithoutReceiptInput> | ReceiptLineCreateWithoutReceiptInput[] | ReceiptLineUncheckedCreateWithoutReceiptInput[]
    connectOrCreate?: ReceiptLineCreateOrConnectWithoutReceiptInput | ReceiptLineCreateOrConnectWithoutReceiptInput[]
    upsert?: ReceiptLineUpsertWithWhereUniqueWithoutReceiptInput | ReceiptLineUpsertWithWhereUniqueWithoutReceiptInput[]
    createMany?: ReceiptLineCreateManyReceiptInputEnvelope
    set?: ReceiptLineWhereUniqueInput | ReceiptLineWhereUniqueInput[]
    disconnect?: ReceiptLineWhereUniqueInput | ReceiptLineWhereUniqueInput[]
    delete?: ReceiptLineWhereUniqueInput | ReceiptLineWhereUniqueInput[]
    connect?: ReceiptLineWhereUniqueInput | ReceiptLineWhereUniqueInput[]
    update?: ReceiptLineUpdateWithWhereUniqueWithoutReceiptInput | ReceiptLineUpdateWithWhereUniqueWithoutReceiptInput[]
    updateMany?: ReceiptLineUpdateManyWithWhereWithoutReceiptInput | ReceiptLineUpdateManyWithWhereWithoutReceiptInput[]
    deleteMany?: ReceiptLineScalarWhereInput | ReceiptLineScalarWhereInput[]
  }

  export type ReceiptCreateNestedOneWithoutLinesInput = {
    create?: XOR<ReceiptCreateWithoutLinesInput, ReceiptUncheckedCreateWithoutLinesInput>
    connectOrCreate?: ReceiptCreateOrConnectWithoutLinesInput
    connect?: ReceiptWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutReceiptLinesInput = {
    create?: XOR<ProductCreateWithoutReceiptLinesInput, ProductUncheckedCreateWithoutReceiptLinesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReceiptLinesInput
    connect?: ProductWhereUniqueInput
  }

  export type ReceiptUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<ReceiptCreateWithoutLinesInput, ReceiptUncheckedCreateWithoutLinesInput>
    connectOrCreate?: ReceiptCreateOrConnectWithoutLinesInput
    upsert?: ReceiptUpsertWithoutLinesInput
    connect?: ReceiptWhereUniqueInput
    update?: XOR<XOR<ReceiptUpdateToOneWithWhereWithoutLinesInput, ReceiptUpdateWithoutLinesInput>, ReceiptUncheckedUpdateWithoutLinesInput>
  }

  export type ProductUpdateOneRequiredWithoutReceiptLinesNestedInput = {
    create?: XOR<ProductCreateWithoutReceiptLinesInput, ProductUncheckedCreateWithoutReceiptLinesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReceiptLinesInput
    upsert?: ProductUpsertWithoutReceiptLinesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutReceiptLinesInput, ProductUpdateWithoutReceiptLinesInput>, ProductUncheckedUpdateWithoutReceiptLinesInput>
  }

  export type WarehouseCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<WarehouseCreateWithoutDeliveriesInput, WarehouseUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutDeliveriesInput
    connect?: WarehouseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDeliveriesCreatedInput = {
    create?: XOR<UserCreateWithoutDeliveriesCreatedInput, UserUncheckedCreateWithoutDeliveriesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeliveriesCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type DeliveryLineCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<DeliveryLineCreateWithoutDeliveryInput, DeliveryLineUncheckedCreateWithoutDeliveryInput> | DeliveryLineCreateWithoutDeliveryInput[] | DeliveryLineUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: DeliveryLineCreateOrConnectWithoutDeliveryInput | DeliveryLineCreateOrConnectWithoutDeliveryInput[]
    createMany?: DeliveryLineCreateManyDeliveryInputEnvelope
    connect?: DeliveryLineWhereUniqueInput | DeliveryLineWhereUniqueInput[]
  }

  export type DeliveryLineUncheckedCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<DeliveryLineCreateWithoutDeliveryInput, DeliveryLineUncheckedCreateWithoutDeliveryInput> | DeliveryLineCreateWithoutDeliveryInput[] | DeliveryLineUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: DeliveryLineCreateOrConnectWithoutDeliveryInput | DeliveryLineCreateOrConnectWithoutDeliveryInput[]
    createMany?: DeliveryLineCreateManyDeliveryInputEnvelope
    connect?: DeliveryLineWhereUniqueInput | DeliveryLineWhereUniqueInput[]
  }

  export type WarehouseUpdateOneRequiredWithoutDeliveriesNestedInput = {
    create?: XOR<WarehouseCreateWithoutDeliveriesInput, WarehouseUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutDeliveriesInput
    upsert?: WarehouseUpsertWithoutDeliveriesInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutDeliveriesInput, WarehouseUpdateWithoutDeliveriesInput>, WarehouseUncheckedUpdateWithoutDeliveriesInput>
  }

  export type UserUpdateOneWithoutDeliveriesCreatedNestedInput = {
    create?: XOR<UserCreateWithoutDeliveriesCreatedInput, UserUncheckedCreateWithoutDeliveriesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeliveriesCreatedInput
    upsert?: UserUpsertWithoutDeliveriesCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeliveriesCreatedInput, UserUpdateWithoutDeliveriesCreatedInput>, UserUncheckedUpdateWithoutDeliveriesCreatedInput>
  }

  export type DeliveryLineUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<DeliveryLineCreateWithoutDeliveryInput, DeliveryLineUncheckedCreateWithoutDeliveryInput> | DeliveryLineCreateWithoutDeliveryInput[] | DeliveryLineUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: DeliveryLineCreateOrConnectWithoutDeliveryInput | DeliveryLineCreateOrConnectWithoutDeliveryInput[]
    upsert?: DeliveryLineUpsertWithWhereUniqueWithoutDeliveryInput | DeliveryLineUpsertWithWhereUniqueWithoutDeliveryInput[]
    createMany?: DeliveryLineCreateManyDeliveryInputEnvelope
    set?: DeliveryLineWhereUniqueInput | DeliveryLineWhereUniqueInput[]
    disconnect?: DeliveryLineWhereUniqueInput | DeliveryLineWhereUniqueInput[]
    delete?: DeliveryLineWhereUniqueInput | DeliveryLineWhereUniqueInput[]
    connect?: DeliveryLineWhereUniqueInput | DeliveryLineWhereUniqueInput[]
    update?: DeliveryLineUpdateWithWhereUniqueWithoutDeliveryInput | DeliveryLineUpdateWithWhereUniqueWithoutDeliveryInput[]
    updateMany?: DeliveryLineUpdateManyWithWhereWithoutDeliveryInput | DeliveryLineUpdateManyWithWhereWithoutDeliveryInput[]
    deleteMany?: DeliveryLineScalarWhereInput | DeliveryLineScalarWhereInput[]
  }

  export type DeliveryLineUncheckedUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<DeliveryLineCreateWithoutDeliveryInput, DeliveryLineUncheckedCreateWithoutDeliveryInput> | DeliveryLineCreateWithoutDeliveryInput[] | DeliveryLineUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: DeliveryLineCreateOrConnectWithoutDeliveryInput | DeliveryLineCreateOrConnectWithoutDeliveryInput[]
    upsert?: DeliveryLineUpsertWithWhereUniqueWithoutDeliveryInput | DeliveryLineUpsertWithWhereUniqueWithoutDeliveryInput[]
    createMany?: DeliveryLineCreateManyDeliveryInputEnvelope
    set?: DeliveryLineWhereUniqueInput | DeliveryLineWhereUniqueInput[]
    disconnect?: DeliveryLineWhereUniqueInput | DeliveryLineWhereUniqueInput[]
    delete?: DeliveryLineWhereUniqueInput | DeliveryLineWhereUniqueInput[]
    connect?: DeliveryLineWhereUniqueInput | DeliveryLineWhereUniqueInput[]
    update?: DeliveryLineUpdateWithWhereUniqueWithoutDeliveryInput | DeliveryLineUpdateWithWhereUniqueWithoutDeliveryInput[]
    updateMany?: DeliveryLineUpdateManyWithWhereWithoutDeliveryInput | DeliveryLineUpdateManyWithWhereWithoutDeliveryInput[]
    deleteMany?: DeliveryLineScalarWhereInput | DeliveryLineScalarWhereInput[]
  }

  export type DeliveryCreateNestedOneWithoutLinesInput = {
    create?: XOR<DeliveryCreateWithoutLinesInput, DeliveryUncheckedCreateWithoutLinesInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutLinesInput
    connect?: DeliveryWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutDeliveryLinesInput = {
    create?: XOR<ProductCreateWithoutDeliveryLinesInput, ProductUncheckedCreateWithoutDeliveryLinesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutDeliveryLinesInput
    connect?: ProductWhereUniqueInput
  }

  export type DeliveryUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<DeliveryCreateWithoutLinesInput, DeliveryUncheckedCreateWithoutLinesInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutLinesInput
    upsert?: DeliveryUpsertWithoutLinesInput
    connect?: DeliveryWhereUniqueInput
    update?: XOR<XOR<DeliveryUpdateToOneWithWhereWithoutLinesInput, DeliveryUpdateWithoutLinesInput>, DeliveryUncheckedUpdateWithoutLinesInput>
  }

  export type ProductUpdateOneRequiredWithoutDeliveryLinesNestedInput = {
    create?: XOR<ProductCreateWithoutDeliveryLinesInput, ProductUncheckedCreateWithoutDeliveryLinesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutDeliveryLinesInput
    upsert?: ProductUpsertWithoutDeliveryLinesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutDeliveryLinesInput, ProductUpdateWithoutDeliveryLinesInput>, ProductUncheckedUpdateWithoutDeliveryLinesInput>
  }

  export type WarehouseCreateNestedOneWithoutTransfersFromInput = {
    create?: XOR<WarehouseCreateWithoutTransfersFromInput, WarehouseUncheckedCreateWithoutTransfersFromInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutTransfersFromInput
    connect?: WarehouseWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutTransfersToInput = {
    create?: XOR<WarehouseCreateWithoutTransfersToInput, WarehouseUncheckedCreateWithoutTransfersToInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutTransfersToInput
    connect?: WarehouseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransfersCreatedInput = {
    create?: XOR<UserCreateWithoutTransfersCreatedInput, UserUncheckedCreateWithoutTransfersCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransfersCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type TransferLineCreateNestedManyWithoutTransferInput = {
    create?: XOR<TransferLineCreateWithoutTransferInput, TransferLineUncheckedCreateWithoutTransferInput> | TransferLineCreateWithoutTransferInput[] | TransferLineUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferLineCreateOrConnectWithoutTransferInput | TransferLineCreateOrConnectWithoutTransferInput[]
    createMany?: TransferLineCreateManyTransferInputEnvelope
    connect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
  }

  export type TransferLineUncheckedCreateNestedManyWithoutTransferInput = {
    create?: XOR<TransferLineCreateWithoutTransferInput, TransferLineUncheckedCreateWithoutTransferInput> | TransferLineCreateWithoutTransferInput[] | TransferLineUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferLineCreateOrConnectWithoutTransferInput | TransferLineCreateOrConnectWithoutTransferInput[]
    createMany?: TransferLineCreateManyTransferInputEnvelope
    connect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
  }

  export type WarehouseUpdateOneRequiredWithoutTransfersFromNestedInput = {
    create?: XOR<WarehouseCreateWithoutTransfersFromInput, WarehouseUncheckedCreateWithoutTransfersFromInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutTransfersFromInput
    upsert?: WarehouseUpsertWithoutTransfersFromInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutTransfersFromInput, WarehouseUpdateWithoutTransfersFromInput>, WarehouseUncheckedUpdateWithoutTransfersFromInput>
  }

  export type WarehouseUpdateOneRequiredWithoutTransfersToNestedInput = {
    create?: XOR<WarehouseCreateWithoutTransfersToInput, WarehouseUncheckedCreateWithoutTransfersToInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutTransfersToInput
    upsert?: WarehouseUpsertWithoutTransfersToInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutTransfersToInput, WarehouseUpdateWithoutTransfersToInput>, WarehouseUncheckedUpdateWithoutTransfersToInput>
  }

  export type UserUpdateOneWithoutTransfersCreatedNestedInput = {
    create?: XOR<UserCreateWithoutTransfersCreatedInput, UserUncheckedCreateWithoutTransfersCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransfersCreatedInput
    upsert?: UserUpsertWithoutTransfersCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransfersCreatedInput, UserUpdateWithoutTransfersCreatedInput>, UserUncheckedUpdateWithoutTransfersCreatedInput>
  }

  export type TransferLineUpdateManyWithoutTransferNestedInput = {
    create?: XOR<TransferLineCreateWithoutTransferInput, TransferLineUncheckedCreateWithoutTransferInput> | TransferLineCreateWithoutTransferInput[] | TransferLineUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferLineCreateOrConnectWithoutTransferInput | TransferLineCreateOrConnectWithoutTransferInput[]
    upsert?: TransferLineUpsertWithWhereUniqueWithoutTransferInput | TransferLineUpsertWithWhereUniqueWithoutTransferInput[]
    createMany?: TransferLineCreateManyTransferInputEnvelope
    set?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    disconnect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    delete?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    connect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    update?: TransferLineUpdateWithWhereUniqueWithoutTransferInput | TransferLineUpdateWithWhereUniqueWithoutTransferInput[]
    updateMany?: TransferLineUpdateManyWithWhereWithoutTransferInput | TransferLineUpdateManyWithWhereWithoutTransferInput[]
    deleteMany?: TransferLineScalarWhereInput | TransferLineScalarWhereInput[]
  }

  export type TransferLineUncheckedUpdateManyWithoutTransferNestedInput = {
    create?: XOR<TransferLineCreateWithoutTransferInput, TransferLineUncheckedCreateWithoutTransferInput> | TransferLineCreateWithoutTransferInput[] | TransferLineUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferLineCreateOrConnectWithoutTransferInput | TransferLineCreateOrConnectWithoutTransferInput[]
    upsert?: TransferLineUpsertWithWhereUniqueWithoutTransferInput | TransferLineUpsertWithWhereUniqueWithoutTransferInput[]
    createMany?: TransferLineCreateManyTransferInputEnvelope
    set?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    disconnect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    delete?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    connect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    update?: TransferLineUpdateWithWhereUniqueWithoutTransferInput | TransferLineUpdateWithWhereUniqueWithoutTransferInput[]
    updateMany?: TransferLineUpdateManyWithWhereWithoutTransferInput | TransferLineUpdateManyWithWhereWithoutTransferInput[]
    deleteMany?: TransferLineScalarWhereInput | TransferLineScalarWhereInput[]
  }

  export type TransferCreateNestedOneWithoutLinesInput = {
    create?: XOR<TransferCreateWithoutLinesInput, TransferUncheckedCreateWithoutLinesInput>
    connectOrCreate?: TransferCreateOrConnectWithoutLinesInput
    connect?: TransferWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutTransferLinesInput = {
    create?: XOR<ProductCreateWithoutTransferLinesInput, ProductUncheckedCreateWithoutTransferLinesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTransferLinesInput
    connect?: ProductWhereUniqueInput
  }

  export type TransferUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<TransferCreateWithoutLinesInput, TransferUncheckedCreateWithoutLinesInput>
    connectOrCreate?: TransferCreateOrConnectWithoutLinesInput
    upsert?: TransferUpsertWithoutLinesInput
    connect?: TransferWhereUniqueInput
    update?: XOR<XOR<TransferUpdateToOneWithWhereWithoutLinesInput, TransferUpdateWithoutLinesInput>, TransferUncheckedUpdateWithoutLinesInput>
  }

  export type ProductUpdateOneRequiredWithoutTransferLinesNestedInput = {
    create?: XOR<ProductCreateWithoutTransferLinesInput, ProductUncheckedCreateWithoutTransferLinesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTransferLinesInput
    upsert?: ProductUpsertWithoutTransferLinesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutTransferLinesInput, ProductUpdateWithoutTransferLinesInput>, ProductUncheckedUpdateWithoutTransferLinesInput>
  }

  export type WarehouseCreateNestedOneWithoutAdjustmentsInput = {
    create?: XOR<WarehouseCreateWithoutAdjustmentsInput, WarehouseUncheckedCreateWithoutAdjustmentsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutAdjustmentsInput
    connect?: WarehouseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAdjustmentsCreatedInput = {
    create?: XOR<UserCreateWithoutAdjustmentsCreatedInput, UserUncheckedCreateWithoutAdjustmentsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdjustmentsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type AdjustmentLineCreateNestedManyWithoutAdjustmentInput = {
    create?: XOR<AdjustmentLineCreateWithoutAdjustmentInput, AdjustmentLineUncheckedCreateWithoutAdjustmentInput> | AdjustmentLineCreateWithoutAdjustmentInput[] | AdjustmentLineUncheckedCreateWithoutAdjustmentInput[]
    connectOrCreate?: AdjustmentLineCreateOrConnectWithoutAdjustmentInput | AdjustmentLineCreateOrConnectWithoutAdjustmentInput[]
    createMany?: AdjustmentLineCreateManyAdjustmentInputEnvelope
    connect?: AdjustmentLineWhereUniqueInput | AdjustmentLineWhereUniqueInput[]
  }

  export type AdjustmentLineUncheckedCreateNestedManyWithoutAdjustmentInput = {
    create?: XOR<AdjustmentLineCreateWithoutAdjustmentInput, AdjustmentLineUncheckedCreateWithoutAdjustmentInput> | AdjustmentLineCreateWithoutAdjustmentInput[] | AdjustmentLineUncheckedCreateWithoutAdjustmentInput[]
    connectOrCreate?: AdjustmentLineCreateOrConnectWithoutAdjustmentInput | AdjustmentLineCreateOrConnectWithoutAdjustmentInput[]
    createMany?: AdjustmentLineCreateManyAdjustmentInputEnvelope
    connect?: AdjustmentLineWhereUniqueInput | AdjustmentLineWhereUniqueInput[]
  }

  export type WarehouseUpdateOneRequiredWithoutAdjustmentsNestedInput = {
    create?: XOR<WarehouseCreateWithoutAdjustmentsInput, WarehouseUncheckedCreateWithoutAdjustmentsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutAdjustmentsInput
    upsert?: WarehouseUpsertWithoutAdjustmentsInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutAdjustmentsInput, WarehouseUpdateWithoutAdjustmentsInput>, WarehouseUncheckedUpdateWithoutAdjustmentsInput>
  }

  export type UserUpdateOneWithoutAdjustmentsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutAdjustmentsCreatedInput, UserUncheckedCreateWithoutAdjustmentsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdjustmentsCreatedInput
    upsert?: UserUpsertWithoutAdjustmentsCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdjustmentsCreatedInput, UserUpdateWithoutAdjustmentsCreatedInput>, UserUncheckedUpdateWithoutAdjustmentsCreatedInput>
  }

  export type AdjustmentLineUpdateManyWithoutAdjustmentNestedInput = {
    create?: XOR<AdjustmentLineCreateWithoutAdjustmentInput, AdjustmentLineUncheckedCreateWithoutAdjustmentInput> | AdjustmentLineCreateWithoutAdjustmentInput[] | AdjustmentLineUncheckedCreateWithoutAdjustmentInput[]
    connectOrCreate?: AdjustmentLineCreateOrConnectWithoutAdjustmentInput | AdjustmentLineCreateOrConnectWithoutAdjustmentInput[]
    upsert?: AdjustmentLineUpsertWithWhereUniqueWithoutAdjustmentInput | AdjustmentLineUpsertWithWhereUniqueWithoutAdjustmentInput[]
    createMany?: AdjustmentLineCreateManyAdjustmentInputEnvelope
    set?: AdjustmentLineWhereUniqueInput | AdjustmentLineWhereUniqueInput[]
    disconnect?: AdjustmentLineWhereUniqueInput | AdjustmentLineWhereUniqueInput[]
    delete?: AdjustmentLineWhereUniqueInput | AdjustmentLineWhereUniqueInput[]
    connect?: AdjustmentLineWhereUniqueInput | AdjustmentLineWhereUniqueInput[]
    update?: AdjustmentLineUpdateWithWhereUniqueWithoutAdjustmentInput | AdjustmentLineUpdateWithWhereUniqueWithoutAdjustmentInput[]
    updateMany?: AdjustmentLineUpdateManyWithWhereWithoutAdjustmentInput | AdjustmentLineUpdateManyWithWhereWithoutAdjustmentInput[]
    deleteMany?: AdjustmentLineScalarWhereInput | AdjustmentLineScalarWhereInput[]
  }

  export type AdjustmentLineUncheckedUpdateManyWithoutAdjustmentNestedInput = {
    create?: XOR<AdjustmentLineCreateWithoutAdjustmentInput, AdjustmentLineUncheckedCreateWithoutAdjustmentInput> | AdjustmentLineCreateWithoutAdjustmentInput[] | AdjustmentLineUncheckedCreateWithoutAdjustmentInput[]
    connectOrCreate?: AdjustmentLineCreateOrConnectWithoutAdjustmentInput | AdjustmentLineCreateOrConnectWithoutAdjustmentInput[]
    upsert?: AdjustmentLineUpsertWithWhereUniqueWithoutAdjustmentInput | AdjustmentLineUpsertWithWhereUniqueWithoutAdjustmentInput[]
    createMany?: AdjustmentLineCreateManyAdjustmentInputEnvelope
    set?: AdjustmentLineWhereUniqueInput | AdjustmentLineWhereUniqueInput[]
    disconnect?: AdjustmentLineWhereUniqueInput | AdjustmentLineWhereUniqueInput[]
    delete?: AdjustmentLineWhereUniqueInput | AdjustmentLineWhereUniqueInput[]
    connect?: AdjustmentLineWhereUniqueInput | AdjustmentLineWhereUniqueInput[]
    update?: AdjustmentLineUpdateWithWhereUniqueWithoutAdjustmentInput | AdjustmentLineUpdateWithWhereUniqueWithoutAdjustmentInput[]
    updateMany?: AdjustmentLineUpdateManyWithWhereWithoutAdjustmentInput | AdjustmentLineUpdateManyWithWhereWithoutAdjustmentInput[]
    deleteMany?: AdjustmentLineScalarWhereInput | AdjustmentLineScalarWhereInput[]
  }

  export type AdjustmentCreateNestedOneWithoutLinesInput = {
    create?: XOR<AdjustmentCreateWithoutLinesInput, AdjustmentUncheckedCreateWithoutLinesInput>
    connectOrCreate?: AdjustmentCreateOrConnectWithoutLinesInput
    connect?: AdjustmentWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutAdjustmentLinesInput = {
    create?: XOR<ProductCreateWithoutAdjustmentLinesInput, ProductUncheckedCreateWithoutAdjustmentLinesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAdjustmentLinesInput
    connect?: ProductWhereUniqueInput
  }

  export type AdjustmentUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<AdjustmentCreateWithoutLinesInput, AdjustmentUncheckedCreateWithoutLinesInput>
    connectOrCreate?: AdjustmentCreateOrConnectWithoutLinesInput
    upsert?: AdjustmentUpsertWithoutLinesInput
    connect?: AdjustmentWhereUniqueInput
    update?: XOR<XOR<AdjustmentUpdateToOneWithWhereWithoutLinesInput, AdjustmentUpdateWithoutLinesInput>, AdjustmentUncheckedUpdateWithoutLinesInput>
  }

  export type ProductUpdateOneRequiredWithoutAdjustmentLinesNestedInput = {
    create?: XOR<ProductCreateWithoutAdjustmentLinesInput, ProductUncheckedCreateWithoutAdjustmentLinesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAdjustmentLinesInput
    upsert?: ProductUpsertWithoutAdjustmentLinesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutAdjustmentLinesInput, ProductUpdateWithoutAdjustmentLinesInput>, ProductUncheckedUpdateWithoutAdjustmentLinesInput>
  }

  export type ProductCreateNestedOneWithoutStockMovesInput = {
    create?: XOR<ProductCreateWithoutStockMovesInput, ProductUncheckedCreateWithoutStockMovesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockMovesInput
    connect?: ProductWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutStockMovesFromInput = {
    create?: XOR<WarehouseCreateWithoutStockMovesFromInput, WarehouseUncheckedCreateWithoutStockMovesFromInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutStockMovesFromInput
    connect?: WarehouseWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutStockMovesToInput = {
    create?: XOR<WarehouseCreateWithoutStockMovesToInput, WarehouseUncheckedCreateWithoutStockMovesToInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutStockMovesToInput
    connect?: WarehouseWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutStockMovesFromInput = {
    create?: XOR<LocationCreateWithoutStockMovesFromInput, LocationUncheckedCreateWithoutStockMovesFromInput>
    connectOrCreate?: LocationCreateOrConnectWithoutStockMovesFromInput
    connect?: LocationWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutStockMovesToInput = {
    create?: XOR<LocationCreateWithoutStockMovesToInput, LocationUncheckedCreateWithoutStockMovesToInput>
    connectOrCreate?: LocationCreateOrConnectWithoutStockMovesToInput
    connect?: LocationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStockMovesCreatedInput = {
    create?: XOR<UserCreateWithoutStockMovesCreatedInput, UserUncheckedCreateWithoutStockMovesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutStockMovesCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutStockMovesNestedInput = {
    create?: XOR<ProductCreateWithoutStockMovesInput, ProductUncheckedCreateWithoutStockMovesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockMovesInput
    upsert?: ProductUpsertWithoutStockMovesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutStockMovesInput, ProductUpdateWithoutStockMovesInput>, ProductUncheckedUpdateWithoutStockMovesInput>
  }

  export type WarehouseUpdateOneWithoutStockMovesFromNestedInput = {
    create?: XOR<WarehouseCreateWithoutStockMovesFromInput, WarehouseUncheckedCreateWithoutStockMovesFromInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutStockMovesFromInput
    upsert?: WarehouseUpsertWithoutStockMovesFromInput
    disconnect?: WarehouseWhereInput | boolean
    delete?: WarehouseWhereInput | boolean
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutStockMovesFromInput, WarehouseUpdateWithoutStockMovesFromInput>, WarehouseUncheckedUpdateWithoutStockMovesFromInput>
  }

  export type WarehouseUpdateOneWithoutStockMovesToNestedInput = {
    create?: XOR<WarehouseCreateWithoutStockMovesToInput, WarehouseUncheckedCreateWithoutStockMovesToInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutStockMovesToInput
    upsert?: WarehouseUpsertWithoutStockMovesToInput
    disconnect?: WarehouseWhereInput | boolean
    delete?: WarehouseWhereInput | boolean
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutStockMovesToInput, WarehouseUpdateWithoutStockMovesToInput>, WarehouseUncheckedUpdateWithoutStockMovesToInput>
  }

  export type LocationUpdateOneWithoutStockMovesFromNestedInput = {
    create?: XOR<LocationCreateWithoutStockMovesFromInput, LocationUncheckedCreateWithoutStockMovesFromInput>
    connectOrCreate?: LocationCreateOrConnectWithoutStockMovesFromInput
    upsert?: LocationUpsertWithoutStockMovesFromInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutStockMovesFromInput, LocationUpdateWithoutStockMovesFromInput>, LocationUncheckedUpdateWithoutStockMovesFromInput>
  }

  export type LocationUpdateOneWithoutStockMovesToNestedInput = {
    create?: XOR<LocationCreateWithoutStockMovesToInput, LocationUncheckedCreateWithoutStockMovesToInput>
    connectOrCreate?: LocationCreateOrConnectWithoutStockMovesToInput
    upsert?: LocationUpsertWithoutStockMovesToInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutStockMovesToInput, LocationUpdateWithoutStockMovesToInput>, LocationUncheckedUpdateWithoutStockMovesToInput>
  }

  export type UserUpdateOneWithoutStockMovesCreatedNestedInput = {
    create?: XOR<UserCreateWithoutStockMovesCreatedInput, UserUncheckedCreateWithoutStockMovesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutStockMovesCreatedInput
    upsert?: UserUpsertWithoutStockMovesCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStockMovesCreatedInput, UserUpdateWithoutStockMovesCreatedInput>, UserUncheckedUpdateWithoutStockMovesCreatedInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumDocumentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusFilter<$PrismaModel> | $Enums.DocumentStatus
  }

  export type NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentStatusFilter<$PrismaModel>
  }

  export type ReceiptCreateWithoutCreatedByInput = {
    receiptNo: string
    reference?: string | null
    partner?: string | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutReceiptsInput
    lines?: ReceiptLineCreateNestedManyWithoutReceiptInput
  }

  export type ReceiptUncheckedCreateWithoutCreatedByInput = {
    id?: number
    receiptNo: string
    reference?: string | null
    warehouseId: number
    partner?: string | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: ReceiptLineUncheckedCreateNestedManyWithoutReceiptInput
  }

  export type ReceiptCreateOrConnectWithoutCreatedByInput = {
    where: ReceiptWhereUniqueInput
    create: XOR<ReceiptCreateWithoutCreatedByInput, ReceiptUncheckedCreateWithoutCreatedByInput>
  }

  export type ReceiptCreateManyCreatedByInputEnvelope = {
    data: ReceiptCreateManyCreatedByInput | ReceiptCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryCreateWithoutCreatedByInput = {
    deliveryNo: string
    reference?: string | null
    partner?: string | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutDeliveriesInput
    lines?: DeliveryLineCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateWithoutCreatedByInput = {
    id?: number
    deliveryNo: string
    reference?: string | null
    warehouseId: number
    partner?: string | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: DeliveryLineUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryCreateOrConnectWithoutCreatedByInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutCreatedByInput, DeliveryUncheckedCreateWithoutCreatedByInput>
  }

  export type DeliveryCreateManyCreatedByInputEnvelope = {
    data: DeliveryCreateManyCreatedByInput | DeliveryCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutCreatedByInput = {
    transferNo: string
    reference?: string | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    fromWarehouse: WarehouseCreateNestedOneWithoutTransfersFromInput
    toWarehouse: WarehouseCreateNestedOneWithoutTransfersToInput
    lines?: TransferLineCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutCreatedByInput = {
    id?: number
    transferNo: string
    reference?: string | null
    fromWarehouseId: number
    toWarehouseId: number
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: TransferLineUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutCreatedByInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutCreatedByInput, TransferUncheckedCreateWithoutCreatedByInput>
  }

  export type TransferCreateManyCreatedByInputEnvelope = {
    data: TransferCreateManyCreatedByInput | TransferCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AdjustmentCreateWithoutCreatedByInput = {
    adjustmentNo: string
    reason?: string | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutAdjustmentsInput
    lines?: AdjustmentLineCreateNestedManyWithoutAdjustmentInput
  }

  export type AdjustmentUncheckedCreateWithoutCreatedByInput = {
    id?: number
    adjustmentNo: string
    warehouseId: number
    reason?: string | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: AdjustmentLineUncheckedCreateNestedManyWithoutAdjustmentInput
  }

  export type AdjustmentCreateOrConnectWithoutCreatedByInput = {
    where: AdjustmentWhereUniqueInput
    create: XOR<AdjustmentCreateWithoutCreatedByInput, AdjustmentUncheckedCreateWithoutCreatedByInput>
  }

  export type AdjustmentCreateManyCreatedByInputEnvelope = {
    data: AdjustmentCreateManyCreatedByInput | AdjustmentCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type StockMoveCreateWithoutCreatedByInput = {
    moveNo?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    reason?: string | null
    reference?: string | null
    documentType?: string | null
    documentId?: number | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutStockMovesInput
    fromWarehouse?: WarehouseCreateNestedOneWithoutStockMovesFromInput
    toWarehouse?: WarehouseCreateNestedOneWithoutStockMovesToInput
    fromLocation?: LocationCreateNestedOneWithoutStockMovesFromInput
    toLocation?: LocationCreateNestedOneWithoutStockMovesToInput
  }

  export type StockMoveUncheckedCreateWithoutCreatedByInput = {
    id?: number
    moveNo?: string | null
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    fromWarehouseId?: number | null
    toWarehouseId?: number | null
    fromLocationId?: number | null
    toLocationId?: number | null
    reason?: string | null
    reference?: string | null
    documentType?: string | null
    documentId?: number | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
  }

  export type StockMoveCreateOrConnectWithoutCreatedByInput = {
    where: StockMoveWhereUniqueInput
    create: XOR<StockMoveCreateWithoutCreatedByInput, StockMoveUncheckedCreateWithoutCreatedByInput>
  }

  export type StockMoveCreateManyCreatedByInputEnvelope = {
    data: StockMoveCreateManyCreatedByInput | StockMoveCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ReceiptUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ReceiptWhereUniqueInput
    update: XOR<ReceiptUpdateWithoutCreatedByInput, ReceiptUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ReceiptCreateWithoutCreatedByInput, ReceiptUncheckedCreateWithoutCreatedByInput>
  }

  export type ReceiptUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ReceiptWhereUniqueInput
    data: XOR<ReceiptUpdateWithoutCreatedByInput, ReceiptUncheckedUpdateWithoutCreatedByInput>
  }

  export type ReceiptUpdateManyWithWhereWithoutCreatedByInput = {
    where: ReceiptScalarWhereInput
    data: XOR<ReceiptUpdateManyMutationInput, ReceiptUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ReceiptScalarWhereInput = {
    AND?: ReceiptScalarWhereInput | ReceiptScalarWhereInput[]
    OR?: ReceiptScalarWhereInput[]
    NOT?: ReceiptScalarWhereInput | ReceiptScalarWhereInput[]
    id?: IntFilter<"Receipt"> | number
    receiptNo?: StringFilter<"Receipt"> | string
    reference?: StringNullableFilter<"Receipt"> | string | null
    warehouseId?: IntFilter<"Receipt"> | number
    partner?: StringNullableFilter<"Receipt"> | string | null
    status?: EnumDocumentStatusFilter<"Receipt"> | $Enums.DocumentStatus
    createdById?: IntNullableFilter<"Receipt"> | number | null
    createdAt?: DateTimeFilter<"Receipt"> | Date | string
    updatedAt?: DateTimeFilter<"Receipt"> | Date | string
  }

  export type DeliveryUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: DeliveryWhereUniqueInput
    update: XOR<DeliveryUpdateWithoutCreatedByInput, DeliveryUncheckedUpdateWithoutCreatedByInput>
    create: XOR<DeliveryCreateWithoutCreatedByInput, DeliveryUncheckedCreateWithoutCreatedByInput>
  }

  export type DeliveryUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: DeliveryWhereUniqueInput
    data: XOR<DeliveryUpdateWithoutCreatedByInput, DeliveryUncheckedUpdateWithoutCreatedByInput>
  }

  export type DeliveryUpdateManyWithWhereWithoutCreatedByInput = {
    where: DeliveryScalarWhereInput
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type DeliveryScalarWhereInput = {
    AND?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
    OR?: DeliveryScalarWhereInput[]
    NOT?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
    id?: IntFilter<"Delivery"> | number
    deliveryNo?: StringFilter<"Delivery"> | string
    reference?: StringNullableFilter<"Delivery"> | string | null
    warehouseId?: IntFilter<"Delivery"> | number
    partner?: StringNullableFilter<"Delivery"> | string | null
    status?: EnumDocumentStatusFilter<"Delivery"> | $Enums.DocumentStatus
    createdById?: IntNullableFilter<"Delivery"> | number | null
    createdAt?: DateTimeFilter<"Delivery"> | Date | string
    updatedAt?: DateTimeFilter<"Delivery"> | Date | string
  }

  export type TransferUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutCreatedByInput, TransferUncheckedUpdateWithoutCreatedByInput>
    create: XOR<TransferCreateWithoutCreatedByInput, TransferUncheckedCreateWithoutCreatedByInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutCreatedByInput, TransferUncheckedUpdateWithoutCreatedByInput>
  }

  export type TransferUpdateManyWithWhereWithoutCreatedByInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type TransferScalarWhereInput = {
    AND?: TransferScalarWhereInput | TransferScalarWhereInput[]
    OR?: TransferScalarWhereInput[]
    NOT?: TransferScalarWhereInput | TransferScalarWhereInput[]
    id?: IntFilter<"Transfer"> | number
    transferNo?: StringFilter<"Transfer"> | string
    reference?: StringNullableFilter<"Transfer"> | string | null
    fromWarehouseId?: IntFilter<"Transfer"> | number
    toWarehouseId?: IntFilter<"Transfer"> | number
    status?: EnumDocumentStatusFilter<"Transfer"> | $Enums.DocumentStatus
    createdById?: IntNullableFilter<"Transfer"> | number | null
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeFilter<"Transfer"> | Date | string
  }

  export type AdjustmentUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: AdjustmentWhereUniqueInput
    update: XOR<AdjustmentUpdateWithoutCreatedByInput, AdjustmentUncheckedUpdateWithoutCreatedByInput>
    create: XOR<AdjustmentCreateWithoutCreatedByInput, AdjustmentUncheckedCreateWithoutCreatedByInput>
  }

  export type AdjustmentUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: AdjustmentWhereUniqueInput
    data: XOR<AdjustmentUpdateWithoutCreatedByInput, AdjustmentUncheckedUpdateWithoutCreatedByInput>
  }

  export type AdjustmentUpdateManyWithWhereWithoutCreatedByInput = {
    where: AdjustmentScalarWhereInput
    data: XOR<AdjustmentUpdateManyMutationInput, AdjustmentUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AdjustmentScalarWhereInput = {
    AND?: AdjustmentScalarWhereInput | AdjustmentScalarWhereInput[]
    OR?: AdjustmentScalarWhereInput[]
    NOT?: AdjustmentScalarWhereInput | AdjustmentScalarWhereInput[]
    id?: IntFilter<"Adjustment"> | number
    adjustmentNo?: StringFilter<"Adjustment"> | string
    warehouseId?: IntFilter<"Adjustment"> | number
    reason?: StringNullableFilter<"Adjustment"> | string | null
    status?: EnumDocumentStatusFilter<"Adjustment"> | $Enums.DocumentStatus
    createdById?: IntNullableFilter<"Adjustment"> | number | null
    createdAt?: DateTimeFilter<"Adjustment"> | Date | string
    updatedAt?: DateTimeFilter<"Adjustment"> | Date | string
  }

  export type StockMoveUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: StockMoveWhereUniqueInput
    update: XOR<StockMoveUpdateWithoutCreatedByInput, StockMoveUncheckedUpdateWithoutCreatedByInput>
    create: XOR<StockMoveCreateWithoutCreatedByInput, StockMoveUncheckedCreateWithoutCreatedByInput>
  }

  export type StockMoveUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: StockMoveWhereUniqueInput
    data: XOR<StockMoveUpdateWithoutCreatedByInput, StockMoveUncheckedUpdateWithoutCreatedByInput>
  }

  export type StockMoveUpdateManyWithWhereWithoutCreatedByInput = {
    where: StockMoveScalarWhereInput
    data: XOR<StockMoveUpdateManyMutationInput, StockMoveUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type StockMoveScalarWhereInput = {
    AND?: StockMoveScalarWhereInput | StockMoveScalarWhereInput[]
    OR?: StockMoveScalarWhereInput[]
    NOT?: StockMoveScalarWhereInput | StockMoveScalarWhereInput[]
    id?: IntFilter<"StockMove"> | number
    moveNo?: StringNullableFilter<"StockMove"> | string | null
    productId?: IntFilter<"StockMove"> | number
    quantity?: DecimalFilter<"StockMove"> | Decimal | DecimalJsLike | number | string
    uom?: StringFilter<"StockMove"> | string
    fromWarehouseId?: IntNullableFilter<"StockMove"> | number | null
    toWarehouseId?: IntNullableFilter<"StockMove"> | number | null
    fromLocationId?: IntNullableFilter<"StockMove"> | number | null
    toLocationId?: IntNullableFilter<"StockMove"> | number | null
    reason?: StringNullableFilter<"StockMove"> | string | null
    reference?: StringNullableFilter<"StockMove"> | string | null
    documentType?: StringNullableFilter<"StockMove"> | string | null
    documentId?: IntNullableFilter<"StockMove"> | number | null
    status?: EnumDocumentStatusFilter<"StockMove"> | $Enums.DocumentStatus
    createdById?: IntNullableFilter<"StockMove"> | number | null
    createdAt?: DateTimeFilter<"StockMove"> | Date | string
  }

  export type StockQuantCreateWithoutProductInput = {
    quantity?: Decimal | DecimalJsLike | number | string
    reserved?: Decimal | DecimalJsLike | number | string
    incoming?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutStockQuantsInput
    location?: LocationCreateNestedOneWithoutStockQuantsInput
  }

  export type StockQuantUncheckedCreateWithoutProductInput = {
    id?: number
    warehouseId: number
    locationId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string
    reserved?: Decimal | DecimalJsLike | number | string
    incoming?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockQuantCreateOrConnectWithoutProductInput = {
    where: StockQuantWhereUniqueInput
    create: XOR<StockQuantCreateWithoutProductInput, StockQuantUncheckedCreateWithoutProductInput>
  }

  export type StockQuantCreateManyProductInputEnvelope = {
    data: StockQuantCreateManyProductInput | StockQuantCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type StockMoveCreateWithoutProductInput = {
    moveNo?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    reason?: string | null
    reference?: string | null
    documentType?: string | null
    documentId?: number | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    fromWarehouse?: WarehouseCreateNestedOneWithoutStockMovesFromInput
    toWarehouse?: WarehouseCreateNestedOneWithoutStockMovesToInput
    fromLocation?: LocationCreateNestedOneWithoutStockMovesFromInput
    toLocation?: LocationCreateNestedOneWithoutStockMovesToInput
    createdBy?: UserCreateNestedOneWithoutStockMovesCreatedInput
  }

  export type StockMoveUncheckedCreateWithoutProductInput = {
    id?: number
    moveNo?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    fromWarehouseId?: number | null
    toWarehouseId?: number | null
    fromLocationId?: number | null
    toLocationId?: number | null
    reason?: string | null
    reference?: string | null
    documentType?: string | null
    documentId?: number | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
  }

  export type StockMoveCreateOrConnectWithoutProductInput = {
    where: StockMoveWhereUniqueInput
    create: XOR<StockMoveCreateWithoutProductInput, StockMoveUncheckedCreateWithoutProductInput>
  }

  export type StockMoveCreateManyProductInputEnvelope = {
    data: StockMoveCreateManyProductInput | StockMoveCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ReceiptLineCreateWithoutProductInput = {
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    receipt: ReceiptCreateNestedOneWithoutLinesInput
  }

  export type ReceiptLineUncheckedCreateWithoutProductInput = {
    id?: number
    receiptId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
  }

  export type ReceiptLineCreateOrConnectWithoutProductInput = {
    where: ReceiptLineWhereUniqueInput
    create: XOR<ReceiptLineCreateWithoutProductInput, ReceiptLineUncheckedCreateWithoutProductInput>
  }

  export type ReceiptLineCreateManyProductInputEnvelope = {
    data: ReceiptLineCreateManyProductInput | ReceiptLineCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryLineCreateWithoutProductInput = {
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    delivery: DeliveryCreateNestedOneWithoutLinesInput
  }

  export type DeliveryLineUncheckedCreateWithoutProductInput = {
    id?: number
    deliveryId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
  }

  export type DeliveryLineCreateOrConnectWithoutProductInput = {
    where: DeliveryLineWhereUniqueInput
    create: XOR<DeliveryLineCreateWithoutProductInput, DeliveryLineUncheckedCreateWithoutProductInput>
  }

  export type DeliveryLineCreateManyProductInputEnvelope = {
    data: DeliveryLineCreateManyProductInput | DeliveryLineCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type TransferLineCreateWithoutProductInput = {
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    transfer: TransferCreateNestedOneWithoutLinesInput
  }

  export type TransferLineUncheckedCreateWithoutProductInput = {
    id?: number
    transferId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
  }

  export type TransferLineCreateOrConnectWithoutProductInput = {
    where: TransferLineWhereUniqueInput
    create: XOR<TransferLineCreateWithoutProductInput, TransferLineUncheckedCreateWithoutProductInput>
  }

  export type TransferLineCreateManyProductInputEnvelope = {
    data: TransferLineCreateManyProductInput | TransferLineCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type AdjustmentLineCreateWithoutProductInput = {
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    note?: string | null
    adjustment: AdjustmentCreateNestedOneWithoutLinesInput
  }

  export type AdjustmentLineUncheckedCreateWithoutProductInput = {
    id?: number
    adjustmentId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    note?: string | null
  }

  export type AdjustmentLineCreateOrConnectWithoutProductInput = {
    where: AdjustmentLineWhereUniqueInput
    create: XOR<AdjustmentLineCreateWithoutProductInput, AdjustmentLineUncheckedCreateWithoutProductInput>
  }

  export type AdjustmentLineCreateManyProductInputEnvelope = {
    data: AdjustmentLineCreateManyProductInput | AdjustmentLineCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutProductsInput = {
    name: string
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type ReorderRuleCreateWithoutProductInput = {
    minQty: Decimal | DecimalJsLike | number | string
    maxQty?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutReorderRulesInput
  }

  export type ReorderRuleUncheckedCreateWithoutProductInput = {
    id?: number
    warehouseId: number
    minQty: Decimal | DecimalJsLike | number | string
    maxQty?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type ReorderRuleCreateOrConnectWithoutProductInput = {
    where: ReorderRuleWhereUniqueInput
    create: XOR<ReorderRuleCreateWithoutProductInput, ReorderRuleUncheckedCreateWithoutProductInput>
  }

  export type ReorderRuleCreateManyProductInputEnvelope = {
    data: ReorderRuleCreateManyProductInput | ReorderRuleCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type StockQuantUpsertWithWhereUniqueWithoutProductInput = {
    where: StockQuantWhereUniqueInput
    update: XOR<StockQuantUpdateWithoutProductInput, StockQuantUncheckedUpdateWithoutProductInput>
    create: XOR<StockQuantCreateWithoutProductInput, StockQuantUncheckedCreateWithoutProductInput>
  }

  export type StockQuantUpdateWithWhereUniqueWithoutProductInput = {
    where: StockQuantWhereUniqueInput
    data: XOR<StockQuantUpdateWithoutProductInput, StockQuantUncheckedUpdateWithoutProductInput>
  }

  export type StockQuantUpdateManyWithWhereWithoutProductInput = {
    where: StockQuantScalarWhereInput
    data: XOR<StockQuantUpdateManyMutationInput, StockQuantUncheckedUpdateManyWithoutProductInput>
  }

  export type StockQuantScalarWhereInput = {
    AND?: StockQuantScalarWhereInput | StockQuantScalarWhereInput[]
    OR?: StockQuantScalarWhereInput[]
    NOT?: StockQuantScalarWhereInput | StockQuantScalarWhereInput[]
    id?: IntFilter<"StockQuant"> | number
    productId?: IntFilter<"StockQuant"> | number
    warehouseId?: IntFilter<"StockQuant"> | number
    locationId?: IntNullableFilter<"StockQuant"> | number | null
    quantity?: DecimalFilter<"StockQuant"> | Decimal | DecimalJsLike | number | string
    reserved?: DecimalFilter<"StockQuant"> | Decimal | DecimalJsLike | number | string
    incoming?: DecimalFilter<"StockQuant"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"StockQuant"> | Date | string
    updatedAt?: DateTimeFilter<"StockQuant"> | Date | string
  }

  export type StockMoveUpsertWithWhereUniqueWithoutProductInput = {
    where: StockMoveWhereUniqueInput
    update: XOR<StockMoveUpdateWithoutProductInput, StockMoveUncheckedUpdateWithoutProductInput>
    create: XOR<StockMoveCreateWithoutProductInput, StockMoveUncheckedCreateWithoutProductInput>
  }

  export type StockMoveUpdateWithWhereUniqueWithoutProductInput = {
    where: StockMoveWhereUniqueInput
    data: XOR<StockMoveUpdateWithoutProductInput, StockMoveUncheckedUpdateWithoutProductInput>
  }

  export type StockMoveUpdateManyWithWhereWithoutProductInput = {
    where: StockMoveScalarWhereInput
    data: XOR<StockMoveUpdateManyMutationInput, StockMoveUncheckedUpdateManyWithoutProductInput>
  }

  export type ReceiptLineUpsertWithWhereUniqueWithoutProductInput = {
    where: ReceiptLineWhereUniqueInput
    update: XOR<ReceiptLineUpdateWithoutProductInput, ReceiptLineUncheckedUpdateWithoutProductInput>
    create: XOR<ReceiptLineCreateWithoutProductInput, ReceiptLineUncheckedCreateWithoutProductInput>
  }

  export type ReceiptLineUpdateWithWhereUniqueWithoutProductInput = {
    where: ReceiptLineWhereUniqueInput
    data: XOR<ReceiptLineUpdateWithoutProductInput, ReceiptLineUncheckedUpdateWithoutProductInput>
  }

  export type ReceiptLineUpdateManyWithWhereWithoutProductInput = {
    where: ReceiptLineScalarWhereInput
    data: XOR<ReceiptLineUpdateManyMutationInput, ReceiptLineUncheckedUpdateManyWithoutProductInput>
  }

  export type ReceiptLineScalarWhereInput = {
    AND?: ReceiptLineScalarWhereInput | ReceiptLineScalarWhereInput[]
    OR?: ReceiptLineScalarWhereInput[]
    NOT?: ReceiptLineScalarWhereInput | ReceiptLineScalarWhereInput[]
    id?: IntFilter<"ReceiptLine"> | number
    receiptId?: IntFilter<"ReceiptLine"> | number
    productId?: IntFilter<"ReceiptLine"> | number
    quantity?: DecimalFilter<"ReceiptLine"> | Decimal | DecimalJsLike | number | string
    uom?: StringFilter<"ReceiptLine"> | string
    unitPrice?: DecimalNullableFilter<"ReceiptLine"> | Decimal | DecimalJsLike | number | string | null
  }

  export type DeliveryLineUpsertWithWhereUniqueWithoutProductInput = {
    where: DeliveryLineWhereUniqueInput
    update: XOR<DeliveryLineUpdateWithoutProductInput, DeliveryLineUncheckedUpdateWithoutProductInput>
    create: XOR<DeliveryLineCreateWithoutProductInput, DeliveryLineUncheckedCreateWithoutProductInput>
  }

  export type DeliveryLineUpdateWithWhereUniqueWithoutProductInput = {
    where: DeliveryLineWhereUniqueInput
    data: XOR<DeliveryLineUpdateWithoutProductInput, DeliveryLineUncheckedUpdateWithoutProductInput>
  }

  export type DeliveryLineUpdateManyWithWhereWithoutProductInput = {
    where: DeliveryLineScalarWhereInput
    data: XOR<DeliveryLineUpdateManyMutationInput, DeliveryLineUncheckedUpdateManyWithoutProductInput>
  }

  export type DeliveryLineScalarWhereInput = {
    AND?: DeliveryLineScalarWhereInput | DeliveryLineScalarWhereInput[]
    OR?: DeliveryLineScalarWhereInput[]
    NOT?: DeliveryLineScalarWhereInput | DeliveryLineScalarWhereInput[]
    id?: IntFilter<"DeliveryLine"> | number
    deliveryId?: IntFilter<"DeliveryLine"> | number
    productId?: IntFilter<"DeliveryLine"> | number
    quantity?: DecimalFilter<"DeliveryLine"> | Decimal | DecimalJsLike | number | string
    uom?: StringFilter<"DeliveryLine"> | string
    unitPrice?: DecimalNullableFilter<"DeliveryLine"> | Decimal | DecimalJsLike | number | string | null
  }

  export type TransferLineUpsertWithWhereUniqueWithoutProductInput = {
    where: TransferLineWhereUniqueInput
    update: XOR<TransferLineUpdateWithoutProductInput, TransferLineUncheckedUpdateWithoutProductInput>
    create: XOR<TransferLineCreateWithoutProductInput, TransferLineUncheckedCreateWithoutProductInput>
  }

  export type TransferLineUpdateWithWhereUniqueWithoutProductInput = {
    where: TransferLineWhereUniqueInput
    data: XOR<TransferLineUpdateWithoutProductInput, TransferLineUncheckedUpdateWithoutProductInput>
  }

  export type TransferLineUpdateManyWithWhereWithoutProductInput = {
    where: TransferLineScalarWhereInput
    data: XOR<TransferLineUpdateManyMutationInput, TransferLineUncheckedUpdateManyWithoutProductInput>
  }

  export type TransferLineScalarWhereInput = {
    AND?: TransferLineScalarWhereInput | TransferLineScalarWhereInput[]
    OR?: TransferLineScalarWhereInput[]
    NOT?: TransferLineScalarWhereInput | TransferLineScalarWhereInput[]
    id?: IntFilter<"TransferLine"> | number
    transferId?: IntFilter<"TransferLine"> | number
    productId?: IntFilter<"TransferLine"> | number
    quantity?: DecimalFilter<"TransferLine"> | Decimal | DecimalJsLike | number | string
    uom?: StringFilter<"TransferLine"> | string
  }

  export type AdjustmentLineUpsertWithWhereUniqueWithoutProductInput = {
    where: AdjustmentLineWhereUniqueInput
    update: XOR<AdjustmentLineUpdateWithoutProductInput, AdjustmentLineUncheckedUpdateWithoutProductInput>
    create: XOR<AdjustmentLineCreateWithoutProductInput, AdjustmentLineUncheckedCreateWithoutProductInput>
  }

  export type AdjustmentLineUpdateWithWhereUniqueWithoutProductInput = {
    where: AdjustmentLineWhereUniqueInput
    data: XOR<AdjustmentLineUpdateWithoutProductInput, AdjustmentLineUncheckedUpdateWithoutProductInput>
  }

  export type AdjustmentLineUpdateManyWithWhereWithoutProductInput = {
    where: AdjustmentLineScalarWhereInput
    data: XOR<AdjustmentLineUpdateManyMutationInput, AdjustmentLineUncheckedUpdateManyWithoutProductInput>
  }

  export type AdjustmentLineScalarWhereInput = {
    AND?: AdjustmentLineScalarWhereInput | AdjustmentLineScalarWhereInput[]
    OR?: AdjustmentLineScalarWhereInput[]
    NOT?: AdjustmentLineScalarWhereInput | AdjustmentLineScalarWhereInput[]
    id?: IntFilter<"AdjustmentLine"> | number
    adjustmentId?: IntFilter<"AdjustmentLine"> | number
    productId?: IntFilter<"AdjustmentLine"> | number
    quantity?: DecimalFilter<"AdjustmentLine"> | Decimal | DecimalJsLike | number | string
    uom?: StringFilter<"AdjustmentLine"> | string
    note?: StringNullableFilter<"AdjustmentLine"> | string | null
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReorderRuleUpsertWithWhereUniqueWithoutProductInput = {
    where: ReorderRuleWhereUniqueInput
    update: XOR<ReorderRuleUpdateWithoutProductInput, ReorderRuleUncheckedUpdateWithoutProductInput>
    create: XOR<ReorderRuleCreateWithoutProductInput, ReorderRuleUncheckedCreateWithoutProductInput>
  }

  export type ReorderRuleUpdateWithWhereUniqueWithoutProductInput = {
    where: ReorderRuleWhereUniqueInput
    data: XOR<ReorderRuleUpdateWithoutProductInput, ReorderRuleUncheckedUpdateWithoutProductInput>
  }

  export type ReorderRuleUpdateManyWithWhereWithoutProductInput = {
    where: ReorderRuleScalarWhereInput
    data: XOR<ReorderRuleUpdateManyMutationInput, ReorderRuleUncheckedUpdateManyWithoutProductInput>
  }

  export type ReorderRuleScalarWhereInput = {
    AND?: ReorderRuleScalarWhereInput | ReorderRuleScalarWhereInput[]
    OR?: ReorderRuleScalarWhereInput[]
    NOT?: ReorderRuleScalarWhereInput | ReorderRuleScalarWhereInput[]
    id?: IntFilter<"ReorderRule"> | number
    productId?: IntFilter<"ReorderRule"> | number
    warehouseId?: IntFilter<"ReorderRule"> | number
    minQty?: DecimalFilter<"ReorderRule"> | Decimal | DecimalJsLike | number | string
    maxQty?: DecimalNullableFilter<"ReorderRule"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ReorderRule"> | Date | string
  }

  export type ProductCreateWithoutCategoryInput = {
    sku: string
    name: string
    description?: string | null
    uom: string
    defaultPrice: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockQuants?: StockQuantCreateNestedManyWithoutProductInput
    stockMoves?: StockMoveCreateNestedManyWithoutProductInput
    receiptLines?: ReceiptLineCreateNestedManyWithoutProductInput
    deliveryLines?: DeliveryLineCreateNestedManyWithoutProductInput
    transferLines?: TransferLineCreateNestedManyWithoutProductInput
    adjustmentLines?: AdjustmentLineCreateNestedManyWithoutProductInput
    reorderRules?: ReorderRuleCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: number
    sku: string
    name: string
    description?: string | null
    uom: string
    defaultPrice: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockQuants?: StockQuantUncheckedCreateNestedManyWithoutProductInput
    stockMoves?: StockMoveUncheckedCreateNestedManyWithoutProductInput
    receiptLines?: ReceiptLineUncheckedCreateNestedManyWithoutProductInput
    deliveryLines?: DeliveryLineUncheckedCreateNestedManyWithoutProductInput
    transferLines?: TransferLineUncheckedCreateNestedManyWithoutProductInput
    adjustmentLines?: AdjustmentLineUncheckedCreateNestedManyWithoutProductInput
    reorderRules?: ReorderRuleUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    sku?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    uom?: StringFilter<"Product"> | string
    defaultPrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    active?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    categoryId?: IntNullableFilter<"Product"> | number | null
  }

  export type ProductCreateWithoutReorderRulesInput = {
    sku: string
    name: string
    description?: string | null
    uom: string
    defaultPrice: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockQuants?: StockQuantCreateNestedManyWithoutProductInput
    stockMoves?: StockMoveCreateNestedManyWithoutProductInput
    receiptLines?: ReceiptLineCreateNestedManyWithoutProductInput
    deliveryLines?: DeliveryLineCreateNestedManyWithoutProductInput
    transferLines?: TransferLineCreateNestedManyWithoutProductInput
    adjustmentLines?: AdjustmentLineCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutReorderRulesInput = {
    id?: number
    sku: string
    name: string
    description?: string | null
    uom: string
    defaultPrice: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: number | null
    stockQuants?: StockQuantUncheckedCreateNestedManyWithoutProductInput
    stockMoves?: StockMoveUncheckedCreateNestedManyWithoutProductInput
    receiptLines?: ReceiptLineUncheckedCreateNestedManyWithoutProductInput
    deliveryLines?: DeliveryLineUncheckedCreateNestedManyWithoutProductInput
    transferLines?: TransferLineUncheckedCreateNestedManyWithoutProductInput
    adjustmentLines?: AdjustmentLineUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutReorderRulesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutReorderRulesInput, ProductUncheckedCreateWithoutReorderRulesInput>
  }

  export type WarehouseCreateWithoutReorderRulesInput = {
    code: string
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutWarehouseInput
    stockQuants?: StockQuantCreateNestedManyWithoutWarehouseInput
    receipts?: ReceiptCreateNestedManyWithoutWarehouseInput
    deliveries?: DeliveryCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferCreateNestedManyWithoutToWarehouseInput
    adjustments?: AdjustmentCreateNestedManyWithoutWarehouseInput
    stockMovesFrom?: StockMoveCreateNestedManyWithoutFromWarehouseInput
    stockMovesTo?: StockMoveCreateNestedManyWithoutToWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutReorderRulesInput = {
    id?: number
    code: string
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutWarehouseInput
    stockQuants?: StockQuantUncheckedCreateNestedManyWithoutWarehouseInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutWarehouseInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToWarehouseInput
    adjustments?: AdjustmentUncheckedCreateNestedManyWithoutWarehouseInput
    stockMovesFrom?: StockMoveUncheckedCreateNestedManyWithoutFromWarehouseInput
    stockMovesTo?: StockMoveUncheckedCreateNestedManyWithoutToWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutReorderRulesInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutReorderRulesInput, WarehouseUncheckedCreateWithoutReorderRulesInput>
  }

  export type ProductUpsertWithoutReorderRulesInput = {
    update: XOR<ProductUpdateWithoutReorderRulesInput, ProductUncheckedUpdateWithoutReorderRulesInput>
    create: XOR<ProductCreateWithoutReorderRulesInput, ProductUncheckedCreateWithoutReorderRulesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutReorderRulesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutReorderRulesInput, ProductUncheckedUpdateWithoutReorderRulesInput>
  }

  export type ProductUpdateWithoutReorderRulesInput = {
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuants?: StockQuantUpdateManyWithoutProductNestedInput
    stockMoves?: StockMoveUpdateManyWithoutProductNestedInput
    receiptLines?: ReceiptLineUpdateManyWithoutProductNestedInput
    deliveryLines?: DeliveryLineUpdateManyWithoutProductNestedInput
    transferLines?: TransferLineUpdateManyWithoutProductNestedInput
    adjustmentLines?: AdjustmentLineUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutReorderRulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuants?: StockQuantUncheckedUpdateManyWithoutProductNestedInput
    stockMoves?: StockMoveUncheckedUpdateManyWithoutProductNestedInput
    receiptLines?: ReceiptLineUncheckedUpdateManyWithoutProductNestedInput
    deliveryLines?: DeliveryLineUncheckedUpdateManyWithoutProductNestedInput
    transferLines?: TransferLineUncheckedUpdateManyWithoutProductNestedInput
    adjustmentLines?: AdjustmentLineUncheckedUpdateManyWithoutProductNestedInput
  }

  export type WarehouseUpsertWithoutReorderRulesInput = {
    update: XOR<WarehouseUpdateWithoutReorderRulesInput, WarehouseUncheckedUpdateWithoutReorderRulesInput>
    create: XOR<WarehouseCreateWithoutReorderRulesInput, WarehouseUncheckedCreateWithoutReorderRulesInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutReorderRulesInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutReorderRulesInput, WarehouseUncheckedUpdateWithoutReorderRulesInput>
  }

  export type WarehouseUpdateWithoutReorderRulesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutWarehouseNestedInput
    stockQuants?: StockQuantUpdateManyWithoutWarehouseNestedInput
    receipts?: ReceiptUpdateManyWithoutWarehouseNestedInput
    deliveries?: DeliveryUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUpdateManyWithoutToWarehouseNestedInput
    adjustments?: AdjustmentUpdateManyWithoutWarehouseNestedInput
    stockMovesFrom?: StockMoveUpdateManyWithoutFromWarehouseNestedInput
    stockMovesTo?: StockMoveUpdateManyWithoutToWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutReorderRulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutWarehouseNestedInput
    stockQuants?: StockQuantUncheckedUpdateManyWithoutWarehouseNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutWarehouseNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToWarehouseNestedInput
    adjustments?: AdjustmentUncheckedUpdateManyWithoutWarehouseNestedInput
    stockMovesFrom?: StockMoveUncheckedUpdateManyWithoutFromWarehouseNestedInput
    stockMovesTo?: StockMoveUncheckedUpdateManyWithoutToWarehouseNestedInput
  }

  export type LocationCreateWithoutWarehouseInput = {
    code: string
    name: string
    parentId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockQuants?: StockQuantCreateNestedManyWithoutLocationInput
    stockMovesFrom?: StockMoveCreateNestedManyWithoutFromLocationInput
    stockMovesTo?: StockMoveCreateNestedManyWithoutToLocationInput
  }

  export type LocationUncheckedCreateWithoutWarehouseInput = {
    id?: number
    code: string
    name: string
    parentId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockQuants?: StockQuantUncheckedCreateNestedManyWithoutLocationInput
    stockMovesFrom?: StockMoveUncheckedCreateNestedManyWithoutFromLocationInput
    stockMovesTo?: StockMoveUncheckedCreateNestedManyWithoutToLocationInput
  }

  export type LocationCreateOrConnectWithoutWarehouseInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutWarehouseInput, LocationUncheckedCreateWithoutWarehouseInput>
  }

  export type LocationCreateManyWarehouseInputEnvelope = {
    data: LocationCreateManyWarehouseInput | LocationCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type StockQuantCreateWithoutWarehouseInput = {
    quantity?: Decimal | DecimalJsLike | number | string
    reserved?: Decimal | DecimalJsLike | number | string
    incoming?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutStockQuantsInput
    location?: LocationCreateNestedOneWithoutStockQuantsInput
  }

  export type StockQuantUncheckedCreateWithoutWarehouseInput = {
    id?: number
    productId: number
    locationId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string
    reserved?: Decimal | DecimalJsLike | number | string
    incoming?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockQuantCreateOrConnectWithoutWarehouseInput = {
    where: StockQuantWhereUniqueInput
    create: XOR<StockQuantCreateWithoutWarehouseInput, StockQuantUncheckedCreateWithoutWarehouseInput>
  }

  export type StockQuantCreateManyWarehouseInputEnvelope = {
    data: StockQuantCreateManyWarehouseInput | StockQuantCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type ReceiptCreateWithoutWarehouseInput = {
    receiptNo: string
    reference?: string | null
    partner?: string | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutReceiptsCreatedInput
    lines?: ReceiptLineCreateNestedManyWithoutReceiptInput
  }

  export type ReceiptUncheckedCreateWithoutWarehouseInput = {
    id?: number
    receiptNo: string
    reference?: string | null
    partner?: string | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: ReceiptLineUncheckedCreateNestedManyWithoutReceiptInput
  }

  export type ReceiptCreateOrConnectWithoutWarehouseInput = {
    where: ReceiptWhereUniqueInput
    create: XOR<ReceiptCreateWithoutWarehouseInput, ReceiptUncheckedCreateWithoutWarehouseInput>
  }

  export type ReceiptCreateManyWarehouseInputEnvelope = {
    data: ReceiptCreateManyWarehouseInput | ReceiptCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryCreateWithoutWarehouseInput = {
    deliveryNo: string
    reference?: string | null
    partner?: string | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutDeliveriesCreatedInput
    lines?: DeliveryLineCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateWithoutWarehouseInput = {
    id?: number
    deliveryNo: string
    reference?: string | null
    partner?: string | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: DeliveryLineUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryCreateOrConnectWithoutWarehouseInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutWarehouseInput, DeliveryUncheckedCreateWithoutWarehouseInput>
  }

  export type DeliveryCreateManyWarehouseInputEnvelope = {
    data: DeliveryCreateManyWarehouseInput | DeliveryCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutFromWarehouseInput = {
    transferNo: string
    reference?: string | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    toWarehouse: WarehouseCreateNestedOneWithoutTransfersToInput
    createdBy?: UserCreateNestedOneWithoutTransfersCreatedInput
    lines?: TransferLineCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutFromWarehouseInput = {
    id?: number
    transferNo: string
    reference?: string | null
    toWarehouseId: number
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: TransferLineUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutFromWarehouseInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutFromWarehouseInput, TransferUncheckedCreateWithoutFromWarehouseInput>
  }

  export type TransferCreateManyFromWarehouseInputEnvelope = {
    data: TransferCreateManyFromWarehouseInput | TransferCreateManyFromWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutToWarehouseInput = {
    transferNo: string
    reference?: string | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    fromWarehouse: WarehouseCreateNestedOneWithoutTransfersFromInput
    createdBy?: UserCreateNestedOneWithoutTransfersCreatedInput
    lines?: TransferLineCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutToWarehouseInput = {
    id?: number
    transferNo: string
    reference?: string | null
    fromWarehouseId: number
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: TransferLineUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutToWarehouseInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutToWarehouseInput, TransferUncheckedCreateWithoutToWarehouseInput>
  }

  export type TransferCreateManyToWarehouseInputEnvelope = {
    data: TransferCreateManyToWarehouseInput | TransferCreateManyToWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type AdjustmentCreateWithoutWarehouseInput = {
    adjustmentNo: string
    reason?: string | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutAdjustmentsCreatedInput
    lines?: AdjustmentLineCreateNestedManyWithoutAdjustmentInput
  }

  export type AdjustmentUncheckedCreateWithoutWarehouseInput = {
    id?: number
    adjustmentNo: string
    reason?: string | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: AdjustmentLineUncheckedCreateNestedManyWithoutAdjustmentInput
  }

  export type AdjustmentCreateOrConnectWithoutWarehouseInput = {
    where: AdjustmentWhereUniqueInput
    create: XOR<AdjustmentCreateWithoutWarehouseInput, AdjustmentUncheckedCreateWithoutWarehouseInput>
  }

  export type AdjustmentCreateManyWarehouseInputEnvelope = {
    data: AdjustmentCreateManyWarehouseInput | AdjustmentCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type StockMoveCreateWithoutFromWarehouseInput = {
    moveNo?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    reason?: string | null
    reference?: string | null
    documentType?: string | null
    documentId?: number | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutStockMovesInput
    toWarehouse?: WarehouseCreateNestedOneWithoutStockMovesToInput
    fromLocation?: LocationCreateNestedOneWithoutStockMovesFromInput
    toLocation?: LocationCreateNestedOneWithoutStockMovesToInput
    createdBy?: UserCreateNestedOneWithoutStockMovesCreatedInput
  }

  export type StockMoveUncheckedCreateWithoutFromWarehouseInput = {
    id?: number
    moveNo?: string | null
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    toWarehouseId?: number | null
    fromLocationId?: number | null
    toLocationId?: number | null
    reason?: string | null
    reference?: string | null
    documentType?: string | null
    documentId?: number | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
  }

  export type StockMoveCreateOrConnectWithoutFromWarehouseInput = {
    where: StockMoveWhereUniqueInput
    create: XOR<StockMoveCreateWithoutFromWarehouseInput, StockMoveUncheckedCreateWithoutFromWarehouseInput>
  }

  export type StockMoveCreateManyFromWarehouseInputEnvelope = {
    data: StockMoveCreateManyFromWarehouseInput | StockMoveCreateManyFromWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type StockMoveCreateWithoutToWarehouseInput = {
    moveNo?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    reason?: string | null
    reference?: string | null
    documentType?: string | null
    documentId?: number | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutStockMovesInput
    fromWarehouse?: WarehouseCreateNestedOneWithoutStockMovesFromInput
    fromLocation?: LocationCreateNestedOneWithoutStockMovesFromInput
    toLocation?: LocationCreateNestedOneWithoutStockMovesToInput
    createdBy?: UserCreateNestedOneWithoutStockMovesCreatedInput
  }

  export type StockMoveUncheckedCreateWithoutToWarehouseInput = {
    id?: number
    moveNo?: string | null
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    fromWarehouseId?: number | null
    fromLocationId?: number | null
    toLocationId?: number | null
    reason?: string | null
    reference?: string | null
    documentType?: string | null
    documentId?: number | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
  }

  export type StockMoveCreateOrConnectWithoutToWarehouseInput = {
    where: StockMoveWhereUniqueInput
    create: XOR<StockMoveCreateWithoutToWarehouseInput, StockMoveUncheckedCreateWithoutToWarehouseInput>
  }

  export type StockMoveCreateManyToWarehouseInputEnvelope = {
    data: StockMoveCreateManyToWarehouseInput | StockMoveCreateManyToWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type ReorderRuleCreateWithoutWarehouseInput = {
    minQty: Decimal | DecimalJsLike | number | string
    maxQty?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutReorderRulesInput
  }

  export type ReorderRuleUncheckedCreateWithoutWarehouseInput = {
    id?: number
    productId: number
    minQty: Decimal | DecimalJsLike | number | string
    maxQty?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type ReorderRuleCreateOrConnectWithoutWarehouseInput = {
    where: ReorderRuleWhereUniqueInput
    create: XOR<ReorderRuleCreateWithoutWarehouseInput, ReorderRuleUncheckedCreateWithoutWarehouseInput>
  }

  export type ReorderRuleCreateManyWarehouseInputEnvelope = {
    data: ReorderRuleCreateManyWarehouseInput | ReorderRuleCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutWarehouseInput, LocationUncheckedUpdateWithoutWarehouseInput>
    create: XOR<LocationCreateWithoutWarehouseInput, LocationUncheckedCreateWithoutWarehouseInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutWarehouseInput, LocationUncheckedUpdateWithoutWarehouseInput>
  }

  export type LocationUpdateManyWithWhereWithoutWarehouseInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type LocationScalarWhereInput = {
    AND?: LocationScalarWhereInput | LocationScalarWhereInput[]
    OR?: LocationScalarWhereInput[]
    NOT?: LocationScalarWhereInput | LocationScalarWhereInput[]
    id?: IntFilter<"Location"> | number
    code?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    warehouseId?: IntFilter<"Location"> | number
    parentId?: IntNullableFilter<"Location"> | number | null
    isActive?: BoolFilter<"Location"> | boolean
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
  }

  export type StockQuantUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: StockQuantWhereUniqueInput
    update: XOR<StockQuantUpdateWithoutWarehouseInput, StockQuantUncheckedUpdateWithoutWarehouseInput>
    create: XOR<StockQuantCreateWithoutWarehouseInput, StockQuantUncheckedCreateWithoutWarehouseInput>
  }

  export type StockQuantUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: StockQuantWhereUniqueInput
    data: XOR<StockQuantUpdateWithoutWarehouseInput, StockQuantUncheckedUpdateWithoutWarehouseInput>
  }

  export type StockQuantUpdateManyWithWhereWithoutWarehouseInput = {
    where: StockQuantScalarWhereInput
    data: XOR<StockQuantUpdateManyMutationInput, StockQuantUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type ReceiptUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: ReceiptWhereUniqueInput
    update: XOR<ReceiptUpdateWithoutWarehouseInput, ReceiptUncheckedUpdateWithoutWarehouseInput>
    create: XOR<ReceiptCreateWithoutWarehouseInput, ReceiptUncheckedCreateWithoutWarehouseInput>
  }

  export type ReceiptUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: ReceiptWhereUniqueInput
    data: XOR<ReceiptUpdateWithoutWarehouseInput, ReceiptUncheckedUpdateWithoutWarehouseInput>
  }

  export type ReceiptUpdateManyWithWhereWithoutWarehouseInput = {
    where: ReceiptScalarWhereInput
    data: XOR<ReceiptUpdateManyMutationInput, ReceiptUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type DeliveryUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: DeliveryWhereUniqueInput
    update: XOR<DeliveryUpdateWithoutWarehouseInput, DeliveryUncheckedUpdateWithoutWarehouseInput>
    create: XOR<DeliveryCreateWithoutWarehouseInput, DeliveryUncheckedCreateWithoutWarehouseInput>
  }

  export type DeliveryUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: DeliveryWhereUniqueInput
    data: XOR<DeliveryUpdateWithoutWarehouseInput, DeliveryUncheckedUpdateWithoutWarehouseInput>
  }

  export type DeliveryUpdateManyWithWhereWithoutWarehouseInput = {
    where: DeliveryScalarWhereInput
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutFromWarehouseInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutFromWarehouseInput, TransferUncheckedUpdateWithoutFromWarehouseInput>
    create: XOR<TransferCreateWithoutFromWarehouseInput, TransferUncheckedCreateWithoutFromWarehouseInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutFromWarehouseInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutFromWarehouseInput, TransferUncheckedUpdateWithoutFromWarehouseInput>
  }

  export type TransferUpdateManyWithWhereWithoutFromWarehouseInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutFromWarehouseInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutToWarehouseInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutToWarehouseInput, TransferUncheckedUpdateWithoutToWarehouseInput>
    create: XOR<TransferCreateWithoutToWarehouseInput, TransferUncheckedCreateWithoutToWarehouseInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutToWarehouseInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutToWarehouseInput, TransferUncheckedUpdateWithoutToWarehouseInput>
  }

  export type TransferUpdateManyWithWhereWithoutToWarehouseInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutToWarehouseInput>
  }

  export type AdjustmentUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: AdjustmentWhereUniqueInput
    update: XOR<AdjustmentUpdateWithoutWarehouseInput, AdjustmentUncheckedUpdateWithoutWarehouseInput>
    create: XOR<AdjustmentCreateWithoutWarehouseInput, AdjustmentUncheckedCreateWithoutWarehouseInput>
  }

  export type AdjustmentUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: AdjustmentWhereUniqueInput
    data: XOR<AdjustmentUpdateWithoutWarehouseInput, AdjustmentUncheckedUpdateWithoutWarehouseInput>
  }

  export type AdjustmentUpdateManyWithWhereWithoutWarehouseInput = {
    where: AdjustmentScalarWhereInput
    data: XOR<AdjustmentUpdateManyMutationInput, AdjustmentUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type StockMoveUpsertWithWhereUniqueWithoutFromWarehouseInput = {
    where: StockMoveWhereUniqueInput
    update: XOR<StockMoveUpdateWithoutFromWarehouseInput, StockMoveUncheckedUpdateWithoutFromWarehouseInput>
    create: XOR<StockMoveCreateWithoutFromWarehouseInput, StockMoveUncheckedCreateWithoutFromWarehouseInput>
  }

  export type StockMoveUpdateWithWhereUniqueWithoutFromWarehouseInput = {
    where: StockMoveWhereUniqueInput
    data: XOR<StockMoveUpdateWithoutFromWarehouseInput, StockMoveUncheckedUpdateWithoutFromWarehouseInput>
  }

  export type StockMoveUpdateManyWithWhereWithoutFromWarehouseInput = {
    where: StockMoveScalarWhereInput
    data: XOR<StockMoveUpdateManyMutationInput, StockMoveUncheckedUpdateManyWithoutFromWarehouseInput>
  }

  export type StockMoveUpsertWithWhereUniqueWithoutToWarehouseInput = {
    where: StockMoveWhereUniqueInput
    update: XOR<StockMoveUpdateWithoutToWarehouseInput, StockMoveUncheckedUpdateWithoutToWarehouseInput>
    create: XOR<StockMoveCreateWithoutToWarehouseInput, StockMoveUncheckedCreateWithoutToWarehouseInput>
  }

  export type StockMoveUpdateWithWhereUniqueWithoutToWarehouseInput = {
    where: StockMoveWhereUniqueInput
    data: XOR<StockMoveUpdateWithoutToWarehouseInput, StockMoveUncheckedUpdateWithoutToWarehouseInput>
  }

  export type StockMoveUpdateManyWithWhereWithoutToWarehouseInput = {
    where: StockMoveScalarWhereInput
    data: XOR<StockMoveUpdateManyMutationInput, StockMoveUncheckedUpdateManyWithoutToWarehouseInput>
  }

  export type ReorderRuleUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: ReorderRuleWhereUniqueInput
    update: XOR<ReorderRuleUpdateWithoutWarehouseInput, ReorderRuleUncheckedUpdateWithoutWarehouseInput>
    create: XOR<ReorderRuleCreateWithoutWarehouseInput, ReorderRuleUncheckedCreateWithoutWarehouseInput>
  }

  export type ReorderRuleUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: ReorderRuleWhereUniqueInput
    data: XOR<ReorderRuleUpdateWithoutWarehouseInput, ReorderRuleUncheckedUpdateWithoutWarehouseInput>
  }

  export type ReorderRuleUpdateManyWithWhereWithoutWarehouseInput = {
    where: ReorderRuleScalarWhereInput
    data: XOR<ReorderRuleUpdateManyMutationInput, ReorderRuleUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type WarehouseCreateWithoutLocationsInput = {
    code: string
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stockQuants?: StockQuantCreateNestedManyWithoutWarehouseInput
    receipts?: ReceiptCreateNestedManyWithoutWarehouseInput
    deliveries?: DeliveryCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferCreateNestedManyWithoutToWarehouseInput
    adjustments?: AdjustmentCreateNestedManyWithoutWarehouseInput
    stockMovesFrom?: StockMoveCreateNestedManyWithoutFromWarehouseInput
    stockMovesTo?: StockMoveCreateNestedManyWithoutToWarehouseInput
    reorderRules?: ReorderRuleCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutLocationsInput = {
    id?: number
    code: string
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stockQuants?: StockQuantUncheckedCreateNestedManyWithoutWarehouseInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutWarehouseInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToWarehouseInput
    adjustments?: AdjustmentUncheckedCreateNestedManyWithoutWarehouseInput
    stockMovesFrom?: StockMoveUncheckedCreateNestedManyWithoutFromWarehouseInput
    stockMovesTo?: StockMoveUncheckedCreateNestedManyWithoutToWarehouseInput
    reorderRules?: ReorderRuleUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutLocationsInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutLocationsInput, WarehouseUncheckedCreateWithoutLocationsInput>
  }

  export type StockQuantCreateWithoutLocationInput = {
    quantity?: Decimal | DecimalJsLike | number | string
    reserved?: Decimal | DecimalJsLike | number | string
    incoming?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutStockQuantsInput
    warehouse: WarehouseCreateNestedOneWithoutStockQuantsInput
  }

  export type StockQuantUncheckedCreateWithoutLocationInput = {
    id?: number
    productId: number
    warehouseId: number
    quantity?: Decimal | DecimalJsLike | number | string
    reserved?: Decimal | DecimalJsLike | number | string
    incoming?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockQuantCreateOrConnectWithoutLocationInput = {
    where: StockQuantWhereUniqueInput
    create: XOR<StockQuantCreateWithoutLocationInput, StockQuantUncheckedCreateWithoutLocationInput>
  }

  export type StockQuantCreateManyLocationInputEnvelope = {
    data: StockQuantCreateManyLocationInput | StockQuantCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type StockMoveCreateWithoutFromLocationInput = {
    moveNo?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    reason?: string | null
    reference?: string | null
    documentType?: string | null
    documentId?: number | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutStockMovesInput
    fromWarehouse?: WarehouseCreateNestedOneWithoutStockMovesFromInput
    toWarehouse?: WarehouseCreateNestedOneWithoutStockMovesToInput
    toLocation?: LocationCreateNestedOneWithoutStockMovesToInput
    createdBy?: UserCreateNestedOneWithoutStockMovesCreatedInput
  }

  export type StockMoveUncheckedCreateWithoutFromLocationInput = {
    id?: number
    moveNo?: string | null
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    fromWarehouseId?: number | null
    toWarehouseId?: number | null
    toLocationId?: number | null
    reason?: string | null
    reference?: string | null
    documentType?: string | null
    documentId?: number | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
  }

  export type StockMoveCreateOrConnectWithoutFromLocationInput = {
    where: StockMoveWhereUniqueInput
    create: XOR<StockMoveCreateWithoutFromLocationInput, StockMoveUncheckedCreateWithoutFromLocationInput>
  }

  export type StockMoveCreateManyFromLocationInputEnvelope = {
    data: StockMoveCreateManyFromLocationInput | StockMoveCreateManyFromLocationInput[]
    skipDuplicates?: boolean
  }

  export type StockMoveCreateWithoutToLocationInput = {
    moveNo?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    reason?: string | null
    reference?: string | null
    documentType?: string | null
    documentId?: number | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutStockMovesInput
    fromWarehouse?: WarehouseCreateNestedOneWithoutStockMovesFromInput
    toWarehouse?: WarehouseCreateNestedOneWithoutStockMovesToInput
    fromLocation?: LocationCreateNestedOneWithoutStockMovesFromInput
    createdBy?: UserCreateNestedOneWithoutStockMovesCreatedInput
  }

  export type StockMoveUncheckedCreateWithoutToLocationInput = {
    id?: number
    moveNo?: string | null
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    fromWarehouseId?: number | null
    toWarehouseId?: number | null
    fromLocationId?: number | null
    reason?: string | null
    reference?: string | null
    documentType?: string | null
    documentId?: number | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
  }

  export type StockMoveCreateOrConnectWithoutToLocationInput = {
    where: StockMoveWhereUniqueInput
    create: XOR<StockMoveCreateWithoutToLocationInput, StockMoveUncheckedCreateWithoutToLocationInput>
  }

  export type StockMoveCreateManyToLocationInputEnvelope = {
    data: StockMoveCreateManyToLocationInput | StockMoveCreateManyToLocationInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseUpsertWithoutLocationsInput = {
    update: XOR<WarehouseUpdateWithoutLocationsInput, WarehouseUncheckedUpdateWithoutLocationsInput>
    create: XOR<WarehouseCreateWithoutLocationsInput, WarehouseUncheckedCreateWithoutLocationsInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutLocationsInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutLocationsInput, WarehouseUncheckedUpdateWithoutLocationsInput>
  }

  export type WarehouseUpdateWithoutLocationsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuants?: StockQuantUpdateManyWithoutWarehouseNestedInput
    receipts?: ReceiptUpdateManyWithoutWarehouseNestedInput
    deliveries?: DeliveryUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUpdateManyWithoutToWarehouseNestedInput
    adjustments?: AdjustmentUpdateManyWithoutWarehouseNestedInput
    stockMovesFrom?: StockMoveUpdateManyWithoutFromWarehouseNestedInput
    stockMovesTo?: StockMoveUpdateManyWithoutToWarehouseNestedInput
    reorderRules?: ReorderRuleUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuants?: StockQuantUncheckedUpdateManyWithoutWarehouseNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutWarehouseNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToWarehouseNestedInput
    adjustments?: AdjustmentUncheckedUpdateManyWithoutWarehouseNestedInput
    stockMovesFrom?: StockMoveUncheckedUpdateManyWithoutFromWarehouseNestedInput
    stockMovesTo?: StockMoveUncheckedUpdateManyWithoutToWarehouseNestedInput
    reorderRules?: ReorderRuleUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type StockQuantUpsertWithWhereUniqueWithoutLocationInput = {
    where: StockQuantWhereUniqueInput
    update: XOR<StockQuantUpdateWithoutLocationInput, StockQuantUncheckedUpdateWithoutLocationInput>
    create: XOR<StockQuantCreateWithoutLocationInput, StockQuantUncheckedCreateWithoutLocationInput>
  }

  export type StockQuantUpdateWithWhereUniqueWithoutLocationInput = {
    where: StockQuantWhereUniqueInput
    data: XOR<StockQuantUpdateWithoutLocationInput, StockQuantUncheckedUpdateWithoutLocationInput>
  }

  export type StockQuantUpdateManyWithWhereWithoutLocationInput = {
    where: StockQuantScalarWhereInput
    data: XOR<StockQuantUpdateManyMutationInput, StockQuantUncheckedUpdateManyWithoutLocationInput>
  }

  export type StockMoveUpsertWithWhereUniqueWithoutFromLocationInput = {
    where: StockMoveWhereUniqueInput
    update: XOR<StockMoveUpdateWithoutFromLocationInput, StockMoveUncheckedUpdateWithoutFromLocationInput>
    create: XOR<StockMoveCreateWithoutFromLocationInput, StockMoveUncheckedCreateWithoutFromLocationInput>
  }

  export type StockMoveUpdateWithWhereUniqueWithoutFromLocationInput = {
    where: StockMoveWhereUniqueInput
    data: XOR<StockMoveUpdateWithoutFromLocationInput, StockMoveUncheckedUpdateWithoutFromLocationInput>
  }

  export type StockMoveUpdateManyWithWhereWithoutFromLocationInput = {
    where: StockMoveScalarWhereInput
    data: XOR<StockMoveUpdateManyMutationInput, StockMoveUncheckedUpdateManyWithoutFromLocationInput>
  }

  export type StockMoveUpsertWithWhereUniqueWithoutToLocationInput = {
    where: StockMoveWhereUniqueInput
    update: XOR<StockMoveUpdateWithoutToLocationInput, StockMoveUncheckedUpdateWithoutToLocationInput>
    create: XOR<StockMoveCreateWithoutToLocationInput, StockMoveUncheckedCreateWithoutToLocationInput>
  }

  export type StockMoveUpdateWithWhereUniqueWithoutToLocationInput = {
    where: StockMoveWhereUniqueInput
    data: XOR<StockMoveUpdateWithoutToLocationInput, StockMoveUncheckedUpdateWithoutToLocationInput>
  }

  export type StockMoveUpdateManyWithWhereWithoutToLocationInput = {
    where: StockMoveScalarWhereInput
    data: XOR<StockMoveUpdateManyMutationInput, StockMoveUncheckedUpdateManyWithoutToLocationInput>
  }

  export type ProductCreateWithoutStockQuantsInput = {
    sku: string
    name: string
    description?: string | null
    uom: string
    defaultPrice: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockMoves?: StockMoveCreateNestedManyWithoutProductInput
    receiptLines?: ReceiptLineCreateNestedManyWithoutProductInput
    deliveryLines?: DeliveryLineCreateNestedManyWithoutProductInput
    transferLines?: TransferLineCreateNestedManyWithoutProductInput
    adjustmentLines?: AdjustmentLineCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    reorderRules?: ReorderRuleCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutStockQuantsInput = {
    id?: number
    sku: string
    name: string
    description?: string | null
    uom: string
    defaultPrice: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: number | null
    stockMoves?: StockMoveUncheckedCreateNestedManyWithoutProductInput
    receiptLines?: ReceiptLineUncheckedCreateNestedManyWithoutProductInput
    deliveryLines?: DeliveryLineUncheckedCreateNestedManyWithoutProductInput
    transferLines?: TransferLineUncheckedCreateNestedManyWithoutProductInput
    adjustmentLines?: AdjustmentLineUncheckedCreateNestedManyWithoutProductInput
    reorderRules?: ReorderRuleUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStockQuantsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStockQuantsInput, ProductUncheckedCreateWithoutStockQuantsInput>
  }

  export type WarehouseCreateWithoutStockQuantsInput = {
    code: string
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutWarehouseInput
    receipts?: ReceiptCreateNestedManyWithoutWarehouseInput
    deliveries?: DeliveryCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferCreateNestedManyWithoutToWarehouseInput
    adjustments?: AdjustmentCreateNestedManyWithoutWarehouseInput
    stockMovesFrom?: StockMoveCreateNestedManyWithoutFromWarehouseInput
    stockMovesTo?: StockMoveCreateNestedManyWithoutToWarehouseInput
    reorderRules?: ReorderRuleCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutStockQuantsInput = {
    id?: number
    code: string
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutWarehouseInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutWarehouseInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToWarehouseInput
    adjustments?: AdjustmentUncheckedCreateNestedManyWithoutWarehouseInput
    stockMovesFrom?: StockMoveUncheckedCreateNestedManyWithoutFromWarehouseInput
    stockMovesTo?: StockMoveUncheckedCreateNestedManyWithoutToWarehouseInput
    reorderRules?: ReorderRuleUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutStockQuantsInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutStockQuantsInput, WarehouseUncheckedCreateWithoutStockQuantsInput>
  }

  export type LocationCreateWithoutStockQuantsInput = {
    code: string
    name: string
    parentId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutLocationsInput
    stockMovesFrom?: StockMoveCreateNestedManyWithoutFromLocationInput
    stockMovesTo?: StockMoveCreateNestedManyWithoutToLocationInput
  }

  export type LocationUncheckedCreateWithoutStockQuantsInput = {
    id?: number
    code: string
    name: string
    warehouseId: number
    parentId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockMovesFrom?: StockMoveUncheckedCreateNestedManyWithoutFromLocationInput
    stockMovesTo?: StockMoveUncheckedCreateNestedManyWithoutToLocationInput
  }

  export type LocationCreateOrConnectWithoutStockQuantsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutStockQuantsInput, LocationUncheckedCreateWithoutStockQuantsInput>
  }

  export type ProductUpsertWithoutStockQuantsInput = {
    update: XOR<ProductUpdateWithoutStockQuantsInput, ProductUncheckedUpdateWithoutStockQuantsInput>
    create: XOR<ProductCreateWithoutStockQuantsInput, ProductUncheckedCreateWithoutStockQuantsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutStockQuantsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutStockQuantsInput, ProductUncheckedUpdateWithoutStockQuantsInput>
  }

  export type ProductUpdateWithoutStockQuantsInput = {
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockMoves?: StockMoveUpdateManyWithoutProductNestedInput
    receiptLines?: ReceiptLineUpdateManyWithoutProductNestedInput
    deliveryLines?: DeliveryLineUpdateManyWithoutProductNestedInput
    transferLines?: TransferLineUpdateManyWithoutProductNestedInput
    adjustmentLines?: AdjustmentLineUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    reorderRules?: ReorderRuleUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutStockQuantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    stockMoves?: StockMoveUncheckedUpdateManyWithoutProductNestedInput
    receiptLines?: ReceiptLineUncheckedUpdateManyWithoutProductNestedInput
    deliveryLines?: DeliveryLineUncheckedUpdateManyWithoutProductNestedInput
    transferLines?: TransferLineUncheckedUpdateManyWithoutProductNestedInput
    adjustmentLines?: AdjustmentLineUncheckedUpdateManyWithoutProductNestedInput
    reorderRules?: ReorderRuleUncheckedUpdateManyWithoutProductNestedInput
  }

  export type WarehouseUpsertWithoutStockQuantsInput = {
    update: XOR<WarehouseUpdateWithoutStockQuantsInput, WarehouseUncheckedUpdateWithoutStockQuantsInput>
    create: XOR<WarehouseCreateWithoutStockQuantsInput, WarehouseUncheckedCreateWithoutStockQuantsInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutStockQuantsInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutStockQuantsInput, WarehouseUncheckedUpdateWithoutStockQuantsInput>
  }

  export type WarehouseUpdateWithoutStockQuantsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutWarehouseNestedInput
    receipts?: ReceiptUpdateManyWithoutWarehouseNestedInput
    deliveries?: DeliveryUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUpdateManyWithoutToWarehouseNestedInput
    adjustments?: AdjustmentUpdateManyWithoutWarehouseNestedInput
    stockMovesFrom?: StockMoveUpdateManyWithoutFromWarehouseNestedInput
    stockMovesTo?: StockMoveUpdateManyWithoutToWarehouseNestedInput
    reorderRules?: ReorderRuleUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutStockQuantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutWarehouseNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutWarehouseNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToWarehouseNestedInput
    adjustments?: AdjustmentUncheckedUpdateManyWithoutWarehouseNestedInput
    stockMovesFrom?: StockMoveUncheckedUpdateManyWithoutFromWarehouseNestedInput
    stockMovesTo?: StockMoveUncheckedUpdateManyWithoutToWarehouseNestedInput
    reorderRules?: ReorderRuleUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type LocationUpsertWithoutStockQuantsInput = {
    update: XOR<LocationUpdateWithoutStockQuantsInput, LocationUncheckedUpdateWithoutStockQuantsInput>
    create: XOR<LocationCreateWithoutStockQuantsInput, LocationUncheckedCreateWithoutStockQuantsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutStockQuantsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutStockQuantsInput, LocationUncheckedUpdateWithoutStockQuantsInput>
  }

  export type LocationUpdateWithoutStockQuantsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutLocationsNestedInput
    stockMovesFrom?: StockMoveUpdateManyWithoutFromLocationNestedInput
    stockMovesTo?: StockMoveUpdateManyWithoutToLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutStockQuantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    warehouseId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockMovesFrom?: StockMoveUncheckedUpdateManyWithoutFromLocationNestedInput
    stockMovesTo?: StockMoveUncheckedUpdateManyWithoutToLocationNestedInput
  }

  export type WarehouseCreateWithoutReceiptsInput = {
    code: string
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutWarehouseInput
    stockQuants?: StockQuantCreateNestedManyWithoutWarehouseInput
    deliveries?: DeliveryCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferCreateNestedManyWithoutToWarehouseInput
    adjustments?: AdjustmentCreateNestedManyWithoutWarehouseInput
    stockMovesFrom?: StockMoveCreateNestedManyWithoutFromWarehouseInput
    stockMovesTo?: StockMoveCreateNestedManyWithoutToWarehouseInput
    reorderRules?: ReorderRuleCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutReceiptsInput = {
    id?: number
    code: string
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutWarehouseInput
    stockQuants?: StockQuantUncheckedCreateNestedManyWithoutWarehouseInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToWarehouseInput
    adjustments?: AdjustmentUncheckedCreateNestedManyWithoutWarehouseInput
    stockMovesFrom?: StockMoveUncheckedCreateNestedManyWithoutFromWarehouseInput
    stockMovesTo?: StockMoveUncheckedCreateNestedManyWithoutToWarehouseInput
    reorderRules?: ReorderRuleUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutReceiptsInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutReceiptsInput, WarehouseUncheckedCreateWithoutReceiptsInput>
  }

  export type UserCreateWithoutReceiptsCreatedInput = {
    name?: string | null
    email: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveriesCreated?: DeliveryCreateNestedManyWithoutCreatedByInput
    transfersCreated?: TransferCreateNestedManyWithoutCreatedByInput
    adjustmentsCreated?: AdjustmentCreateNestedManyWithoutCreatedByInput
    stockMovesCreated?: StockMoveCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutReceiptsCreatedInput = {
    id?: number
    name?: string | null
    email: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveriesCreated?: DeliveryUncheckedCreateNestedManyWithoutCreatedByInput
    transfersCreated?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    adjustmentsCreated?: AdjustmentUncheckedCreateNestedManyWithoutCreatedByInput
    stockMovesCreated?: StockMoveUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutReceiptsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceiptsCreatedInput, UserUncheckedCreateWithoutReceiptsCreatedInput>
  }

  export type ReceiptLineCreateWithoutReceiptInput = {
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    product: ProductCreateNestedOneWithoutReceiptLinesInput
  }

  export type ReceiptLineUncheckedCreateWithoutReceiptInput = {
    id?: number
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
  }

  export type ReceiptLineCreateOrConnectWithoutReceiptInput = {
    where: ReceiptLineWhereUniqueInput
    create: XOR<ReceiptLineCreateWithoutReceiptInput, ReceiptLineUncheckedCreateWithoutReceiptInput>
  }

  export type ReceiptLineCreateManyReceiptInputEnvelope = {
    data: ReceiptLineCreateManyReceiptInput | ReceiptLineCreateManyReceiptInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseUpsertWithoutReceiptsInput = {
    update: XOR<WarehouseUpdateWithoutReceiptsInput, WarehouseUncheckedUpdateWithoutReceiptsInput>
    create: XOR<WarehouseCreateWithoutReceiptsInput, WarehouseUncheckedCreateWithoutReceiptsInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutReceiptsInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutReceiptsInput, WarehouseUncheckedUpdateWithoutReceiptsInput>
  }

  export type WarehouseUpdateWithoutReceiptsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutWarehouseNestedInput
    stockQuants?: StockQuantUpdateManyWithoutWarehouseNestedInput
    deliveries?: DeliveryUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUpdateManyWithoutToWarehouseNestedInput
    adjustments?: AdjustmentUpdateManyWithoutWarehouseNestedInput
    stockMovesFrom?: StockMoveUpdateManyWithoutFromWarehouseNestedInput
    stockMovesTo?: StockMoveUpdateManyWithoutToWarehouseNestedInput
    reorderRules?: ReorderRuleUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutReceiptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutWarehouseNestedInput
    stockQuants?: StockQuantUncheckedUpdateManyWithoutWarehouseNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToWarehouseNestedInput
    adjustments?: AdjustmentUncheckedUpdateManyWithoutWarehouseNestedInput
    stockMovesFrom?: StockMoveUncheckedUpdateManyWithoutFromWarehouseNestedInput
    stockMovesTo?: StockMoveUncheckedUpdateManyWithoutToWarehouseNestedInput
    reorderRules?: ReorderRuleUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type UserUpsertWithoutReceiptsCreatedInput = {
    update: XOR<UserUpdateWithoutReceiptsCreatedInput, UserUncheckedUpdateWithoutReceiptsCreatedInput>
    create: XOR<UserCreateWithoutReceiptsCreatedInput, UserUncheckedCreateWithoutReceiptsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceiptsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceiptsCreatedInput, UserUncheckedUpdateWithoutReceiptsCreatedInput>
  }

  export type UserUpdateWithoutReceiptsCreatedInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveriesCreated?: DeliveryUpdateManyWithoutCreatedByNestedInput
    transfersCreated?: TransferUpdateManyWithoutCreatedByNestedInput
    adjustmentsCreated?: AdjustmentUpdateManyWithoutCreatedByNestedInput
    stockMovesCreated?: StockMoveUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutReceiptsCreatedInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveriesCreated?: DeliveryUncheckedUpdateManyWithoutCreatedByNestedInput
    transfersCreated?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    adjustmentsCreated?: AdjustmentUncheckedUpdateManyWithoutCreatedByNestedInput
    stockMovesCreated?: StockMoveUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ReceiptLineUpsertWithWhereUniqueWithoutReceiptInput = {
    where: ReceiptLineWhereUniqueInput
    update: XOR<ReceiptLineUpdateWithoutReceiptInput, ReceiptLineUncheckedUpdateWithoutReceiptInput>
    create: XOR<ReceiptLineCreateWithoutReceiptInput, ReceiptLineUncheckedCreateWithoutReceiptInput>
  }

  export type ReceiptLineUpdateWithWhereUniqueWithoutReceiptInput = {
    where: ReceiptLineWhereUniqueInput
    data: XOR<ReceiptLineUpdateWithoutReceiptInput, ReceiptLineUncheckedUpdateWithoutReceiptInput>
  }

  export type ReceiptLineUpdateManyWithWhereWithoutReceiptInput = {
    where: ReceiptLineScalarWhereInput
    data: XOR<ReceiptLineUpdateManyMutationInput, ReceiptLineUncheckedUpdateManyWithoutReceiptInput>
  }

  export type ReceiptCreateWithoutLinesInput = {
    receiptNo: string
    reference?: string | null
    partner?: string | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutReceiptsInput
    createdBy?: UserCreateNestedOneWithoutReceiptsCreatedInput
  }

  export type ReceiptUncheckedCreateWithoutLinesInput = {
    id?: number
    receiptNo: string
    reference?: string | null
    warehouseId: number
    partner?: string | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceiptCreateOrConnectWithoutLinesInput = {
    where: ReceiptWhereUniqueInput
    create: XOR<ReceiptCreateWithoutLinesInput, ReceiptUncheckedCreateWithoutLinesInput>
  }

  export type ProductCreateWithoutReceiptLinesInput = {
    sku: string
    name: string
    description?: string | null
    uom: string
    defaultPrice: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockQuants?: StockQuantCreateNestedManyWithoutProductInput
    stockMoves?: StockMoveCreateNestedManyWithoutProductInput
    deliveryLines?: DeliveryLineCreateNestedManyWithoutProductInput
    transferLines?: TransferLineCreateNestedManyWithoutProductInput
    adjustmentLines?: AdjustmentLineCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    reorderRules?: ReorderRuleCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutReceiptLinesInput = {
    id?: number
    sku: string
    name: string
    description?: string | null
    uom: string
    defaultPrice: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: number | null
    stockQuants?: StockQuantUncheckedCreateNestedManyWithoutProductInput
    stockMoves?: StockMoveUncheckedCreateNestedManyWithoutProductInput
    deliveryLines?: DeliveryLineUncheckedCreateNestedManyWithoutProductInput
    transferLines?: TransferLineUncheckedCreateNestedManyWithoutProductInput
    adjustmentLines?: AdjustmentLineUncheckedCreateNestedManyWithoutProductInput
    reorderRules?: ReorderRuleUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutReceiptLinesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutReceiptLinesInput, ProductUncheckedCreateWithoutReceiptLinesInput>
  }

  export type ReceiptUpsertWithoutLinesInput = {
    update: XOR<ReceiptUpdateWithoutLinesInput, ReceiptUncheckedUpdateWithoutLinesInput>
    create: XOR<ReceiptCreateWithoutLinesInput, ReceiptUncheckedCreateWithoutLinesInput>
    where?: ReceiptWhereInput
  }

  export type ReceiptUpdateToOneWithWhereWithoutLinesInput = {
    where?: ReceiptWhereInput
    data: XOR<ReceiptUpdateWithoutLinesInput, ReceiptUncheckedUpdateWithoutLinesInput>
  }

  export type ReceiptUpdateWithoutLinesInput = {
    receiptNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutReceiptsNestedInput
    createdBy?: UserUpdateOneWithoutReceiptsCreatedNestedInput
  }

  export type ReceiptUncheckedUpdateWithoutLinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: IntFieldUpdateOperationsInput | number
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutReceiptLinesInput = {
    update: XOR<ProductUpdateWithoutReceiptLinesInput, ProductUncheckedUpdateWithoutReceiptLinesInput>
    create: XOR<ProductCreateWithoutReceiptLinesInput, ProductUncheckedCreateWithoutReceiptLinesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutReceiptLinesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutReceiptLinesInput, ProductUncheckedUpdateWithoutReceiptLinesInput>
  }

  export type ProductUpdateWithoutReceiptLinesInput = {
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuants?: StockQuantUpdateManyWithoutProductNestedInput
    stockMoves?: StockMoveUpdateManyWithoutProductNestedInput
    deliveryLines?: DeliveryLineUpdateManyWithoutProductNestedInput
    transferLines?: TransferLineUpdateManyWithoutProductNestedInput
    adjustmentLines?: AdjustmentLineUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    reorderRules?: ReorderRuleUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutReceiptLinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuants?: StockQuantUncheckedUpdateManyWithoutProductNestedInput
    stockMoves?: StockMoveUncheckedUpdateManyWithoutProductNestedInput
    deliveryLines?: DeliveryLineUncheckedUpdateManyWithoutProductNestedInput
    transferLines?: TransferLineUncheckedUpdateManyWithoutProductNestedInput
    adjustmentLines?: AdjustmentLineUncheckedUpdateManyWithoutProductNestedInput
    reorderRules?: ReorderRuleUncheckedUpdateManyWithoutProductNestedInput
  }

  export type WarehouseCreateWithoutDeliveriesInput = {
    code: string
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutWarehouseInput
    stockQuants?: StockQuantCreateNestedManyWithoutWarehouseInput
    receipts?: ReceiptCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferCreateNestedManyWithoutToWarehouseInput
    adjustments?: AdjustmentCreateNestedManyWithoutWarehouseInput
    stockMovesFrom?: StockMoveCreateNestedManyWithoutFromWarehouseInput
    stockMovesTo?: StockMoveCreateNestedManyWithoutToWarehouseInput
    reorderRules?: ReorderRuleCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutDeliveriesInput = {
    id?: number
    code: string
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutWarehouseInput
    stockQuants?: StockQuantUncheckedCreateNestedManyWithoutWarehouseInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToWarehouseInput
    adjustments?: AdjustmentUncheckedCreateNestedManyWithoutWarehouseInput
    stockMovesFrom?: StockMoveUncheckedCreateNestedManyWithoutFromWarehouseInput
    stockMovesTo?: StockMoveUncheckedCreateNestedManyWithoutToWarehouseInput
    reorderRules?: ReorderRuleUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutDeliveriesInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutDeliveriesInput, WarehouseUncheckedCreateWithoutDeliveriesInput>
  }

  export type UserCreateWithoutDeliveriesCreatedInput = {
    name?: string | null
    email: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    receiptsCreated?: ReceiptCreateNestedManyWithoutCreatedByInput
    transfersCreated?: TransferCreateNestedManyWithoutCreatedByInput
    adjustmentsCreated?: AdjustmentCreateNestedManyWithoutCreatedByInput
    stockMovesCreated?: StockMoveCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutDeliveriesCreatedInput = {
    id?: number
    name?: string | null
    email: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    receiptsCreated?: ReceiptUncheckedCreateNestedManyWithoutCreatedByInput
    transfersCreated?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    adjustmentsCreated?: AdjustmentUncheckedCreateNestedManyWithoutCreatedByInput
    stockMovesCreated?: StockMoveUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutDeliveriesCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeliveriesCreatedInput, UserUncheckedCreateWithoutDeliveriesCreatedInput>
  }

  export type DeliveryLineCreateWithoutDeliveryInput = {
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    product: ProductCreateNestedOneWithoutDeliveryLinesInput
  }

  export type DeliveryLineUncheckedCreateWithoutDeliveryInput = {
    id?: number
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
  }

  export type DeliveryLineCreateOrConnectWithoutDeliveryInput = {
    where: DeliveryLineWhereUniqueInput
    create: XOR<DeliveryLineCreateWithoutDeliveryInput, DeliveryLineUncheckedCreateWithoutDeliveryInput>
  }

  export type DeliveryLineCreateManyDeliveryInputEnvelope = {
    data: DeliveryLineCreateManyDeliveryInput | DeliveryLineCreateManyDeliveryInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseUpsertWithoutDeliveriesInput = {
    update: XOR<WarehouseUpdateWithoutDeliveriesInput, WarehouseUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<WarehouseCreateWithoutDeliveriesInput, WarehouseUncheckedCreateWithoutDeliveriesInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutDeliveriesInput, WarehouseUncheckedUpdateWithoutDeliveriesInput>
  }

  export type WarehouseUpdateWithoutDeliveriesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutWarehouseNestedInput
    stockQuants?: StockQuantUpdateManyWithoutWarehouseNestedInput
    receipts?: ReceiptUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUpdateManyWithoutToWarehouseNestedInput
    adjustments?: AdjustmentUpdateManyWithoutWarehouseNestedInput
    stockMovesFrom?: StockMoveUpdateManyWithoutFromWarehouseNestedInput
    stockMovesTo?: StockMoveUpdateManyWithoutToWarehouseNestedInput
    reorderRules?: ReorderRuleUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutDeliveriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutWarehouseNestedInput
    stockQuants?: StockQuantUncheckedUpdateManyWithoutWarehouseNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToWarehouseNestedInput
    adjustments?: AdjustmentUncheckedUpdateManyWithoutWarehouseNestedInput
    stockMovesFrom?: StockMoveUncheckedUpdateManyWithoutFromWarehouseNestedInput
    stockMovesTo?: StockMoveUncheckedUpdateManyWithoutToWarehouseNestedInput
    reorderRules?: ReorderRuleUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type UserUpsertWithoutDeliveriesCreatedInput = {
    update: XOR<UserUpdateWithoutDeliveriesCreatedInput, UserUncheckedUpdateWithoutDeliveriesCreatedInput>
    create: XOR<UserCreateWithoutDeliveriesCreatedInput, UserUncheckedCreateWithoutDeliveriesCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeliveriesCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeliveriesCreatedInput, UserUncheckedUpdateWithoutDeliveriesCreatedInput>
  }

  export type UserUpdateWithoutDeliveriesCreatedInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptsCreated?: ReceiptUpdateManyWithoutCreatedByNestedInput
    transfersCreated?: TransferUpdateManyWithoutCreatedByNestedInput
    adjustmentsCreated?: AdjustmentUpdateManyWithoutCreatedByNestedInput
    stockMovesCreated?: StockMoveUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutDeliveriesCreatedInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptsCreated?: ReceiptUncheckedUpdateManyWithoutCreatedByNestedInput
    transfersCreated?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    adjustmentsCreated?: AdjustmentUncheckedUpdateManyWithoutCreatedByNestedInput
    stockMovesCreated?: StockMoveUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type DeliveryLineUpsertWithWhereUniqueWithoutDeliveryInput = {
    where: DeliveryLineWhereUniqueInput
    update: XOR<DeliveryLineUpdateWithoutDeliveryInput, DeliveryLineUncheckedUpdateWithoutDeliveryInput>
    create: XOR<DeliveryLineCreateWithoutDeliveryInput, DeliveryLineUncheckedCreateWithoutDeliveryInput>
  }

  export type DeliveryLineUpdateWithWhereUniqueWithoutDeliveryInput = {
    where: DeliveryLineWhereUniqueInput
    data: XOR<DeliveryLineUpdateWithoutDeliveryInput, DeliveryLineUncheckedUpdateWithoutDeliveryInput>
  }

  export type DeliveryLineUpdateManyWithWhereWithoutDeliveryInput = {
    where: DeliveryLineScalarWhereInput
    data: XOR<DeliveryLineUpdateManyMutationInput, DeliveryLineUncheckedUpdateManyWithoutDeliveryInput>
  }

  export type DeliveryCreateWithoutLinesInput = {
    deliveryNo: string
    reference?: string | null
    partner?: string | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutDeliveriesInput
    createdBy?: UserCreateNestedOneWithoutDeliveriesCreatedInput
  }

  export type DeliveryUncheckedCreateWithoutLinesInput = {
    id?: number
    deliveryNo: string
    reference?: string | null
    warehouseId: number
    partner?: string | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryCreateOrConnectWithoutLinesInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutLinesInput, DeliveryUncheckedCreateWithoutLinesInput>
  }

  export type ProductCreateWithoutDeliveryLinesInput = {
    sku: string
    name: string
    description?: string | null
    uom: string
    defaultPrice: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockQuants?: StockQuantCreateNestedManyWithoutProductInput
    stockMoves?: StockMoveCreateNestedManyWithoutProductInput
    receiptLines?: ReceiptLineCreateNestedManyWithoutProductInput
    transferLines?: TransferLineCreateNestedManyWithoutProductInput
    adjustmentLines?: AdjustmentLineCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    reorderRules?: ReorderRuleCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutDeliveryLinesInput = {
    id?: number
    sku: string
    name: string
    description?: string | null
    uom: string
    defaultPrice: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: number | null
    stockQuants?: StockQuantUncheckedCreateNestedManyWithoutProductInput
    stockMoves?: StockMoveUncheckedCreateNestedManyWithoutProductInput
    receiptLines?: ReceiptLineUncheckedCreateNestedManyWithoutProductInput
    transferLines?: TransferLineUncheckedCreateNestedManyWithoutProductInput
    adjustmentLines?: AdjustmentLineUncheckedCreateNestedManyWithoutProductInput
    reorderRules?: ReorderRuleUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutDeliveryLinesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutDeliveryLinesInput, ProductUncheckedCreateWithoutDeliveryLinesInput>
  }

  export type DeliveryUpsertWithoutLinesInput = {
    update: XOR<DeliveryUpdateWithoutLinesInput, DeliveryUncheckedUpdateWithoutLinesInput>
    create: XOR<DeliveryCreateWithoutLinesInput, DeliveryUncheckedCreateWithoutLinesInput>
    where?: DeliveryWhereInput
  }

  export type DeliveryUpdateToOneWithWhereWithoutLinesInput = {
    where?: DeliveryWhereInput
    data: XOR<DeliveryUpdateWithoutLinesInput, DeliveryUncheckedUpdateWithoutLinesInput>
  }

  export type DeliveryUpdateWithoutLinesInput = {
    deliveryNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutDeliveriesNestedInput
    createdBy?: UserUpdateOneWithoutDeliveriesCreatedNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutLinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    deliveryNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: IntFieldUpdateOperationsInput | number
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutDeliveryLinesInput = {
    update: XOR<ProductUpdateWithoutDeliveryLinesInput, ProductUncheckedUpdateWithoutDeliveryLinesInput>
    create: XOR<ProductCreateWithoutDeliveryLinesInput, ProductUncheckedCreateWithoutDeliveryLinesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutDeliveryLinesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutDeliveryLinesInput, ProductUncheckedUpdateWithoutDeliveryLinesInput>
  }

  export type ProductUpdateWithoutDeliveryLinesInput = {
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuants?: StockQuantUpdateManyWithoutProductNestedInput
    stockMoves?: StockMoveUpdateManyWithoutProductNestedInput
    receiptLines?: ReceiptLineUpdateManyWithoutProductNestedInput
    transferLines?: TransferLineUpdateManyWithoutProductNestedInput
    adjustmentLines?: AdjustmentLineUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    reorderRules?: ReorderRuleUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutDeliveryLinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuants?: StockQuantUncheckedUpdateManyWithoutProductNestedInput
    stockMoves?: StockMoveUncheckedUpdateManyWithoutProductNestedInput
    receiptLines?: ReceiptLineUncheckedUpdateManyWithoutProductNestedInput
    transferLines?: TransferLineUncheckedUpdateManyWithoutProductNestedInput
    adjustmentLines?: AdjustmentLineUncheckedUpdateManyWithoutProductNestedInput
    reorderRules?: ReorderRuleUncheckedUpdateManyWithoutProductNestedInput
  }

  export type WarehouseCreateWithoutTransfersFromInput = {
    code: string
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutWarehouseInput
    stockQuants?: StockQuantCreateNestedManyWithoutWarehouseInput
    receipts?: ReceiptCreateNestedManyWithoutWarehouseInput
    deliveries?: DeliveryCreateNestedManyWithoutWarehouseInput
    transfersTo?: TransferCreateNestedManyWithoutToWarehouseInput
    adjustments?: AdjustmentCreateNestedManyWithoutWarehouseInput
    stockMovesFrom?: StockMoveCreateNestedManyWithoutFromWarehouseInput
    stockMovesTo?: StockMoveCreateNestedManyWithoutToWarehouseInput
    reorderRules?: ReorderRuleCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutTransfersFromInput = {
    id?: number
    code: string
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutWarehouseInput
    stockQuants?: StockQuantUncheckedCreateNestedManyWithoutWarehouseInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutWarehouseInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutWarehouseInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToWarehouseInput
    adjustments?: AdjustmentUncheckedCreateNestedManyWithoutWarehouseInput
    stockMovesFrom?: StockMoveUncheckedCreateNestedManyWithoutFromWarehouseInput
    stockMovesTo?: StockMoveUncheckedCreateNestedManyWithoutToWarehouseInput
    reorderRules?: ReorderRuleUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutTransfersFromInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutTransfersFromInput, WarehouseUncheckedCreateWithoutTransfersFromInput>
  }

  export type WarehouseCreateWithoutTransfersToInput = {
    code: string
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutWarehouseInput
    stockQuants?: StockQuantCreateNestedManyWithoutWarehouseInput
    receipts?: ReceiptCreateNestedManyWithoutWarehouseInput
    deliveries?: DeliveryCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferCreateNestedManyWithoutFromWarehouseInput
    adjustments?: AdjustmentCreateNestedManyWithoutWarehouseInput
    stockMovesFrom?: StockMoveCreateNestedManyWithoutFromWarehouseInput
    stockMovesTo?: StockMoveCreateNestedManyWithoutToWarehouseInput
    reorderRules?: ReorderRuleCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutTransfersToInput = {
    id?: number
    code: string
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutWarehouseInput
    stockQuants?: StockQuantUncheckedCreateNestedManyWithoutWarehouseInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutWarehouseInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromWarehouseInput
    adjustments?: AdjustmentUncheckedCreateNestedManyWithoutWarehouseInput
    stockMovesFrom?: StockMoveUncheckedCreateNestedManyWithoutFromWarehouseInput
    stockMovesTo?: StockMoveUncheckedCreateNestedManyWithoutToWarehouseInput
    reorderRules?: ReorderRuleUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutTransfersToInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutTransfersToInput, WarehouseUncheckedCreateWithoutTransfersToInput>
  }

  export type UserCreateWithoutTransfersCreatedInput = {
    name?: string | null
    email: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    receiptsCreated?: ReceiptCreateNestedManyWithoutCreatedByInput
    deliveriesCreated?: DeliveryCreateNestedManyWithoutCreatedByInput
    adjustmentsCreated?: AdjustmentCreateNestedManyWithoutCreatedByInput
    stockMovesCreated?: StockMoveCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutTransfersCreatedInput = {
    id?: number
    name?: string | null
    email: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    receiptsCreated?: ReceiptUncheckedCreateNestedManyWithoutCreatedByInput
    deliveriesCreated?: DeliveryUncheckedCreateNestedManyWithoutCreatedByInput
    adjustmentsCreated?: AdjustmentUncheckedCreateNestedManyWithoutCreatedByInput
    stockMovesCreated?: StockMoveUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutTransfersCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransfersCreatedInput, UserUncheckedCreateWithoutTransfersCreatedInput>
  }

  export type TransferLineCreateWithoutTransferInput = {
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    product: ProductCreateNestedOneWithoutTransferLinesInput
  }

  export type TransferLineUncheckedCreateWithoutTransferInput = {
    id?: number
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
  }

  export type TransferLineCreateOrConnectWithoutTransferInput = {
    where: TransferLineWhereUniqueInput
    create: XOR<TransferLineCreateWithoutTransferInput, TransferLineUncheckedCreateWithoutTransferInput>
  }

  export type TransferLineCreateManyTransferInputEnvelope = {
    data: TransferLineCreateManyTransferInput | TransferLineCreateManyTransferInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseUpsertWithoutTransfersFromInput = {
    update: XOR<WarehouseUpdateWithoutTransfersFromInput, WarehouseUncheckedUpdateWithoutTransfersFromInput>
    create: XOR<WarehouseCreateWithoutTransfersFromInput, WarehouseUncheckedCreateWithoutTransfersFromInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutTransfersFromInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutTransfersFromInput, WarehouseUncheckedUpdateWithoutTransfersFromInput>
  }

  export type WarehouseUpdateWithoutTransfersFromInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutWarehouseNestedInput
    stockQuants?: StockQuantUpdateManyWithoutWarehouseNestedInput
    receipts?: ReceiptUpdateManyWithoutWarehouseNestedInput
    deliveries?: DeliveryUpdateManyWithoutWarehouseNestedInput
    transfersTo?: TransferUpdateManyWithoutToWarehouseNestedInput
    adjustments?: AdjustmentUpdateManyWithoutWarehouseNestedInput
    stockMovesFrom?: StockMoveUpdateManyWithoutFromWarehouseNestedInput
    stockMovesTo?: StockMoveUpdateManyWithoutToWarehouseNestedInput
    reorderRules?: ReorderRuleUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutTransfersFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutWarehouseNestedInput
    stockQuants?: StockQuantUncheckedUpdateManyWithoutWarehouseNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutWarehouseNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutWarehouseNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToWarehouseNestedInput
    adjustments?: AdjustmentUncheckedUpdateManyWithoutWarehouseNestedInput
    stockMovesFrom?: StockMoveUncheckedUpdateManyWithoutFromWarehouseNestedInput
    stockMovesTo?: StockMoveUncheckedUpdateManyWithoutToWarehouseNestedInput
    reorderRules?: ReorderRuleUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUpsertWithoutTransfersToInput = {
    update: XOR<WarehouseUpdateWithoutTransfersToInput, WarehouseUncheckedUpdateWithoutTransfersToInput>
    create: XOR<WarehouseCreateWithoutTransfersToInput, WarehouseUncheckedCreateWithoutTransfersToInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutTransfersToInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutTransfersToInput, WarehouseUncheckedUpdateWithoutTransfersToInput>
  }

  export type WarehouseUpdateWithoutTransfersToInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutWarehouseNestedInput
    stockQuants?: StockQuantUpdateManyWithoutWarehouseNestedInput
    receipts?: ReceiptUpdateManyWithoutWarehouseNestedInput
    deliveries?: DeliveryUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromWarehouseNestedInput
    adjustments?: AdjustmentUpdateManyWithoutWarehouseNestedInput
    stockMovesFrom?: StockMoveUpdateManyWithoutFromWarehouseNestedInput
    stockMovesTo?: StockMoveUpdateManyWithoutToWarehouseNestedInput
    reorderRules?: ReorderRuleUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutTransfersToInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutWarehouseNestedInput
    stockQuants?: StockQuantUncheckedUpdateManyWithoutWarehouseNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutWarehouseNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromWarehouseNestedInput
    adjustments?: AdjustmentUncheckedUpdateManyWithoutWarehouseNestedInput
    stockMovesFrom?: StockMoveUncheckedUpdateManyWithoutFromWarehouseNestedInput
    stockMovesTo?: StockMoveUncheckedUpdateManyWithoutToWarehouseNestedInput
    reorderRules?: ReorderRuleUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type UserUpsertWithoutTransfersCreatedInput = {
    update: XOR<UserUpdateWithoutTransfersCreatedInput, UserUncheckedUpdateWithoutTransfersCreatedInput>
    create: XOR<UserCreateWithoutTransfersCreatedInput, UserUncheckedCreateWithoutTransfersCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransfersCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransfersCreatedInput, UserUncheckedUpdateWithoutTransfersCreatedInput>
  }

  export type UserUpdateWithoutTransfersCreatedInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptsCreated?: ReceiptUpdateManyWithoutCreatedByNestedInput
    deliveriesCreated?: DeliveryUpdateManyWithoutCreatedByNestedInput
    adjustmentsCreated?: AdjustmentUpdateManyWithoutCreatedByNestedInput
    stockMovesCreated?: StockMoveUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTransfersCreatedInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptsCreated?: ReceiptUncheckedUpdateManyWithoutCreatedByNestedInput
    deliveriesCreated?: DeliveryUncheckedUpdateManyWithoutCreatedByNestedInput
    adjustmentsCreated?: AdjustmentUncheckedUpdateManyWithoutCreatedByNestedInput
    stockMovesCreated?: StockMoveUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type TransferLineUpsertWithWhereUniqueWithoutTransferInput = {
    where: TransferLineWhereUniqueInput
    update: XOR<TransferLineUpdateWithoutTransferInput, TransferLineUncheckedUpdateWithoutTransferInput>
    create: XOR<TransferLineCreateWithoutTransferInput, TransferLineUncheckedCreateWithoutTransferInput>
  }

  export type TransferLineUpdateWithWhereUniqueWithoutTransferInput = {
    where: TransferLineWhereUniqueInput
    data: XOR<TransferLineUpdateWithoutTransferInput, TransferLineUncheckedUpdateWithoutTransferInput>
  }

  export type TransferLineUpdateManyWithWhereWithoutTransferInput = {
    where: TransferLineScalarWhereInput
    data: XOR<TransferLineUpdateManyMutationInput, TransferLineUncheckedUpdateManyWithoutTransferInput>
  }

  export type TransferCreateWithoutLinesInput = {
    transferNo: string
    reference?: string | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    fromWarehouse: WarehouseCreateNestedOneWithoutTransfersFromInput
    toWarehouse: WarehouseCreateNestedOneWithoutTransfersToInput
    createdBy?: UserCreateNestedOneWithoutTransfersCreatedInput
  }

  export type TransferUncheckedCreateWithoutLinesInput = {
    id?: number
    transferNo: string
    reference?: string | null
    fromWarehouseId: number
    toWarehouseId: number
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateOrConnectWithoutLinesInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutLinesInput, TransferUncheckedCreateWithoutLinesInput>
  }

  export type ProductCreateWithoutTransferLinesInput = {
    sku: string
    name: string
    description?: string | null
    uom: string
    defaultPrice: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockQuants?: StockQuantCreateNestedManyWithoutProductInput
    stockMoves?: StockMoveCreateNestedManyWithoutProductInput
    receiptLines?: ReceiptLineCreateNestedManyWithoutProductInput
    deliveryLines?: DeliveryLineCreateNestedManyWithoutProductInput
    adjustmentLines?: AdjustmentLineCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    reorderRules?: ReorderRuleCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTransferLinesInput = {
    id?: number
    sku: string
    name: string
    description?: string | null
    uom: string
    defaultPrice: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: number | null
    stockQuants?: StockQuantUncheckedCreateNestedManyWithoutProductInput
    stockMoves?: StockMoveUncheckedCreateNestedManyWithoutProductInput
    receiptLines?: ReceiptLineUncheckedCreateNestedManyWithoutProductInput
    deliveryLines?: DeliveryLineUncheckedCreateNestedManyWithoutProductInput
    adjustmentLines?: AdjustmentLineUncheckedCreateNestedManyWithoutProductInput
    reorderRules?: ReorderRuleUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTransferLinesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTransferLinesInput, ProductUncheckedCreateWithoutTransferLinesInput>
  }

  export type TransferUpsertWithoutLinesInput = {
    update: XOR<TransferUpdateWithoutLinesInput, TransferUncheckedUpdateWithoutLinesInput>
    create: XOR<TransferCreateWithoutLinesInput, TransferUncheckedCreateWithoutLinesInput>
    where?: TransferWhereInput
  }

  export type TransferUpdateToOneWithWhereWithoutLinesInput = {
    where?: TransferWhereInput
    data: XOR<TransferUpdateWithoutLinesInput, TransferUncheckedUpdateWithoutLinesInput>
  }

  export type TransferUpdateWithoutLinesInput = {
    transferNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromWarehouse?: WarehouseUpdateOneRequiredWithoutTransfersFromNestedInput
    toWarehouse?: WarehouseUpdateOneRequiredWithoutTransfersToNestedInput
    createdBy?: UserUpdateOneWithoutTransfersCreatedNestedInput
  }

  export type TransferUncheckedUpdateWithoutLinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    transferNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    fromWarehouseId?: IntFieldUpdateOperationsInput | number
    toWarehouseId?: IntFieldUpdateOperationsInput | number
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutTransferLinesInput = {
    update: XOR<ProductUpdateWithoutTransferLinesInput, ProductUncheckedUpdateWithoutTransferLinesInput>
    create: XOR<ProductCreateWithoutTransferLinesInput, ProductUncheckedCreateWithoutTransferLinesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutTransferLinesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutTransferLinesInput, ProductUncheckedUpdateWithoutTransferLinesInput>
  }

  export type ProductUpdateWithoutTransferLinesInput = {
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuants?: StockQuantUpdateManyWithoutProductNestedInput
    stockMoves?: StockMoveUpdateManyWithoutProductNestedInput
    receiptLines?: ReceiptLineUpdateManyWithoutProductNestedInput
    deliveryLines?: DeliveryLineUpdateManyWithoutProductNestedInput
    adjustmentLines?: AdjustmentLineUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    reorderRules?: ReorderRuleUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutTransferLinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuants?: StockQuantUncheckedUpdateManyWithoutProductNestedInput
    stockMoves?: StockMoveUncheckedUpdateManyWithoutProductNestedInput
    receiptLines?: ReceiptLineUncheckedUpdateManyWithoutProductNestedInput
    deliveryLines?: DeliveryLineUncheckedUpdateManyWithoutProductNestedInput
    adjustmentLines?: AdjustmentLineUncheckedUpdateManyWithoutProductNestedInput
    reorderRules?: ReorderRuleUncheckedUpdateManyWithoutProductNestedInput
  }

  export type WarehouseCreateWithoutAdjustmentsInput = {
    code: string
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutWarehouseInput
    stockQuants?: StockQuantCreateNestedManyWithoutWarehouseInput
    receipts?: ReceiptCreateNestedManyWithoutWarehouseInput
    deliveries?: DeliveryCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferCreateNestedManyWithoutToWarehouseInput
    stockMovesFrom?: StockMoveCreateNestedManyWithoutFromWarehouseInput
    stockMovesTo?: StockMoveCreateNestedManyWithoutToWarehouseInput
    reorderRules?: ReorderRuleCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutAdjustmentsInput = {
    id?: number
    code: string
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutWarehouseInput
    stockQuants?: StockQuantUncheckedCreateNestedManyWithoutWarehouseInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutWarehouseInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToWarehouseInput
    stockMovesFrom?: StockMoveUncheckedCreateNestedManyWithoutFromWarehouseInput
    stockMovesTo?: StockMoveUncheckedCreateNestedManyWithoutToWarehouseInput
    reorderRules?: ReorderRuleUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutAdjustmentsInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutAdjustmentsInput, WarehouseUncheckedCreateWithoutAdjustmentsInput>
  }

  export type UserCreateWithoutAdjustmentsCreatedInput = {
    name?: string | null
    email: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    receiptsCreated?: ReceiptCreateNestedManyWithoutCreatedByInput
    deliveriesCreated?: DeliveryCreateNestedManyWithoutCreatedByInput
    transfersCreated?: TransferCreateNestedManyWithoutCreatedByInput
    stockMovesCreated?: StockMoveCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutAdjustmentsCreatedInput = {
    id?: number
    name?: string | null
    email: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    receiptsCreated?: ReceiptUncheckedCreateNestedManyWithoutCreatedByInput
    deliveriesCreated?: DeliveryUncheckedCreateNestedManyWithoutCreatedByInput
    transfersCreated?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    stockMovesCreated?: StockMoveUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutAdjustmentsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdjustmentsCreatedInput, UserUncheckedCreateWithoutAdjustmentsCreatedInput>
  }

  export type AdjustmentLineCreateWithoutAdjustmentInput = {
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    note?: string | null
    product: ProductCreateNestedOneWithoutAdjustmentLinesInput
  }

  export type AdjustmentLineUncheckedCreateWithoutAdjustmentInput = {
    id?: number
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    note?: string | null
  }

  export type AdjustmentLineCreateOrConnectWithoutAdjustmentInput = {
    where: AdjustmentLineWhereUniqueInput
    create: XOR<AdjustmentLineCreateWithoutAdjustmentInput, AdjustmentLineUncheckedCreateWithoutAdjustmentInput>
  }

  export type AdjustmentLineCreateManyAdjustmentInputEnvelope = {
    data: AdjustmentLineCreateManyAdjustmentInput | AdjustmentLineCreateManyAdjustmentInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseUpsertWithoutAdjustmentsInput = {
    update: XOR<WarehouseUpdateWithoutAdjustmentsInput, WarehouseUncheckedUpdateWithoutAdjustmentsInput>
    create: XOR<WarehouseCreateWithoutAdjustmentsInput, WarehouseUncheckedCreateWithoutAdjustmentsInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutAdjustmentsInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutAdjustmentsInput, WarehouseUncheckedUpdateWithoutAdjustmentsInput>
  }

  export type WarehouseUpdateWithoutAdjustmentsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutWarehouseNestedInput
    stockQuants?: StockQuantUpdateManyWithoutWarehouseNestedInput
    receipts?: ReceiptUpdateManyWithoutWarehouseNestedInput
    deliveries?: DeliveryUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUpdateManyWithoutToWarehouseNestedInput
    stockMovesFrom?: StockMoveUpdateManyWithoutFromWarehouseNestedInput
    stockMovesTo?: StockMoveUpdateManyWithoutToWarehouseNestedInput
    reorderRules?: ReorderRuleUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutAdjustmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutWarehouseNestedInput
    stockQuants?: StockQuantUncheckedUpdateManyWithoutWarehouseNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutWarehouseNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToWarehouseNestedInput
    stockMovesFrom?: StockMoveUncheckedUpdateManyWithoutFromWarehouseNestedInput
    stockMovesTo?: StockMoveUncheckedUpdateManyWithoutToWarehouseNestedInput
    reorderRules?: ReorderRuleUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type UserUpsertWithoutAdjustmentsCreatedInput = {
    update: XOR<UserUpdateWithoutAdjustmentsCreatedInput, UserUncheckedUpdateWithoutAdjustmentsCreatedInput>
    create: XOR<UserCreateWithoutAdjustmentsCreatedInput, UserUncheckedCreateWithoutAdjustmentsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdjustmentsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdjustmentsCreatedInput, UserUncheckedUpdateWithoutAdjustmentsCreatedInput>
  }

  export type UserUpdateWithoutAdjustmentsCreatedInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptsCreated?: ReceiptUpdateManyWithoutCreatedByNestedInput
    deliveriesCreated?: DeliveryUpdateManyWithoutCreatedByNestedInput
    transfersCreated?: TransferUpdateManyWithoutCreatedByNestedInput
    stockMovesCreated?: StockMoveUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAdjustmentsCreatedInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptsCreated?: ReceiptUncheckedUpdateManyWithoutCreatedByNestedInput
    deliveriesCreated?: DeliveryUncheckedUpdateManyWithoutCreatedByNestedInput
    transfersCreated?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    stockMovesCreated?: StockMoveUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type AdjustmentLineUpsertWithWhereUniqueWithoutAdjustmentInput = {
    where: AdjustmentLineWhereUniqueInput
    update: XOR<AdjustmentLineUpdateWithoutAdjustmentInput, AdjustmentLineUncheckedUpdateWithoutAdjustmentInput>
    create: XOR<AdjustmentLineCreateWithoutAdjustmentInput, AdjustmentLineUncheckedCreateWithoutAdjustmentInput>
  }

  export type AdjustmentLineUpdateWithWhereUniqueWithoutAdjustmentInput = {
    where: AdjustmentLineWhereUniqueInput
    data: XOR<AdjustmentLineUpdateWithoutAdjustmentInput, AdjustmentLineUncheckedUpdateWithoutAdjustmentInput>
  }

  export type AdjustmentLineUpdateManyWithWhereWithoutAdjustmentInput = {
    where: AdjustmentLineScalarWhereInput
    data: XOR<AdjustmentLineUpdateManyMutationInput, AdjustmentLineUncheckedUpdateManyWithoutAdjustmentInput>
  }

  export type AdjustmentCreateWithoutLinesInput = {
    adjustmentNo: string
    reason?: string | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutAdjustmentsInput
    createdBy?: UserCreateNestedOneWithoutAdjustmentsCreatedInput
  }

  export type AdjustmentUncheckedCreateWithoutLinesInput = {
    id?: number
    adjustmentNo: string
    warehouseId: number
    reason?: string | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdjustmentCreateOrConnectWithoutLinesInput = {
    where: AdjustmentWhereUniqueInput
    create: XOR<AdjustmentCreateWithoutLinesInput, AdjustmentUncheckedCreateWithoutLinesInput>
  }

  export type ProductCreateWithoutAdjustmentLinesInput = {
    sku: string
    name: string
    description?: string | null
    uom: string
    defaultPrice: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockQuants?: StockQuantCreateNestedManyWithoutProductInput
    stockMoves?: StockMoveCreateNestedManyWithoutProductInput
    receiptLines?: ReceiptLineCreateNestedManyWithoutProductInput
    deliveryLines?: DeliveryLineCreateNestedManyWithoutProductInput
    transferLines?: TransferLineCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    reorderRules?: ReorderRuleCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutAdjustmentLinesInput = {
    id?: number
    sku: string
    name: string
    description?: string | null
    uom: string
    defaultPrice: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: number | null
    stockQuants?: StockQuantUncheckedCreateNestedManyWithoutProductInput
    stockMoves?: StockMoveUncheckedCreateNestedManyWithoutProductInput
    receiptLines?: ReceiptLineUncheckedCreateNestedManyWithoutProductInput
    deliveryLines?: DeliveryLineUncheckedCreateNestedManyWithoutProductInput
    transferLines?: TransferLineUncheckedCreateNestedManyWithoutProductInput
    reorderRules?: ReorderRuleUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutAdjustmentLinesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutAdjustmentLinesInput, ProductUncheckedCreateWithoutAdjustmentLinesInput>
  }

  export type AdjustmentUpsertWithoutLinesInput = {
    update: XOR<AdjustmentUpdateWithoutLinesInput, AdjustmentUncheckedUpdateWithoutLinesInput>
    create: XOR<AdjustmentCreateWithoutLinesInput, AdjustmentUncheckedCreateWithoutLinesInput>
    where?: AdjustmentWhereInput
  }

  export type AdjustmentUpdateToOneWithWhereWithoutLinesInput = {
    where?: AdjustmentWhereInput
    data: XOR<AdjustmentUpdateWithoutLinesInput, AdjustmentUncheckedUpdateWithoutLinesInput>
  }

  export type AdjustmentUpdateWithoutLinesInput = {
    adjustmentNo?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutAdjustmentsNestedInput
    createdBy?: UserUpdateOneWithoutAdjustmentsCreatedNestedInput
  }

  export type AdjustmentUncheckedUpdateWithoutLinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    adjustmentNo?: StringFieldUpdateOperationsInput | string
    warehouseId?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutAdjustmentLinesInput = {
    update: XOR<ProductUpdateWithoutAdjustmentLinesInput, ProductUncheckedUpdateWithoutAdjustmentLinesInput>
    create: XOR<ProductCreateWithoutAdjustmentLinesInput, ProductUncheckedCreateWithoutAdjustmentLinesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutAdjustmentLinesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutAdjustmentLinesInput, ProductUncheckedUpdateWithoutAdjustmentLinesInput>
  }

  export type ProductUpdateWithoutAdjustmentLinesInput = {
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuants?: StockQuantUpdateManyWithoutProductNestedInput
    stockMoves?: StockMoveUpdateManyWithoutProductNestedInput
    receiptLines?: ReceiptLineUpdateManyWithoutProductNestedInput
    deliveryLines?: DeliveryLineUpdateManyWithoutProductNestedInput
    transferLines?: TransferLineUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    reorderRules?: ReorderRuleUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutAdjustmentLinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuants?: StockQuantUncheckedUpdateManyWithoutProductNestedInput
    stockMoves?: StockMoveUncheckedUpdateManyWithoutProductNestedInput
    receiptLines?: ReceiptLineUncheckedUpdateManyWithoutProductNestedInput
    deliveryLines?: DeliveryLineUncheckedUpdateManyWithoutProductNestedInput
    transferLines?: TransferLineUncheckedUpdateManyWithoutProductNestedInput
    reorderRules?: ReorderRuleUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutStockMovesInput = {
    sku: string
    name: string
    description?: string | null
    uom: string
    defaultPrice: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockQuants?: StockQuantCreateNestedManyWithoutProductInput
    receiptLines?: ReceiptLineCreateNestedManyWithoutProductInput
    deliveryLines?: DeliveryLineCreateNestedManyWithoutProductInput
    transferLines?: TransferLineCreateNestedManyWithoutProductInput
    adjustmentLines?: AdjustmentLineCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    reorderRules?: ReorderRuleCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutStockMovesInput = {
    id?: number
    sku: string
    name: string
    description?: string | null
    uom: string
    defaultPrice: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: number | null
    stockQuants?: StockQuantUncheckedCreateNestedManyWithoutProductInput
    receiptLines?: ReceiptLineUncheckedCreateNestedManyWithoutProductInput
    deliveryLines?: DeliveryLineUncheckedCreateNestedManyWithoutProductInput
    transferLines?: TransferLineUncheckedCreateNestedManyWithoutProductInput
    adjustmentLines?: AdjustmentLineUncheckedCreateNestedManyWithoutProductInput
    reorderRules?: ReorderRuleUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStockMovesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStockMovesInput, ProductUncheckedCreateWithoutStockMovesInput>
  }

  export type WarehouseCreateWithoutStockMovesFromInput = {
    code: string
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutWarehouseInput
    stockQuants?: StockQuantCreateNestedManyWithoutWarehouseInput
    receipts?: ReceiptCreateNestedManyWithoutWarehouseInput
    deliveries?: DeliveryCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferCreateNestedManyWithoutToWarehouseInput
    adjustments?: AdjustmentCreateNestedManyWithoutWarehouseInput
    stockMovesTo?: StockMoveCreateNestedManyWithoutToWarehouseInput
    reorderRules?: ReorderRuleCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutStockMovesFromInput = {
    id?: number
    code: string
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutWarehouseInput
    stockQuants?: StockQuantUncheckedCreateNestedManyWithoutWarehouseInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutWarehouseInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToWarehouseInput
    adjustments?: AdjustmentUncheckedCreateNestedManyWithoutWarehouseInput
    stockMovesTo?: StockMoveUncheckedCreateNestedManyWithoutToWarehouseInput
    reorderRules?: ReorderRuleUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutStockMovesFromInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutStockMovesFromInput, WarehouseUncheckedCreateWithoutStockMovesFromInput>
  }

  export type WarehouseCreateWithoutStockMovesToInput = {
    code: string
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutWarehouseInput
    stockQuants?: StockQuantCreateNestedManyWithoutWarehouseInput
    receipts?: ReceiptCreateNestedManyWithoutWarehouseInput
    deliveries?: DeliveryCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferCreateNestedManyWithoutToWarehouseInput
    adjustments?: AdjustmentCreateNestedManyWithoutWarehouseInput
    stockMovesFrom?: StockMoveCreateNestedManyWithoutFromWarehouseInput
    reorderRules?: ReorderRuleCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutStockMovesToInput = {
    id?: number
    code: string
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutWarehouseInput
    stockQuants?: StockQuantUncheckedCreateNestedManyWithoutWarehouseInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutWarehouseInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToWarehouseInput
    adjustments?: AdjustmentUncheckedCreateNestedManyWithoutWarehouseInput
    stockMovesFrom?: StockMoveUncheckedCreateNestedManyWithoutFromWarehouseInput
    reorderRules?: ReorderRuleUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutStockMovesToInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutStockMovesToInput, WarehouseUncheckedCreateWithoutStockMovesToInput>
  }

  export type LocationCreateWithoutStockMovesFromInput = {
    code: string
    name: string
    parentId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutLocationsInput
    stockQuants?: StockQuantCreateNestedManyWithoutLocationInput
    stockMovesTo?: StockMoveCreateNestedManyWithoutToLocationInput
  }

  export type LocationUncheckedCreateWithoutStockMovesFromInput = {
    id?: number
    code: string
    name: string
    warehouseId: number
    parentId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockQuants?: StockQuantUncheckedCreateNestedManyWithoutLocationInput
    stockMovesTo?: StockMoveUncheckedCreateNestedManyWithoutToLocationInput
  }

  export type LocationCreateOrConnectWithoutStockMovesFromInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutStockMovesFromInput, LocationUncheckedCreateWithoutStockMovesFromInput>
  }

  export type LocationCreateWithoutStockMovesToInput = {
    code: string
    name: string
    parentId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutLocationsInput
    stockQuants?: StockQuantCreateNestedManyWithoutLocationInput
    stockMovesFrom?: StockMoveCreateNestedManyWithoutFromLocationInput
  }

  export type LocationUncheckedCreateWithoutStockMovesToInput = {
    id?: number
    code: string
    name: string
    warehouseId: number
    parentId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockQuants?: StockQuantUncheckedCreateNestedManyWithoutLocationInput
    stockMovesFrom?: StockMoveUncheckedCreateNestedManyWithoutFromLocationInput
  }

  export type LocationCreateOrConnectWithoutStockMovesToInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutStockMovesToInput, LocationUncheckedCreateWithoutStockMovesToInput>
  }

  export type UserCreateWithoutStockMovesCreatedInput = {
    name?: string | null
    email: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    receiptsCreated?: ReceiptCreateNestedManyWithoutCreatedByInput
    deliveriesCreated?: DeliveryCreateNestedManyWithoutCreatedByInput
    transfersCreated?: TransferCreateNestedManyWithoutCreatedByInput
    adjustmentsCreated?: AdjustmentCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutStockMovesCreatedInput = {
    id?: number
    name?: string | null
    email: string
    passwordHash: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    receiptsCreated?: ReceiptUncheckedCreateNestedManyWithoutCreatedByInput
    deliveriesCreated?: DeliveryUncheckedCreateNestedManyWithoutCreatedByInput
    transfersCreated?: TransferUncheckedCreateNestedManyWithoutCreatedByInput
    adjustmentsCreated?: AdjustmentUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutStockMovesCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStockMovesCreatedInput, UserUncheckedCreateWithoutStockMovesCreatedInput>
  }

  export type ProductUpsertWithoutStockMovesInput = {
    update: XOR<ProductUpdateWithoutStockMovesInput, ProductUncheckedUpdateWithoutStockMovesInput>
    create: XOR<ProductCreateWithoutStockMovesInput, ProductUncheckedCreateWithoutStockMovesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutStockMovesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutStockMovesInput, ProductUncheckedUpdateWithoutStockMovesInput>
  }

  export type ProductUpdateWithoutStockMovesInput = {
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuants?: StockQuantUpdateManyWithoutProductNestedInput
    receiptLines?: ReceiptLineUpdateManyWithoutProductNestedInput
    deliveryLines?: DeliveryLineUpdateManyWithoutProductNestedInput
    transferLines?: TransferLineUpdateManyWithoutProductNestedInput
    adjustmentLines?: AdjustmentLineUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    reorderRules?: ReorderRuleUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutStockMovesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    stockQuants?: StockQuantUncheckedUpdateManyWithoutProductNestedInput
    receiptLines?: ReceiptLineUncheckedUpdateManyWithoutProductNestedInput
    deliveryLines?: DeliveryLineUncheckedUpdateManyWithoutProductNestedInput
    transferLines?: TransferLineUncheckedUpdateManyWithoutProductNestedInput
    adjustmentLines?: AdjustmentLineUncheckedUpdateManyWithoutProductNestedInput
    reorderRules?: ReorderRuleUncheckedUpdateManyWithoutProductNestedInput
  }

  export type WarehouseUpsertWithoutStockMovesFromInput = {
    update: XOR<WarehouseUpdateWithoutStockMovesFromInput, WarehouseUncheckedUpdateWithoutStockMovesFromInput>
    create: XOR<WarehouseCreateWithoutStockMovesFromInput, WarehouseUncheckedCreateWithoutStockMovesFromInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutStockMovesFromInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutStockMovesFromInput, WarehouseUncheckedUpdateWithoutStockMovesFromInput>
  }

  export type WarehouseUpdateWithoutStockMovesFromInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutWarehouseNestedInput
    stockQuants?: StockQuantUpdateManyWithoutWarehouseNestedInput
    receipts?: ReceiptUpdateManyWithoutWarehouseNestedInput
    deliveries?: DeliveryUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUpdateManyWithoutToWarehouseNestedInput
    adjustments?: AdjustmentUpdateManyWithoutWarehouseNestedInput
    stockMovesTo?: StockMoveUpdateManyWithoutToWarehouseNestedInput
    reorderRules?: ReorderRuleUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutStockMovesFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutWarehouseNestedInput
    stockQuants?: StockQuantUncheckedUpdateManyWithoutWarehouseNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutWarehouseNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToWarehouseNestedInput
    adjustments?: AdjustmentUncheckedUpdateManyWithoutWarehouseNestedInput
    stockMovesTo?: StockMoveUncheckedUpdateManyWithoutToWarehouseNestedInput
    reorderRules?: ReorderRuleUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUpsertWithoutStockMovesToInput = {
    update: XOR<WarehouseUpdateWithoutStockMovesToInput, WarehouseUncheckedUpdateWithoutStockMovesToInput>
    create: XOR<WarehouseCreateWithoutStockMovesToInput, WarehouseUncheckedCreateWithoutStockMovesToInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutStockMovesToInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutStockMovesToInput, WarehouseUncheckedUpdateWithoutStockMovesToInput>
  }

  export type WarehouseUpdateWithoutStockMovesToInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutWarehouseNestedInput
    stockQuants?: StockQuantUpdateManyWithoutWarehouseNestedInput
    receipts?: ReceiptUpdateManyWithoutWarehouseNestedInput
    deliveries?: DeliveryUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUpdateManyWithoutToWarehouseNestedInput
    adjustments?: AdjustmentUpdateManyWithoutWarehouseNestedInput
    stockMovesFrom?: StockMoveUpdateManyWithoutFromWarehouseNestedInput
    reorderRules?: ReorderRuleUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutStockMovesToInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutWarehouseNestedInput
    stockQuants?: StockQuantUncheckedUpdateManyWithoutWarehouseNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutWarehouseNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToWarehouseNestedInput
    adjustments?: AdjustmentUncheckedUpdateManyWithoutWarehouseNestedInput
    stockMovesFrom?: StockMoveUncheckedUpdateManyWithoutFromWarehouseNestedInput
    reorderRules?: ReorderRuleUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type LocationUpsertWithoutStockMovesFromInput = {
    update: XOR<LocationUpdateWithoutStockMovesFromInput, LocationUncheckedUpdateWithoutStockMovesFromInput>
    create: XOR<LocationCreateWithoutStockMovesFromInput, LocationUncheckedCreateWithoutStockMovesFromInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutStockMovesFromInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutStockMovesFromInput, LocationUncheckedUpdateWithoutStockMovesFromInput>
  }

  export type LocationUpdateWithoutStockMovesFromInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutLocationsNestedInput
    stockQuants?: StockQuantUpdateManyWithoutLocationNestedInput
    stockMovesTo?: StockMoveUpdateManyWithoutToLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutStockMovesFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    warehouseId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuants?: StockQuantUncheckedUpdateManyWithoutLocationNestedInput
    stockMovesTo?: StockMoveUncheckedUpdateManyWithoutToLocationNestedInput
  }

  export type LocationUpsertWithoutStockMovesToInput = {
    update: XOR<LocationUpdateWithoutStockMovesToInput, LocationUncheckedUpdateWithoutStockMovesToInput>
    create: XOR<LocationCreateWithoutStockMovesToInput, LocationUncheckedCreateWithoutStockMovesToInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutStockMovesToInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutStockMovesToInput, LocationUncheckedUpdateWithoutStockMovesToInput>
  }

  export type LocationUpdateWithoutStockMovesToInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutLocationsNestedInput
    stockQuants?: StockQuantUpdateManyWithoutLocationNestedInput
    stockMovesFrom?: StockMoveUpdateManyWithoutFromLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutStockMovesToInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    warehouseId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuants?: StockQuantUncheckedUpdateManyWithoutLocationNestedInput
    stockMovesFrom?: StockMoveUncheckedUpdateManyWithoutFromLocationNestedInput
  }

  export type UserUpsertWithoutStockMovesCreatedInput = {
    update: XOR<UserUpdateWithoutStockMovesCreatedInput, UserUncheckedUpdateWithoutStockMovesCreatedInput>
    create: XOR<UserCreateWithoutStockMovesCreatedInput, UserUncheckedCreateWithoutStockMovesCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStockMovesCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStockMovesCreatedInput, UserUncheckedUpdateWithoutStockMovesCreatedInput>
  }

  export type UserUpdateWithoutStockMovesCreatedInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptsCreated?: ReceiptUpdateManyWithoutCreatedByNestedInput
    deliveriesCreated?: DeliveryUpdateManyWithoutCreatedByNestedInput
    transfersCreated?: TransferUpdateManyWithoutCreatedByNestedInput
    adjustmentsCreated?: AdjustmentUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutStockMovesCreatedInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptsCreated?: ReceiptUncheckedUpdateManyWithoutCreatedByNestedInput
    deliveriesCreated?: DeliveryUncheckedUpdateManyWithoutCreatedByNestedInput
    transfersCreated?: TransferUncheckedUpdateManyWithoutCreatedByNestedInput
    adjustmentsCreated?: AdjustmentUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ReceiptCreateManyCreatedByInput = {
    id?: number
    receiptNo: string
    reference?: string | null
    warehouseId: number
    partner?: string | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryCreateManyCreatedByInput = {
    id?: number
    deliveryNo: string
    reference?: string | null
    warehouseId: number
    partner?: string | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManyCreatedByInput = {
    id?: number
    transferNo: string
    reference?: string | null
    fromWarehouseId: number
    toWarehouseId: number
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdjustmentCreateManyCreatedByInput = {
    id?: number
    adjustmentNo: string
    warehouseId: number
    reason?: string | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockMoveCreateManyCreatedByInput = {
    id?: number
    moveNo?: string | null
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    fromWarehouseId?: number | null
    toWarehouseId?: number | null
    fromLocationId?: number | null
    toLocationId?: number | null
    reason?: string | null
    reference?: string | null
    documentType?: string | null
    documentId?: number | null
    status?: $Enums.DocumentStatus
    createdAt?: Date | string
  }

  export type ReceiptUpdateWithoutCreatedByInput = {
    receiptNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutReceiptsNestedInput
    lines?: ReceiptLineUpdateManyWithoutReceiptNestedInput
  }

  export type ReceiptUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: IntFieldUpdateOperationsInput | number
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: ReceiptLineUncheckedUpdateManyWithoutReceiptNestedInput
  }

  export type ReceiptUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: IntFieldUpdateOperationsInput | number
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryUpdateWithoutCreatedByInput = {
    deliveryNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutDeliveriesNestedInput
    lines?: DeliveryLineUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    deliveryNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: IntFieldUpdateOperationsInput | number
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: DeliveryLineUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    deliveryNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: IntFieldUpdateOperationsInput | number
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutCreatedByInput = {
    transferNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromWarehouse?: WarehouseUpdateOneRequiredWithoutTransfersFromNestedInput
    toWarehouse?: WarehouseUpdateOneRequiredWithoutTransfersToNestedInput
    lines?: TransferLineUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    transferNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    fromWarehouseId?: IntFieldUpdateOperationsInput | number
    toWarehouseId?: IntFieldUpdateOperationsInput | number
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: TransferLineUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    transferNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    fromWarehouseId?: IntFieldUpdateOperationsInput | number
    toWarehouseId?: IntFieldUpdateOperationsInput | number
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdjustmentUpdateWithoutCreatedByInput = {
    adjustmentNo?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutAdjustmentsNestedInput
    lines?: AdjustmentLineUpdateManyWithoutAdjustmentNestedInput
  }

  export type AdjustmentUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    adjustmentNo?: StringFieldUpdateOperationsInput | string
    warehouseId?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: AdjustmentLineUncheckedUpdateManyWithoutAdjustmentNestedInput
  }

  export type AdjustmentUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    adjustmentNo?: StringFieldUpdateOperationsInput | string
    warehouseId?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMoveUpdateWithoutCreatedByInput = {
    moveNo?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStockMovesNestedInput
    fromWarehouse?: WarehouseUpdateOneWithoutStockMovesFromNestedInput
    toWarehouse?: WarehouseUpdateOneWithoutStockMovesToNestedInput
    fromLocation?: LocationUpdateOneWithoutStockMovesFromNestedInput
    toLocation?: LocationUpdateOneWithoutStockMovesToNestedInput
  }

  export type StockMoveUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    moveNo?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    toWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    fromLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    toLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMoveUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    moveNo?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    toWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    fromLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    toLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockQuantCreateManyProductInput = {
    id?: number
    warehouseId: number
    locationId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string
    reserved?: Decimal | DecimalJsLike | number | string
    incoming?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockMoveCreateManyProductInput = {
    id?: number
    moveNo?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    fromWarehouseId?: number | null
    toWarehouseId?: number | null
    fromLocationId?: number | null
    toLocationId?: number | null
    reason?: string | null
    reference?: string | null
    documentType?: string | null
    documentId?: number | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
  }

  export type ReceiptLineCreateManyProductInput = {
    id?: number
    receiptId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
  }

  export type DeliveryLineCreateManyProductInput = {
    id?: number
    deliveryId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
  }

  export type TransferLineCreateManyProductInput = {
    id?: number
    transferId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
  }

  export type AdjustmentLineCreateManyProductInput = {
    id?: number
    adjustmentId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    note?: string | null
  }

  export type ReorderRuleCreateManyProductInput = {
    id?: number
    warehouseId: number
    minQty: Decimal | DecimalJsLike | number | string
    maxQty?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type StockQuantUpdateWithoutProductInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reserved?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incoming?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutStockQuantsNestedInput
    location?: LocationUpdateOneWithoutStockQuantsNestedInput
  }

  export type StockQuantUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reserved?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incoming?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockQuantUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reserved?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incoming?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMoveUpdateWithoutProductInput = {
    moveNo?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromWarehouse?: WarehouseUpdateOneWithoutStockMovesFromNestedInput
    toWarehouse?: WarehouseUpdateOneWithoutStockMovesToNestedInput
    fromLocation?: LocationUpdateOneWithoutStockMovesFromNestedInput
    toLocation?: LocationUpdateOneWithoutStockMovesToNestedInput
    createdBy?: UserUpdateOneWithoutStockMovesCreatedNestedInput
  }

  export type StockMoveUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    moveNo?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    toWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    fromLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    toLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMoveUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    moveNo?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    toWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    fromLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    toLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptLineUpdateWithoutProductInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    receipt?: ReceiptUpdateOneRequiredWithoutLinesNestedInput
  }

  export type ReceiptLineUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ReceiptLineUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type DeliveryLineUpdateWithoutProductInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery?: DeliveryUpdateOneRequiredWithoutLinesNestedInput
  }

  export type DeliveryLineUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    deliveryId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type DeliveryLineUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    deliveryId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type TransferLineUpdateWithoutProductInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    transfer?: TransferUpdateOneRequiredWithoutLinesNestedInput
  }

  export type TransferLineUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    transferId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
  }

  export type TransferLineUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    transferId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
  }

  export type AdjustmentLineUpdateWithoutProductInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    adjustment?: AdjustmentUpdateOneRequiredWithoutLinesNestedInput
  }

  export type AdjustmentLineUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    adjustmentId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdjustmentLineUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    adjustmentId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReorderRuleUpdateWithoutProductInput = {
    minQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxQty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutReorderRulesNestedInput
  }

  export type ReorderRuleUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    minQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxQty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReorderRuleUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    minQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxQty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyCategoryInput = {
    id?: number
    sku: string
    name: string
    description?: string | null
    uom: string
    defaultPrice: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutCategoryInput = {
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuants?: StockQuantUpdateManyWithoutProductNestedInput
    stockMoves?: StockMoveUpdateManyWithoutProductNestedInput
    receiptLines?: ReceiptLineUpdateManyWithoutProductNestedInput
    deliveryLines?: DeliveryLineUpdateManyWithoutProductNestedInput
    transferLines?: TransferLineUpdateManyWithoutProductNestedInput
    adjustmentLines?: AdjustmentLineUpdateManyWithoutProductNestedInput
    reorderRules?: ReorderRuleUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuants?: StockQuantUncheckedUpdateManyWithoutProductNestedInput
    stockMoves?: StockMoveUncheckedUpdateManyWithoutProductNestedInput
    receiptLines?: ReceiptLineUncheckedUpdateManyWithoutProductNestedInput
    deliveryLines?: DeliveryLineUncheckedUpdateManyWithoutProductNestedInput
    transferLines?: TransferLineUncheckedUpdateManyWithoutProductNestedInput
    adjustmentLines?: AdjustmentLineUncheckedUpdateManyWithoutProductNestedInput
    reorderRules?: ReorderRuleUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateManyWarehouseInput = {
    id?: number
    code: string
    name: string
    parentId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockQuantCreateManyWarehouseInput = {
    id?: number
    productId: number
    locationId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string
    reserved?: Decimal | DecimalJsLike | number | string
    incoming?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceiptCreateManyWarehouseInput = {
    id?: number
    receiptNo: string
    reference?: string | null
    partner?: string | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryCreateManyWarehouseInput = {
    id?: number
    deliveryNo: string
    reference?: string | null
    partner?: string | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManyFromWarehouseInput = {
    id?: number
    transferNo: string
    reference?: string | null
    toWarehouseId: number
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManyToWarehouseInput = {
    id?: number
    transferNo: string
    reference?: string | null
    fromWarehouseId: number
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdjustmentCreateManyWarehouseInput = {
    id?: number
    adjustmentNo: string
    reason?: string | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockMoveCreateManyFromWarehouseInput = {
    id?: number
    moveNo?: string | null
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    toWarehouseId?: number | null
    fromLocationId?: number | null
    toLocationId?: number | null
    reason?: string | null
    reference?: string | null
    documentType?: string | null
    documentId?: number | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
  }

  export type StockMoveCreateManyToWarehouseInput = {
    id?: number
    moveNo?: string | null
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    fromWarehouseId?: number | null
    fromLocationId?: number | null
    toLocationId?: number | null
    reason?: string | null
    reference?: string | null
    documentType?: string | null
    documentId?: number | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
  }

  export type ReorderRuleCreateManyWarehouseInput = {
    id?: number
    productId: number
    minQty: Decimal | DecimalJsLike | number | string
    maxQty?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type LocationUpdateWithoutWarehouseInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuants?: StockQuantUpdateManyWithoutLocationNestedInput
    stockMovesFrom?: StockMoveUpdateManyWithoutFromLocationNestedInput
    stockMovesTo?: StockMoveUpdateManyWithoutToLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuants?: StockQuantUncheckedUpdateManyWithoutLocationNestedInput
    stockMovesFrom?: StockMoveUncheckedUpdateManyWithoutFromLocationNestedInput
    stockMovesTo?: StockMoveUncheckedUpdateManyWithoutToLocationNestedInput
  }

  export type LocationUncheckedUpdateManyWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockQuantUpdateWithoutWarehouseInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reserved?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incoming?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStockQuantsNestedInput
    location?: LocationUpdateOneWithoutStockQuantsNestedInput
  }

  export type StockQuantUncheckedUpdateWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reserved?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incoming?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockQuantUncheckedUpdateManyWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reserved?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incoming?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptUpdateWithoutWarehouseInput = {
    receiptNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutReceiptsCreatedNestedInput
    lines?: ReceiptLineUpdateManyWithoutReceiptNestedInput
  }

  export type ReceiptUncheckedUpdateWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: ReceiptLineUncheckedUpdateManyWithoutReceiptNestedInput
  }

  export type ReceiptUncheckedUpdateManyWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryUpdateWithoutWarehouseInput = {
    deliveryNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutDeliveriesCreatedNestedInput
    lines?: DeliveryLineUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    deliveryNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: DeliveryLineUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateManyWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    deliveryNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutFromWarehouseInput = {
    transferNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toWarehouse?: WarehouseUpdateOneRequiredWithoutTransfersToNestedInput
    createdBy?: UserUpdateOneWithoutTransfersCreatedNestedInput
    lines?: TransferLineUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutFromWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    transferNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    toWarehouseId?: IntFieldUpdateOperationsInput | number
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: TransferLineUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutFromWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    transferNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    toWarehouseId?: IntFieldUpdateOperationsInput | number
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutToWarehouseInput = {
    transferNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromWarehouse?: WarehouseUpdateOneRequiredWithoutTransfersFromNestedInput
    createdBy?: UserUpdateOneWithoutTransfersCreatedNestedInput
    lines?: TransferLineUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutToWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    transferNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    fromWarehouseId?: IntFieldUpdateOperationsInput | number
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: TransferLineUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutToWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    transferNo?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    fromWarehouseId?: IntFieldUpdateOperationsInput | number
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdjustmentUpdateWithoutWarehouseInput = {
    adjustmentNo?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutAdjustmentsCreatedNestedInput
    lines?: AdjustmentLineUpdateManyWithoutAdjustmentNestedInput
  }

  export type AdjustmentUncheckedUpdateWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    adjustmentNo?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: AdjustmentLineUncheckedUpdateManyWithoutAdjustmentNestedInput
  }

  export type AdjustmentUncheckedUpdateManyWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    adjustmentNo?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMoveUpdateWithoutFromWarehouseInput = {
    moveNo?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStockMovesNestedInput
    toWarehouse?: WarehouseUpdateOneWithoutStockMovesToNestedInput
    fromLocation?: LocationUpdateOneWithoutStockMovesFromNestedInput
    toLocation?: LocationUpdateOneWithoutStockMovesToNestedInput
    createdBy?: UserUpdateOneWithoutStockMovesCreatedNestedInput
  }

  export type StockMoveUncheckedUpdateWithoutFromWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    moveNo?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    toWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    fromLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    toLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMoveUncheckedUpdateManyWithoutFromWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    moveNo?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    toWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    fromLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    toLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMoveUpdateWithoutToWarehouseInput = {
    moveNo?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStockMovesNestedInput
    fromWarehouse?: WarehouseUpdateOneWithoutStockMovesFromNestedInput
    fromLocation?: LocationUpdateOneWithoutStockMovesFromNestedInput
    toLocation?: LocationUpdateOneWithoutStockMovesToNestedInput
    createdBy?: UserUpdateOneWithoutStockMovesCreatedNestedInput
  }

  export type StockMoveUncheckedUpdateWithoutToWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    moveNo?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    fromLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    toLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMoveUncheckedUpdateManyWithoutToWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    moveNo?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    fromLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    toLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReorderRuleUpdateWithoutWarehouseInput = {
    minQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxQty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutReorderRulesNestedInput
  }

  export type ReorderRuleUncheckedUpdateWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    minQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxQty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReorderRuleUncheckedUpdateManyWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    minQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxQty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockQuantCreateManyLocationInput = {
    id?: number
    productId: number
    warehouseId: number
    quantity?: Decimal | DecimalJsLike | number | string
    reserved?: Decimal | DecimalJsLike | number | string
    incoming?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockMoveCreateManyFromLocationInput = {
    id?: number
    moveNo?: string | null
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    fromWarehouseId?: number | null
    toWarehouseId?: number | null
    toLocationId?: number | null
    reason?: string | null
    reference?: string | null
    documentType?: string | null
    documentId?: number | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
  }

  export type StockMoveCreateManyToLocationInput = {
    id?: number
    moveNo?: string | null
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    fromWarehouseId?: number | null
    toWarehouseId?: number | null
    fromLocationId?: number | null
    reason?: string | null
    reference?: string | null
    documentType?: string | null
    documentId?: number | null
    status?: $Enums.DocumentStatus
    createdById?: number | null
    createdAt?: Date | string
  }

  export type StockQuantUpdateWithoutLocationInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reserved?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incoming?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStockQuantsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutStockQuantsNestedInput
  }

  export type StockQuantUncheckedUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reserved?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incoming?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockQuantUncheckedUpdateManyWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reserved?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incoming?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMoveUpdateWithoutFromLocationInput = {
    moveNo?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStockMovesNestedInput
    fromWarehouse?: WarehouseUpdateOneWithoutStockMovesFromNestedInput
    toWarehouse?: WarehouseUpdateOneWithoutStockMovesToNestedInput
    toLocation?: LocationUpdateOneWithoutStockMovesToNestedInput
    createdBy?: UserUpdateOneWithoutStockMovesCreatedNestedInput
  }

  export type StockMoveUncheckedUpdateWithoutFromLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    moveNo?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    toWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    toLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMoveUncheckedUpdateManyWithoutFromLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    moveNo?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    toWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    toLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMoveUpdateWithoutToLocationInput = {
    moveNo?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStockMovesNestedInput
    fromWarehouse?: WarehouseUpdateOneWithoutStockMovesFromNestedInput
    toWarehouse?: WarehouseUpdateOneWithoutStockMovesToNestedInput
    fromLocation?: LocationUpdateOneWithoutStockMovesFromNestedInput
    createdBy?: UserUpdateOneWithoutStockMovesCreatedNestedInput
  }

  export type StockMoveUncheckedUpdateWithoutToLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    moveNo?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    toWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    fromLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMoveUncheckedUpdateManyWithoutToLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    moveNo?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    toWarehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    fromLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptLineCreateManyReceiptInput = {
    id?: number
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
  }

  export type ReceiptLineUpdateWithoutReceiptInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product?: ProductUpdateOneRequiredWithoutReceiptLinesNestedInput
  }

  export type ReceiptLineUncheckedUpdateWithoutReceiptInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ReceiptLineUncheckedUpdateManyWithoutReceiptInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type DeliveryLineCreateManyDeliveryInput = {
    id?: number
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    unitPrice?: Decimal | DecimalJsLike | number | string | null
  }

  export type DeliveryLineUpdateWithoutDeliveryInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product?: ProductUpdateOneRequiredWithoutDeliveryLinesNestedInput
  }

  export type DeliveryLineUncheckedUpdateWithoutDeliveryInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type DeliveryLineUncheckedUpdateManyWithoutDeliveryInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type TransferLineCreateManyTransferInput = {
    id?: number
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
  }

  export type TransferLineUpdateWithoutTransferInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutTransferLinesNestedInput
  }

  export type TransferLineUncheckedUpdateWithoutTransferInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
  }

  export type TransferLineUncheckedUpdateManyWithoutTransferInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
  }

  export type AdjustmentLineCreateManyAdjustmentInput = {
    id?: number
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    uom: string
    note?: string | null
  }

  export type AdjustmentLineUpdateWithoutAdjustmentInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutAdjustmentLinesNestedInput
  }

  export type AdjustmentLineUncheckedUpdateWithoutAdjustmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdjustmentLineUncheckedUpdateManyWithoutAdjustmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uom?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}